(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
    else if (typeof define === "function" && define.amd)
        define("@purefunction/jsutils", [], factory);
    else if (typeof exports === "object")
        exports["@purefunction/jsutils"] = factory();
    else root["@purefunction/jsutils"] = factory();
})(typeof self !== "undefined" ? self : this, function () {
    return /******/ (function (modules) {
        // webpackBootstrap
        /******/ // The module cache
        /******/ var installedModules = {}; // The require function
        /******/
        /******/ /******/ function __webpack_require__(moduleId) {
            /******/
            /******/ // Check if module is in cache
            /******/ if (installedModules[moduleId]) {
                /******/ return installedModules[moduleId].exports;
                /******/
            } // Create a new module (and put it into the cache)
            /******/ /******/ var module = (installedModules[moduleId] = {
                /******/ i: moduleId,
                /******/ l: false,
                /******/ exports: {},
                /******/
            }); // Execute the module function
            /******/
            /******/ /******/ modules[moduleId].call(
                module.exports,
                module,
                module.exports,
                __webpack_require__
            ); // Flag the module as loaded
            /******/
            /******/ /******/ module.l = true; // Return the exports of the module
            /******/
            /******/ /******/ return module.exports;
            /******/
        } // expose the modules object (__webpack_modules__)
        /******/
        /******/
        /******/ /******/ __webpack_require__.m = modules; // expose the module cache
        /******/
        /******/ /******/ __webpack_require__.c = installedModules; // define getter function for harmony exports
        /******/
        /******/ /******/ __webpack_require__.d = function (
            exports,
            name,
            getter
        ) {
            /******/ if (!__webpack_require__.o(exports, name)) {
                /******/ Object.defineProperty(exports, name, {
                    enumerable: true,
                    get: getter,
                });
                /******/
            }
            /******/
        }; // define __esModule on exports
        /******/
        /******/ /******/ __webpack_require__.r = function (exports) {
            /******/ if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                /******/ Object.defineProperty(exports, Symbol.toStringTag, {
                    value: "Module",
                });
                /******/
            }
            /******/ Object.defineProperty(exports, "__esModule", {
                value: true,
            });
            /******/
        }; // create a fake namespace object // mode & 1: value is a module id, require it // mode & 2: merge all properties of value into the ns // mode & 4: return value when already ns object // mode & 8|1: behave like require
        /******/
        /******/ /******/ /******/ /******/ /******/ /******/ __webpack_require__.t = function (
            value,
            mode
        ) {
            /******/ if (mode & 1) value = __webpack_require__(value);
            /******/ if (mode & 8) return value;
            /******/ if (
                mode & 4 &&
                typeof value === "object" &&
                value &&
                value.__esModule
            )
                return value;
            /******/ var ns = Object.create(null);
            /******/ __webpack_require__.r(ns);
            /******/ Object.defineProperty(ns, "default", {
                enumerable: true,
                value: value,
            });
            /******/ if (mode & 2 && typeof value != "string")
                for (var key in value)
                    __webpack_require__.d(
                        ns,
                        key,
                        function (key) {
                            return value[key];
                        }.bind(null, key)
                    );
            /******/ return ns;
            /******/
        }; // getDefaultExport function for compatibility with non-harmony modules
        /******/
        /******/ /******/ __webpack_require__.n = function (module) {
            /******/ var getter =
                module && module.__esModule
                    ? /******/ function getDefault() {
                          return module["default"];
                      }
                    : /******/ function getModuleExports() {
                          return module;
                      };
            /******/ __webpack_require__.d(getter, "a", getter);
            /******/ return getter;
            /******/
        }; // Object.prototype.hasOwnProperty.call
        /******/
        /******/ /******/ __webpack_require__.o = function (object, property) {
            return Object.prototype.hasOwnProperty.call(object, property);
        }; // __webpack_public_path__
        /******/
        /******/ /******/ __webpack_require__.p = ""; // Load entry module and return exports
        /******/
        /******/
        /******/ /******/ return __webpack_require__(
            (__webpack_require__.s = "./src/index.js")
        );
        /******/
    })(
        /************************************************************************/
        /******/ {
            /***/ "./node_modules/brackets2dots/index.js":
                /*!*********************************************!*\
  !*** ./node_modules/brackets2dots/index.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    /*!
                     * exports.
                     */

                    module.exports = brackets2dots;
                    /*!
                     * regexp patterns.
                     */

                    var REPLACE_BRACKETS = /\[([^\[\]]+)\]/g;
                    var LFT_RT_TRIM_DOTS = /^[.]*|[.]*$/g;
                    /**
                     * Convert string with bracket notation to dot property notation.
                     *
                     * ### Examples:
                     *
                     *      brackets2dots('group[0].section.a.seat[3]')
                     *      //=> 'group.0.section.a.seat.3'
                     *
                     *      brackets2dots('[0].section.a.seat[3]')
                     *      //=> '0.section.a.seat.3'
                     *
                     *      brackets2dots('people[*].age')
                     *      //=> 'people.*.age'
                     *
                     * @param  {String} string
                     * original string
                     *
                     * @return {String}
                     * dot/bracket-notation string
                     */

                    function brackets2dots(string) {
                        return {}.toString.call(string) == "[object String]"
                            ? string
                                  .replace(REPLACE_BRACKETS, ".$1")
                                  .replace(LFT_RT_TRIM_DOTS, "")
                            : "";
                    }

                    /***/
                },

            /***/ "./node_modules/curry2/index.js":
                /*!**************************************!*\
  !*** ./node_modules/curry2/index.js ***!
  \**************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    /*!
                     * imports.
                     */

                    var bind =
                        Function.prototype.bind ||
                        __webpack_require__(
                            /*! fast-bind */ "./node_modules/fast-bind/bind-loop.js"
                        );
                    /*!
                     * exports.
                     */

                    module.exports = curry2;
                    /**
                     * Curry a binary function.
                     *
                     * @param {Function} fn
                     * Binary function to curry.
                     *
                     * @param {Object} [self]
                     * Function `this` context.
                     *
                     * @return {Function|*}
                     * If partially applied, return unary function, otherwise, return result of full application.
                     */

                    function curry2(fn, self) {
                        var out = function () {
                            if (arguments.length === 0) return out;
                            return arguments.length > 1
                                ? fn.apply(self, arguments)
                                : bind.call(fn, self, arguments[0]);
                        };

                        out.uncurry = function uncurry() {
                            return fn;
                        };

                        return out;
                    }

                    /***/
                },

            /***/ "./node_modules/debug/src/browser.js":
                /*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (process) {
                        /* eslint-env browser */

                        /**
                         * This is the web browser implementation of `debug()`.
                         */
                        exports.log = log;
                        exports.formatArgs = formatArgs;
                        exports.save = save;
                        exports.load = load;
                        exports.useColors = useColors;
                        exports.storage = localstorage();
                        /**
                         * Colors.
                         */

                        exports.colors = [
                            "#0000CC",
                            "#0000FF",
                            "#0033CC",
                            "#0033FF",
                            "#0066CC",
                            "#0066FF",
                            "#0099CC",
                            "#0099FF",
                            "#00CC00",
                            "#00CC33",
                            "#00CC66",
                            "#00CC99",
                            "#00CCCC",
                            "#00CCFF",
                            "#3300CC",
                            "#3300FF",
                            "#3333CC",
                            "#3333FF",
                            "#3366CC",
                            "#3366FF",
                            "#3399CC",
                            "#3399FF",
                            "#33CC00",
                            "#33CC33",
                            "#33CC66",
                            "#33CC99",
                            "#33CCCC",
                            "#33CCFF",
                            "#6600CC",
                            "#6600FF",
                            "#6633CC",
                            "#6633FF",
                            "#66CC00",
                            "#66CC33",
                            "#9900CC",
                            "#9900FF",
                            "#9933CC",
                            "#9933FF",
                            "#99CC00",
                            "#99CC33",
                            "#CC0000",
                            "#CC0033",
                            "#CC0066",
                            "#CC0099",
                            "#CC00CC",
                            "#CC00FF",
                            "#CC3300",
                            "#CC3333",
                            "#CC3366",
                            "#CC3399",
                            "#CC33CC",
                            "#CC33FF",
                            "#CC6600",
                            "#CC6633",
                            "#CC9900",
                            "#CC9933",
                            "#CCCC00",
                            "#CCCC33",
                            "#FF0000",
                            "#FF0033",
                            "#FF0066",
                            "#FF0099",
                            "#FF00CC",
                            "#FF00FF",
                            "#FF3300",
                            "#FF3333",
                            "#FF3366",
                            "#FF3399",
                            "#FF33CC",
                            "#FF33FF",
                            "#FF6600",
                            "#FF6633",
                            "#FF9900",
                            "#FF9933",
                            "#FFCC00",
                            "#FFCC33",
                        ];
                        /**
                         * Currently only WebKit-based Web Inspectors, Firefox >= v31,
                         * and the Firebug extension (any Firefox version) are known
                         * to support "%c" CSS customizations.
                         *
                         * TODO: add a `localStorage` variable to explicitly enable/disable colors
                         */
                        // eslint-disable-next-line complexity

                        function useColors() {
                            // NB: In an Electron preload script, document will be defined but not fully
                            // initialized. Since we know we're in Chrome, we'll just detect this case
                            // explicitly
                            if (
                                typeof window !== "undefined" &&
                                window.process &&
                                (window.process.type === "renderer" ||
                                    window.process.__nwjs)
                            ) {
                                return true;
                            } // Internet Explorer and Edge do not support colors.

                            if (
                                typeof navigator !== "undefined" &&
                                navigator.userAgent &&
                                navigator.userAgent
                                    .toLowerCase()
                                    .match(/(edge|trident)\/(\d+)/)
                            ) {
                                return false;
                            } // Is webkit? http://stackoverflow.com/a/16459606/376773
                            // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632

                            return (
                                (typeof document !== "undefined" &&
                                    document.documentElement &&
                                    document.documentElement.style &&
                                    document.documentElement.style
                                        .WebkitAppearance) || // Is firebug? http://stackoverflow.com/a/398120/376773
                                (typeof window !== "undefined" &&
                                    window.console &&
                                    (window.console.firebug ||
                                        (window.console.exception &&
                                            window.console.table))) || // Is firefox >= v31?
                                // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
                                (typeof navigator !== "undefined" &&
                                    navigator.userAgent &&
                                    navigator.userAgent
                                        .toLowerCase()
                                        .match(/firefox\/(\d+)/) &&
                                    parseInt(RegExp.$1, 10) >= 31) || // Double check webkit in userAgent just in case we are in a worker
                                (typeof navigator !== "undefined" &&
                                    navigator.userAgent &&
                                    navigator.userAgent
                                        .toLowerCase()
                                        .match(/applewebkit\/(\d+)/))
                            );
                        }
                        /**
                         * Colorize log arguments if enabled.
                         *
                         * @api public
                         */

                        function formatArgs(args) {
                            args[0] =
                                (this.useColors ? "%c" : "") +
                                this.namespace +
                                (this.useColors ? " %c" : " ") +
                                args[0] +
                                (this.useColors ? "%c " : " ") +
                                "+" +
                                module.exports.humanize(this.diff);

                            if (!this.useColors) {
                                return;
                            }

                            const c = "color: " + this.color;
                            args.splice(1, 0, c, "color: inherit"); // The final "%c" is somewhat tricky, because there could be other
                            // arguments passed either before or after the %c, so we need to
                            // figure out the correct index to insert the CSS into

                            let index = 0;
                            let lastC = 0;
                            args[0].replace(/%[a-zA-Z%]/g, (match) => {
                                if (match === "%%") {
                                    return;
                                }

                                index++;

                                if (match === "%c") {
                                    // We only are interested in the *last* %c
                                    // (the user may have provided their own)
                                    lastC = index;
                                }
                            });
                            args.splice(lastC, 0, c);
                        }
                        /**
                         * Invokes `console.log()` when available.
                         * No-op when `console.log` is not a "function".
                         *
                         * @api public
                         */

                        function log(...args) {
                            // This hackery is required for IE8/9, where
                            // the `console.log` function doesn't have 'apply'
                            return (
                                typeof console === "object" &&
                                console.log &&
                                console.log(...args)
                            );
                        }
                        /**
                         * Save `namespaces`.
                         *
                         * @param {String} namespaces
                         * @api private
                         */

                        function save(namespaces) {
                            try {
                                if (namespaces) {
                                    exports.storage.setItem(
                                        "debug",
                                        namespaces
                                    );
                                } else {
                                    exports.storage.removeItem("debug");
                                }
                            } catch (error) {
                                // Swallow
                                // XXX (@Qix-) should we be logging these?
                            }
                        }
                        /**
                         * Load `namespaces`.
                         *
                         * @return {String} returns the previously persisted debug modes
                         * @api private
                         */

                        function load() {
                            let r;

                            try {
                                r = exports.storage.getItem("debug");
                            } catch (error) {} // Swallow
                            // XXX (@Qix-) should we be logging these?
                            // If debug isn't set in LS, and we're in Electron, try to load $DEBUG

                            if (
                                !r &&
                                typeof process !== "undefined" &&
                                "env" in process
                            ) {
                                r = process.env.DEBUG;
                            }

                            return r;
                        }
                        /**
                         * Localstorage attempts to return the localstorage.
                         *
                         * This is necessary because safari throws
                         * when a user disables cookies/localstorage
                         * and you attempt to access it.
                         *
                         * @return {LocalStorage}
                         * @api private
                         */

                        function localstorage() {
                            try {
                                // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
                                // The Browser also has localStorage in the global context.
                                return localStorage;
                            } catch (error) {
                                // Swallow
                                // XXX (@Qix-) should we be logging these?
                            }
                        }

                        module.exports = __webpack_require__(
                            /*! ./common */ "./node_modules/debug/src/common.js"
                        )(exports);
                        const { formatters } = module.exports;
                        /**
                         * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
                         */

                        formatters.j = function (v) {
                            try {
                                return JSON.stringify(v);
                            } catch (error) {
                                return (
                                    "[UnexpectedJSONParseError]: " +
                                    error.message
                                );
                            }
                        };
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../../process/browser.js */ "./node_modules/process/browser.js"
                        )
                    ));

                    /***/
                },

            /***/ "./node_modules/debug/src/common.js":
                /*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /**
                     * This is the common logic for both the Node.js and web browser
                     * implementations of `debug()`.
                     */
                    function setup(env) {
                        createDebug.debug = createDebug;
                        createDebug.default = createDebug;
                        createDebug.coerce = coerce;
                        createDebug.disable = disable;
                        createDebug.enable = enable;
                        createDebug.enabled = enabled;
                        createDebug.humanize = __webpack_require__(
                            /*! ms */ "./node_modules/ms/index.js"
                        );
                        Object.keys(env).forEach((key) => {
                            createDebug[key] = env[key];
                        });
                        /**
                         * Active `debug` instances.
                         */

                        createDebug.instances = [];
                        /**
                         * The currently active debug mode names, and names to skip.
                         */

                        createDebug.names = [];
                        createDebug.skips = [];
                        /**
                         * Map of special "%n" handling functions, for the debug "format" argument.
                         *
                         * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
                         */

                        createDebug.formatters = {};
                        /**
                         * Selects a color for a debug namespace
                         * @param {String} namespace The namespace string for the for the debug instance to be colored
                         * @return {Number|String} An ANSI color code for the given namespace
                         * @api private
                         */

                        function selectColor(namespace) {
                            let hash = 0;

                            for (let i = 0; i < namespace.length; i++) {
                                hash =
                                    (hash << 5) -
                                    hash +
                                    namespace.charCodeAt(i);
                                hash |= 0; // Convert to 32bit integer
                            }

                            return createDebug.colors[
                                Math.abs(hash) % createDebug.colors.length
                            ];
                        }

                        createDebug.selectColor = selectColor;
                        /**
                         * Create a debugger with the given `namespace`.
                         *
                         * @param {String} namespace
                         * @return {Function}
                         * @api public
                         */

                        function createDebug(namespace) {
                            let prevTime;

                            function debug(...args) {
                                // Disabled?
                                if (!debug.enabled) {
                                    return;
                                }

                                const self = debug; // Set `diff` timestamp

                                const curr = Number(new Date());
                                const ms = curr - (prevTime || curr);
                                self.diff = ms;
                                self.prev = prevTime;
                                self.curr = curr;
                                prevTime = curr;
                                args[0] = createDebug.coerce(args[0]);

                                if (typeof args[0] !== "string") {
                                    // Anything else let's inspect with %O
                                    args.unshift("%O");
                                } // Apply any `formatters` transformations

                                let index = 0;
                                args[0] = args[0].replace(
                                    /%([a-zA-Z%])/g,
                                    (match, format) => {
                                        // If we encounter an escaped % then don't increase the array index
                                        if (match === "%%") {
                                            return match;
                                        }

                                        index++;
                                        const formatter =
                                            createDebug.formatters[format];

                                        if (typeof formatter === "function") {
                                            const val = args[index];
                                            match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

                                            args.splice(index, 1);
                                            index--;
                                        }

                                        return match;
                                    }
                                ); // Apply env-specific formatting (colors, etc.)

                                createDebug.formatArgs.call(self, args);
                                const logFn = self.log || createDebug.log;
                                logFn.apply(self, args);
                            }

                            debug.namespace = namespace;
                            debug.enabled = createDebug.enabled(namespace);
                            debug.useColors = createDebug.useColors();
                            debug.color = selectColor(namespace);
                            debug.destroy = destroy;
                            debug.extend = extend; // Debug.formatArgs = formatArgs;
                            // debug.rawLog = rawLog;
                            // env-specific initialization logic for debug instances

                            if (typeof createDebug.init === "function") {
                                createDebug.init(debug);
                            }

                            createDebug.instances.push(debug);
                            return debug;
                        }

                        function destroy() {
                            const index = createDebug.instances.indexOf(this);

                            if (index !== -1) {
                                createDebug.instances.splice(index, 1);
                                return true;
                            }

                            return false;
                        }

                        function extend(namespace, delimiter) {
                            const newDebug = createDebug(
                                this.namespace +
                                    (typeof delimiter === "undefined"
                                        ? ":"
                                        : delimiter) +
                                    namespace
                            );
                            newDebug.log = this.log;
                            return newDebug;
                        }
                        /**
                         * Enables a debug mode by namespaces. This can include modes
                         * separated by a colon and wildcards.
                         *
                         * @param {String} namespaces
                         * @api public
                         */

                        function enable(namespaces) {
                            createDebug.save(namespaces);
                            createDebug.names = [];
                            createDebug.skips = [];
                            let i;
                            const split = (typeof namespaces === "string"
                                ? namespaces
                                : ""
                            ).split(/[\s,]+/);
                            const len = split.length;

                            for (i = 0; i < len; i++) {
                                if (!split[i]) {
                                    // ignore empty strings
                                    continue;
                                }

                                namespaces = split[i].replace(/\*/g, ".*?");

                                if (namespaces[0] === "-") {
                                    createDebug.skips.push(
                                        new RegExp(
                                            "^" + namespaces.substr(1) + "$"
                                        )
                                    );
                                } else {
                                    createDebug.names.push(
                                        new RegExp("^" + namespaces + "$")
                                    );
                                }
                            }

                            for (i = 0; i < createDebug.instances.length; i++) {
                                const instance = createDebug.instances[i];
                                instance.enabled = createDebug.enabled(
                                    instance.namespace
                                );
                            }
                        }
                        /**
                         * Disable debug output.
                         *
                         * @return {String} namespaces
                         * @api public
                         */

                        function disable() {
                            const namespaces = [
                                ...createDebug.names.map(toNamespace),
                                ...createDebug.skips
                                    .map(toNamespace)
                                    .map((namespace) => "-" + namespace),
                            ].join(",");
                            createDebug.enable("");
                            return namespaces;
                        }
                        /**
                         * Returns true if the given mode name is enabled, false otherwise.
                         *
                         * @param {String} name
                         * @return {Boolean}
                         * @api public
                         */

                        function enabled(name) {
                            if (name[name.length - 1] === "*") {
                                return true;
                            }

                            let i;
                            let len;

                            for (
                                i = 0, len = createDebug.skips.length;
                                i < len;
                                i++
                            ) {
                                if (createDebug.skips[i].test(name)) {
                                    return false;
                                }
                            }

                            for (
                                i = 0, len = createDebug.names.length;
                                i < len;
                                i++
                            ) {
                                if (createDebug.names[i].test(name)) {
                                    return true;
                                }
                            }

                            return false;
                        }
                        /**
                         * Convert regexp to namespace
                         *
                         * @param {RegExp} regxep
                         * @return {String} namespace
                         * @api private
                         */

                        function toNamespace(regexp) {
                            return regexp
                                .toString()
                                .substring(2, regexp.toString().length - 2)
                                .replace(/\.\*\?$/, "*");
                        }
                        /**
                         * Coerce `val`.
                         *
                         * @param {Mixed} val
                         * @return {Mixed}
                         * @api private
                         */

                        function coerce(val) {
                            if (val instanceof Error) {
                                return val.stack || val.message;
                            }

                            return val;
                        }

                        createDebug.enable(createDebug.load());
                        return createDebug;
                    }

                    module.exports = setup;

                    /***/
                },

            /***/ "./node_modules/dotsplit.js/index.js":
                /*!*******************************************!*\
  !*** ./node_modules/dotsplit.js/index.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    var toString = Object.prototype.toString;
                    /**
                     * Transform dot-delimited strings to array of strings.
                     *
                     * @param  {String} string
                     * Dot-delimited string.
                     *
                     * @return {Array}
                     * Array of strings.
                     */

                    function dotsplit(string) {
                        var idx = -1;
                        var str = compact(normalize(string).split("."));
                        var end = str.length;
                        var out = [];

                        while (++idx < end) {
                            out.push(todots(str[idx]));
                        }

                        return out;
                    }
                    /**
                     * Replace escapes with a placeholder.
                     *
                     * @param  {String} string
                     * Dot-delimited string.
                     *
                     * @return {String}
                     * Dot-delimited string with placeholders in place of escapes.
                     */

                    function normalize(string) {
                        return (toString.call(string) === "[object String]"
                            ? string
                            : ""
                        ).replace(/\\\./g, "\uffff");
                    }
                    /**
                     * Drop empty values from array.
                     *
                     * @param  {Array} array
                     * Array of strings.
                     *
                     * @return {Array}
                     * Array of strings (empty values dropped).
                     */

                    function compact(arr) {
                        var idx = -1;
                        var end = arr.length;
                        var out = [];

                        while (++idx < end) {
                            if (arr[idx]) out.push(arr[idx]);
                        }

                        return out;
                    }
                    /**
                     * Change placeholder to dots.
                     *
                     * @param  {String} string
                     * Dot-delimited string with placeholders.
                     *
                     * @return {String}
                     * Dot-delimited string without placeholders.
                     */

                    function todots(string) {
                        return string.replace(/\uffff/g, ".");
                    }
                    /*!
                     * exports.
                     */

                    module.exports = dotsplit;

                    /***/
                },

            /***/ "./node_modules/es6-promise/dist/es6-promise.js":
                /*!******************************************************!*\
  !*** ./node_modules/es6-promise/dist/es6-promise.js ***!
  \******************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (process, global) {
                        /*!
                         * @overview es6-promise - a tiny implementation of Promises/A+.
                         * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
                         * @license   Licensed under MIT license
                         *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
                         * @version   v4.2.8+1e68dce6
                         */
                        (function (global, factory) {
                            true ? (module.exports = factory()) : undefined;
                        })(this, function () {
                            "use strict";

                            function objectOrFunction(x) {
                                var type = typeof x;
                                return (
                                    x !== null &&
                                    (type === "object" || type === "function")
                                );
                            }

                            function isFunction(x) {
                                return typeof x === "function";
                            }

                            var _isArray = void 0;

                            if (Array.isArray) {
                                _isArray = Array.isArray;
                            } else {
                                _isArray = function (x) {
                                    return (
                                        Object.prototype.toString.call(x) ===
                                        "[object Array]"
                                    );
                                };
                            }

                            var isArray = _isArray;
                            var len = 0;
                            var vertxNext = void 0;
                            var customSchedulerFn = void 0;

                            var asap = function asap(callback, arg) {
                                queue[len] = callback;
                                queue[len + 1] = arg;
                                len += 2;

                                if (len === 2) {
                                    // If len is 2, that means that we need to schedule an async flush.
                                    // If additional callbacks are queued before the queue is flushed, they
                                    // will be processed by this flush that we are scheduling.
                                    if (customSchedulerFn) {
                                        customSchedulerFn(flush);
                                    } else {
                                        scheduleFlush();
                                    }
                                }
                            };

                            function setScheduler(scheduleFn) {
                                customSchedulerFn = scheduleFn;
                            }

                            function setAsap(asapFn) {
                                asap = asapFn;
                            }

                            var browserWindow =
                                typeof window !== "undefined"
                                    ? window
                                    : undefined;
                            var browserGlobal = browserWindow || {};
                            var BrowserMutationObserver =
                                browserGlobal.MutationObserver ||
                                browserGlobal.WebKitMutationObserver;
                            var isNode =
                                typeof self === "undefined" &&
                                typeof process !== "undefined" &&
                                {}.toString.call(process) ===
                                    "[object process]"; // test for web worker but not in IE10

                            var isWorker =
                                typeof Uint8ClampedArray !== "undefined" &&
                                typeof importScripts !== "undefined" &&
                                typeof MessageChannel !== "undefined"; // node

                            function useNextTick() {
                                // node version 0.10.x displays a deprecation warning when nextTick is used recursively
                                // see https://github.com/cujojs/when/issues/410 for details
                                return function () {
                                    return process.nextTick(flush);
                                };
                            } // vertx

                            function useVertxTimer() {
                                if (typeof vertxNext !== "undefined") {
                                    return function () {
                                        vertxNext(flush);
                                    };
                                }

                                return useSetTimeout();
                            }

                            function useMutationObserver() {
                                var iterations = 0;
                                var observer = new BrowserMutationObserver(
                                    flush
                                );
                                var node = document.createTextNode("");
                                observer.observe(node, {
                                    characterData: true,
                                });
                                return function () {
                                    node.data = iterations = ++iterations % 2;
                                };
                            } // web worker

                            function useMessageChannel() {
                                var channel = new MessageChannel();
                                channel.port1.onmessage = flush;
                                return function () {
                                    return channel.port2.postMessage(0);
                                };
                            }

                            function useSetTimeout() {
                                // Store setTimeout reference so es6-promise will be unaffected by
                                // other code modifying setTimeout (like sinon.useFakeTimers())
                                var globalSetTimeout = setTimeout;
                                return function () {
                                    return globalSetTimeout(flush, 1);
                                };
                            }

                            var queue = new Array(1000);

                            function flush() {
                                for (var i = 0; i < len; i += 2) {
                                    var callback = queue[i];
                                    var arg = queue[i + 1];
                                    callback(arg);
                                    queue[i] = undefined;
                                    queue[i + 1] = undefined;
                                }

                                len = 0;
                            }

                            function attemptVertx() {
                                try {
                                    var vertx = Function(
                                        "return this"
                                    )().require("vertx");

                                    vertxNext =
                                        vertx.runOnLoop || vertx.runOnContext;
                                    return useVertxTimer();
                                } catch (e) {
                                    return useSetTimeout();
                                }
                            }

                            var scheduleFlush = void 0; // Decide what async method to use to triggering processing of queued callbacks:

                            if (isNode) {
                                scheduleFlush = useNextTick();
                            } else if (BrowserMutationObserver) {
                                scheduleFlush = useMutationObserver();
                            } else if (isWorker) {
                                scheduleFlush = useMessageChannel();
                            } else if (
                                browserWindow === undefined &&
                                "function" === "function"
                            ) {
                                scheduleFlush = attemptVertx();
                            } else {
                                scheduleFlush = useSetTimeout();
                            }

                            function then(onFulfillment, onRejection) {
                                var parent = this;
                                var child = new this.constructor(noop);

                                if (child[PROMISE_ID] === undefined) {
                                    makePromise(child);
                                }

                                var _state = parent._state;

                                if (_state) {
                                    var callback = arguments[_state - 1];
                                    asap(function () {
                                        return invokeCallback(
                                            _state,
                                            child,
                                            callback,
                                            parent._result
                                        );
                                    });
                                } else {
                                    subscribe(
                                        parent,
                                        child,
                                        onFulfillment,
                                        onRejection
                                    );
                                }

                                return child;
                            }
                            /**
    `Promise.resolve` returns a promise that will become resolved with the
    passed `value`. It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      resolve(1);
    });
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.resolve(1);
  
    promise.then(function(value){
      // value === 1
    });
    ```
  
    @method resolve
    @static
    @param {Any} value value that the returned promise will be resolved with
    Useful for tooling.
    @return {Promise} a promise that will become fulfilled with the given
    `value`
  */

                            function resolve$1(object) {
                                /*jshint validthis:true */
                                var Constructor = this;

                                if (
                                    object &&
                                    typeof object === "object" &&
                                    object.constructor === Constructor
                                ) {
                                    return object;
                                }

                                var promise = new Constructor(noop);
                                resolve(promise, object);
                                return promise;
                            }

                            var PROMISE_ID = Math.random()
                                .toString(36)
                                .substring(2);

                            function noop() {}

                            var PENDING = void 0;
                            var FULFILLED = 1;
                            var REJECTED = 2;

                            function selfFulfillment() {
                                return new TypeError(
                                    "You cannot resolve a promise with itself"
                                );
                            }

                            function cannotReturnOwn() {
                                return new TypeError(
                                    "A promises callback cannot return that same promise."
                                );
                            }

                            function tryThen(
                                then$$1,
                                value,
                                fulfillmentHandler,
                                rejectionHandler
                            ) {
                                try {
                                    then$$1.call(
                                        value,
                                        fulfillmentHandler,
                                        rejectionHandler
                                    );
                                } catch (e) {
                                    return e;
                                }
                            }

                            function handleForeignThenable(
                                promise,
                                thenable,
                                then$$1
                            ) {
                                asap(function (promise) {
                                    var sealed = false;
                                    var error = tryThen(
                                        then$$1,
                                        thenable,
                                        function (value) {
                                            if (sealed) {
                                                return;
                                            }

                                            sealed = true;

                                            if (thenable !== value) {
                                                resolve(promise, value);
                                            } else {
                                                fulfill(promise, value);
                                            }
                                        },
                                        function (reason) {
                                            if (sealed) {
                                                return;
                                            }

                                            sealed = true;
                                            reject(promise, reason);
                                        },
                                        "Settle: " +
                                            (promise._label ||
                                                " unknown promise")
                                    );

                                    if (!sealed && error) {
                                        sealed = true;
                                        reject(promise, error);
                                    }
                                }, promise);
                            }

                            function handleOwnThenable(promise, thenable) {
                                if (thenable._state === FULFILLED) {
                                    fulfill(promise, thenable._result);
                                } else if (thenable._state === REJECTED) {
                                    reject(promise, thenable._result);
                                } else {
                                    subscribe(
                                        thenable,
                                        undefined,
                                        function (value) {
                                            return resolve(promise, value);
                                        },
                                        function (reason) {
                                            return reject(promise, reason);
                                        }
                                    );
                                }
                            }

                            function handleMaybeThenable(
                                promise,
                                maybeThenable,
                                then$$1
                            ) {
                                if (
                                    maybeThenable.constructor ===
                                        promise.constructor &&
                                    then$$1 === then &&
                                    maybeThenable.constructor.resolve ===
                                        resolve$1
                                ) {
                                    handleOwnThenable(promise, maybeThenable);
                                } else {
                                    if (then$$1 === undefined) {
                                        fulfill(promise, maybeThenable);
                                    } else if (isFunction(then$$1)) {
                                        handleForeignThenable(
                                            promise,
                                            maybeThenable,
                                            then$$1
                                        );
                                    } else {
                                        fulfill(promise, maybeThenable);
                                    }
                                }
                            }

                            function resolve(promise, value) {
                                if (promise === value) {
                                    reject(promise, selfFulfillment());
                                } else if (objectOrFunction(value)) {
                                    var then$$1 = void 0;

                                    try {
                                        then$$1 = value.then;
                                    } catch (error) {
                                        reject(promise, error);
                                        return;
                                    }

                                    handleMaybeThenable(
                                        promise,
                                        value,
                                        then$$1
                                    );
                                } else {
                                    fulfill(promise, value);
                                }
                            }

                            function publishRejection(promise) {
                                if (promise._onerror) {
                                    promise._onerror(promise._result);
                                }

                                publish(promise);
                            }

                            function fulfill(promise, value) {
                                if (promise._state !== PENDING) {
                                    return;
                                }

                                promise._result = value;
                                promise._state = FULFILLED;

                                if (promise._subscribers.length !== 0) {
                                    asap(publish, promise);
                                }
                            }

                            function reject(promise, reason) {
                                if (promise._state !== PENDING) {
                                    return;
                                }

                                promise._state = REJECTED;
                                promise._result = reason;
                                asap(publishRejection, promise);
                            }

                            function subscribe(
                                parent,
                                child,
                                onFulfillment,
                                onRejection
                            ) {
                                var _subscribers = parent._subscribers;
                                var length = _subscribers.length;
                                parent._onerror = null;
                                _subscribers[length] = child;
                                _subscribers[
                                    length + FULFILLED
                                ] = onFulfillment;
                                _subscribers[length + REJECTED] = onRejection;

                                if (length === 0 && parent._state) {
                                    asap(publish, parent);
                                }
                            }

                            function publish(promise) {
                                var subscribers = promise._subscribers;
                                var settled = promise._state;

                                if (subscribers.length === 0) {
                                    return;
                                }

                                var child = void 0,
                                    callback = void 0,
                                    detail = promise._result;

                                for (
                                    var i = 0;
                                    i < subscribers.length;
                                    i += 3
                                ) {
                                    child = subscribers[i];
                                    callback = subscribers[i + settled];

                                    if (child) {
                                        invokeCallback(
                                            settled,
                                            child,
                                            callback,
                                            detail
                                        );
                                    } else {
                                        callback(detail);
                                    }
                                }

                                promise._subscribers.length = 0;
                            }

                            function invokeCallback(
                                settled,
                                promise,
                                callback,
                                detail
                            ) {
                                var hasCallback = isFunction(callback),
                                    value = void 0,
                                    error = void 0,
                                    succeeded = true;

                                if (hasCallback) {
                                    try {
                                        value = callback(detail);
                                    } catch (e) {
                                        succeeded = false;
                                        error = e;
                                    }

                                    if (promise === value) {
                                        reject(promise, cannotReturnOwn());
                                        return;
                                    }
                                } else {
                                    value = detail;
                                }

                                if (promise._state !== PENDING) {
                                    // noop
                                } else if (hasCallback && succeeded) {
                                    resolve(promise, value);
                                } else if (succeeded === false) {
                                    reject(promise, error);
                                } else if (settled === FULFILLED) {
                                    fulfill(promise, value);
                                } else if (settled === REJECTED) {
                                    reject(promise, value);
                                }
                            }

                            function initializePromise(promise, resolver) {
                                try {
                                    resolver(
                                        function resolvePromise(value) {
                                            resolve(promise, value);
                                        },
                                        function rejectPromise(reason) {
                                            reject(promise, reason);
                                        }
                                    );
                                } catch (e) {
                                    reject(promise, e);
                                }
                            }

                            var id = 0;

                            function nextId() {
                                return id++;
                            }

                            function makePromise(promise) {
                                promise[PROMISE_ID] = id++;
                                promise._state = undefined;
                                promise._result = undefined;
                                promise._subscribers = [];
                            }

                            function validationError() {
                                return new Error(
                                    "Array Methods must be provided an Array"
                                );
                            }

                            var Enumerator = (function () {
                                function Enumerator(Constructor, input) {
                                    this._instanceConstructor = Constructor;
                                    this.promise = new Constructor(noop);

                                    if (!this.promise[PROMISE_ID]) {
                                        makePromise(this.promise);
                                    }

                                    if (isArray(input)) {
                                        this.length = input.length;
                                        this._remaining = input.length;
                                        this._result = new Array(this.length);

                                        if (this.length === 0) {
                                            fulfill(this.promise, this._result);
                                        } else {
                                            this.length = this.length || 0;

                                            this._enumerate(input);

                                            if (this._remaining === 0) {
                                                fulfill(
                                                    this.promise,
                                                    this._result
                                                );
                                            }
                                        }
                                    } else {
                                        reject(this.promise, validationError());
                                    }
                                }

                                Enumerator.prototype._enumerate = function _enumerate(
                                    input
                                ) {
                                    for (
                                        var i = 0;
                                        this._state === PENDING &&
                                        i < input.length;
                                        i++
                                    ) {
                                        this._eachEntry(input[i], i);
                                    }
                                };

                                Enumerator.prototype._eachEntry = function _eachEntry(
                                    entry,
                                    i
                                ) {
                                    var c = this._instanceConstructor;
                                    var resolve$$1 = c.resolve;

                                    if (resolve$$1 === resolve$1) {
                                        var _then = void 0;

                                        var error = void 0;
                                        var didError = false;

                                        try {
                                            _then = entry.then;
                                        } catch (e) {
                                            didError = true;
                                            error = e;
                                        }

                                        if (
                                            _then === then &&
                                            entry._state !== PENDING
                                        ) {
                                            this._settledAt(
                                                entry._state,
                                                i,
                                                entry._result
                                            );
                                        } else if (
                                            typeof _then !== "function"
                                        ) {
                                            this._remaining--;
                                            this._result[i] = entry;
                                        } else if (c === Promise$1) {
                                            var promise = new c(noop);

                                            if (didError) {
                                                reject(promise, error);
                                            } else {
                                                handleMaybeThenable(
                                                    promise,
                                                    entry,
                                                    _then
                                                );
                                            }

                                            this._willSettleAt(promise, i);
                                        } else {
                                            this._willSettleAt(
                                                new c(function (resolve$$1) {
                                                    return resolve$$1(entry);
                                                }),
                                                i
                                            );
                                        }
                                    } else {
                                        this._willSettleAt(
                                            resolve$$1(entry),
                                            i
                                        );
                                    }
                                };

                                Enumerator.prototype._settledAt = function _settledAt(
                                    state,
                                    i,
                                    value
                                ) {
                                    var promise = this.promise;

                                    if (promise._state === PENDING) {
                                        this._remaining--;

                                        if (state === REJECTED) {
                                            reject(promise, value);
                                        } else {
                                            this._result[i] = value;
                                        }
                                    }

                                    if (this._remaining === 0) {
                                        fulfill(promise, this._result);
                                    }
                                };

                                Enumerator.prototype._willSettleAt = function _willSettleAt(
                                    promise,
                                    i
                                ) {
                                    var enumerator = this;
                                    subscribe(
                                        promise,
                                        undefined,
                                        function (value) {
                                            return enumerator._settledAt(
                                                FULFILLED,
                                                i,
                                                value
                                            );
                                        },
                                        function (reason) {
                                            return enumerator._settledAt(
                                                REJECTED,
                                                i,
                                                reason
                                            );
                                        }
                                    );
                                };

                                return Enumerator;
                            })();
                            /**
    `Promise.all` accepts an array of promises, and returns a new promise which
    is fulfilled with an array of fulfillment values for the passed promises, or
    rejected with the reason of the first passed promise to be rejected. It casts all
    elements of the passed iterable to promises as it runs this algorithm.
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = resolve(2);
    let promise3 = resolve(3);
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // The array here would be [ 1, 2, 3 ];
    });
    ```
  
    If any of the `promises` given to `all` are rejected, the first promise
    that is rejected will be given as an argument to the returned promises's
    rejection handler. For example:
  
    Example:
  
    ```javascript
    let promise1 = resolve(1);
    let promise2 = reject(new Error("2"));
    let promise3 = reject(new Error("3"));
    let promises = [ promise1, promise2, promise3 ];
  
    Promise.all(promises).then(function(array){
      // Code here never runs because there are rejected promises!
    }, function(error) {
      // error.message === "2"
    });
    ```
  
    @method all
    @static
    @param {Array} entries array of promises
    @param {String} label optional string for labeling the promise.
    Useful for tooling.
    @return {Promise} promise that is fulfilled when all `promises` have been
    fulfilled, or rejected if any of them become rejected.
    @static
  */

                            function all(entries) {
                                return new Enumerator(this, entries).promise;
                            }
                            /**
    `Promise.race` returns a new promise which is settled in the same way as the
    first passed promise to settle.
  
    Example:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 2');
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // result === 'promise 2' because it was resolved before promise1
      // was resolved.
    });
    ```
  
    `Promise.race` is deterministic in that only the state of the first
    settled promise matters. For example, even if other promises given to the
    `promises` array argument are resolved, but the first settled promise has
    become rejected before the other promises became fulfilled, the returned
    promise will become rejected:
  
    ```javascript
    let promise1 = new Promise(function(resolve, reject){
      setTimeout(function(){
        resolve('promise 1');
      }, 200);
    });
  
    let promise2 = new Promise(function(resolve, reject){
      setTimeout(function(){
        reject(new Error('promise 2'));
      }, 100);
    });
  
    Promise.race([promise1, promise2]).then(function(result){
      // Code here never runs
    }, function(reason){
      // reason.message === 'promise 2' because promise 2 became rejected before
      // promise 1 became fulfilled
    });
    ```
  
    An example real-world use case is implementing timeouts:
  
    ```javascript
    Promise.race([ajax('foo.json'), timeout(5000)])
    ```
  
    @method race
    @static
    @param {Array} promises array of promises to observe
    Useful for tooling.
    @return {Promise} a promise which settles in the same way as the first passed
    promise to settle.
  */

                            function race(entries) {
                                /*jshint validthis:true */
                                var Constructor = this;

                                if (!isArray(entries)) {
                                    return new Constructor(function (
                                        _,
                                        reject
                                    ) {
                                        return reject(
                                            new TypeError(
                                                "You must pass an array to race."
                                            )
                                        );
                                    });
                                } else {
                                    return new Constructor(function (
                                        resolve,
                                        reject
                                    ) {
                                        var length = entries.length;

                                        for (var i = 0; i < length; i++) {
                                            Constructor.resolve(
                                                entries[i]
                                            ).then(resolve, reject);
                                        }
                                    });
                                }
                            }
                            /**
    `Promise.reject` returns a promise rejected with the passed `reason`.
    It is shorthand for the following:
  
    ```javascript
    let promise = new Promise(function(resolve, reject){
      reject(new Error('WHOOPS'));
    });
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    Instead of writing the above, your code now simply becomes the following:
  
    ```javascript
    let promise = Promise.reject(new Error('WHOOPS'));
  
    promise.then(function(value){
      // Code here doesn't run because the promise is rejected!
    }, function(reason){
      // reason.message === 'WHOOPS'
    });
    ```
  
    @method reject
    @static
    @param {Any} reason value that the returned promise will be rejected with.
    Useful for tooling.
    @return {Promise} a promise rejected with the given `reason`.
  */

                            function reject$1(reason) {
                                /*jshint validthis:true */
                                var Constructor = this;
                                var promise = new Constructor(noop);
                                reject(promise, reason);
                                return promise;
                            }

                            function needsResolver() {
                                throw new TypeError(
                                    "You must pass a resolver function as the first argument to the promise constructor"
                                );
                            }

                            function needsNew() {
                                throw new TypeError(
                                    "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
                                );
                            }
                            /**
    Promise objects represent the eventual result of an asynchronous operation. The
    primary way of interacting with a promise is through its `then` method, which
    registers callbacks to receive either a promise's eventual value or the reason
    why the promise cannot be fulfilled.
  
    Terminology
    -----------
  
    - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
    - `thenable` is an object or function that defines a `then` method.
    - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
    - `exception` is a value that is thrown using the throw statement.
    - `reason` is a value that indicates why a promise was rejected.
    - `settled` the final resting state of a promise, fulfilled or rejected.
  
    A promise can be in one of three states: pending, fulfilled, or rejected.
  
    Promises that are fulfilled have a fulfillment value and are in the fulfilled
    state.  Promises that are rejected have a rejection reason and are in the
    rejected state.  A fulfillment value is never a thenable.
  
    Promises can also be said to *resolve* a value.  If this value is also a
    promise, then the original promise's settled state will match the value's
    settled state.  So a promise that *resolves* a promise that rejects will
    itself reject, and a promise that *resolves* a promise that fulfills will
    itself fulfill.
  
  
    Basic Usage:
    ------------
  
    ```js
    let promise = new Promise(function(resolve, reject) {
      // on success
      resolve(value);
  
      // on failure
      reject(reason);
    });
  
    promise.then(function(value) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Advanced Usage:
    ---------------
  
    Promises shine when abstracting away asynchronous interactions such as
    `XMLHttpRequest`s.
  
    ```js
    function getJSON(url) {
      return new Promise(function(resolve, reject){
        let xhr = new XMLHttpRequest();
  
        xhr.open('GET', url);
        xhr.onreadystatechange = handler;
        xhr.responseType = 'json';
        xhr.setRequestHeader('Accept', 'application/json');
        xhr.send();
  
        function handler() {
          if (this.readyState === this.DONE) {
            if (this.status === 200) {
              resolve(this.response);
            } else {
              reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
            }
          }
        };
      });
    }
  
    getJSON('/posts.json').then(function(json) {
      // on fulfillment
    }, function(reason) {
      // on rejection
    });
    ```
  
    Unlike callbacks, promises are great composable primitives.
  
    ```js
    Promise.all([
      getJSON('/posts'),
      getJSON('/comments')
    ]).then(function(values){
      values[0] // => postsJSON
      values[1] // => commentsJSON
  
      return values;
    });
    ```
  
    @class Promise
    @param {Function} resolver
    Useful for tooling.
    @constructor
  */

                            var Promise$1 = (function () {
                                function Promise(resolver) {
                                    this[PROMISE_ID] = nextId();
                                    this._result = this._state = undefined;
                                    this._subscribers = [];

                                    if (noop !== resolver) {
                                        typeof resolver !== "function" &&
                                            needsResolver();
                                        this instanceof Promise
                                            ? initializePromise(this, resolver)
                                            : needsNew();
                                    }
                                }
                                /**
    The primary way of interacting with a promise is through its `then` method,
    which registers callbacks to receive either a promise's eventual value or the
    reason why the promise cannot be fulfilled.
     ```js
    findUser().then(function(user){
      // user is available
    }, function(reason){
      // user is unavailable, and you are given the reason why
    });
    ```
     Chaining
    --------
     The return value of `then` is itself a promise.  This second, 'downstream'
    promise is resolved with the return value of the first promise's fulfillment
    or rejection handler, or rejected if the handler throws an exception.
     ```js
    findUser().then(function (user) {
      return user.name;
    }, function (reason) {
      return 'default name';
    }).then(function (userName) {
      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
      // will be `'default name'`
    });
     findUser().then(function (user) {
      throw new Error('Found user, but still unhappy');
    }, function (reason) {
      throw new Error('`findUser` rejected and we're unhappy');
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
    });
    ```
    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
     ```js
    findUser().then(function (user) {
      throw new PedagogicalException('Upstream error');
    }).then(function (value) {
      // never reached
    }).then(function (value) {
      // never reached
    }, function (reason) {
      // The `PedgagocialException` is propagated all the way down to here
    });
    ```
     Assimilation
    ------------
     Sometimes the value you want to propagate to a downstream promise can only be
    retrieved asynchronously. This can be achieved by returning a promise in the
    fulfillment or rejection handler. The downstream promise will then be pending
    until the returned promise is settled. This is called *assimilation*.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // The user's comments are now available
    });
    ```
     If the assimliated promise rejects, then the downstream promise will also reject.
     ```js
    findUser().then(function (user) {
      return findCommentsByAuthor(user);
    }).then(function (comments) {
      // If `findCommentsByAuthor` fulfills, we'll have the value here
    }, function (reason) {
      // If `findCommentsByAuthor` rejects, we'll have the reason here
    });
    ```
     Simple Example
    --------------
     Synchronous Example
     ```javascript
    let result;
     try {
      result = findResult();
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
    findResult(function(result, err){
      if (err) {
        // failure
      } else {
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findResult().then(function(result){
      // success
    }, function(reason){
      // failure
    });
    ```
     Advanced Example
    --------------
     Synchronous Example
     ```javascript
    let author, books;
     try {
      author = findAuthor();
      books  = findBooksByAuthor(author);
      // success
    } catch(reason) {
      // failure
    }
    ```
     Errback Example
     ```js
     function foundBooks(books) {
     }
     function failure(reason) {
     }
     findAuthor(function(author, err){
      if (err) {
        failure(err);
        // failure
      } else {
        try {
          findBoooksByAuthor(author, function(books, err) {
            if (err) {
              failure(err);
            } else {
              try {
                foundBooks(books);
              } catch(reason) {
                failure(reason);
              }
            }
          });
        } catch(error) {
          failure(err);
        }
        // success
      }
    });
    ```
     Promise Example;
     ```javascript
    findAuthor().
      then(findBooksByAuthor).
      then(function(books){
        // found books
    }).catch(function(reason){
      // something went wrong
    });
    ```
     @method then
    @param {Function} onFulfilled
    @param {Function} onRejected
    Useful for tooling.
    @return {Promise}
    */

                                /**
    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
    as the catch block of a try/catch statement.
    ```js
    function findAuthor(){
    throw new Error('couldn't find that author');
    }
    // synchronous
    try {
    findAuthor();
    } catch(reason) {
    // something went wrong
    }
    // async with promises
    findAuthor().catch(function(reason){
    // something went wrong
    });
    ```
    @method catch
    @param {Function} onRejection
    Useful for tooling.
    @return {Promise}
    */

                                Promise.prototype.catch = function _catch(
                                    onRejection
                                ) {
                                    return this.then(null, onRejection);
                                };
                                /**
      `finally` will be invoked regardless of the promise's fate just as native
      try/catch/finally behaves
    
      Synchronous example:
    
      ```js
      findAuthor() {
        if (Math.random() > 0.5) {
          throw new Error();
        }
        return new Author();
      }
    
      try {
        return findAuthor(); // succeed or fail
      } catch(error) {
        return findOtherAuther();
      } finally {
        // always runs
        // doesn't affect the return value
      }
      ```
    
      Asynchronous example:
    
      ```js
      findAuthor().catch(function(reason){
        return findOtherAuther();
      }).finally(function(){
        // author was either found, or not
      });
      ```
    
      @method finally
      @param {Function} callback
      @return {Promise}
    */

                                Promise.prototype.finally = function _finally(
                                    callback
                                ) {
                                    var promise = this;
                                    var constructor = promise.constructor;

                                    if (isFunction(callback)) {
                                        return promise.then(
                                            function (value) {
                                                return constructor
                                                    .resolve(callback())
                                                    .then(function () {
                                                        return value;
                                                    });
                                            },
                                            function (reason) {
                                                return constructor
                                                    .resolve(callback())
                                                    .then(function () {
                                                        throw reason;
                                                    });
                                            }
                                        );
                                    }

                                    return promise.then(callback, callback);
                                };

                                return Promise;
                            })();

                            Promise$1.prototype.then = then;
                            Promise$1.all = all;
                            Promise$1.race = race;
                            Promise$1.resolve = resolve$1;
                            Promise$1.reject = reject$1;
                            Promise$1._setScheduler = setScheduler;
                            Promise$1._setAsap = setAsap;
                            Promise$1._asap = asap;
                            /*global self*/

                            function polyfill() {
                                var local = void 0;

                                if (typeof global !== "undefined") {
                                    local = global;
                                } else if (typeof self !== "undefined") {
                                    local = self;
                                } else {
                                    try {
                                        local = Function("return this")();
                                    } catch (e) {
                                        throw new Error(
                                            "polyfill failed because global object is unavailable in this environment"
                                        );
                                    }
                                }

                                var P = local.Promise;

                                if (P) {
                                    var promiseToString = null;

                                    try {
                                        promiseToString = Object.prototype.toString.call(
                                            P.resolve()
                                        );
                                    } catch (e) {
                                        // silently ignored
                                    }

                                    if (
                                        promiseToString ===
                                            "[object Promise]" &&
                                        !P.cast
                                    ) {
                                        return;
                                    }
                                }

                                local.Promise = Promise$1;
                            } // Strange compat..

                            Promise$1.polyfill = polyfill;
                            Promise$1.Promise = Promise$1;
                            return Promise$1;
                        });
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../../process/browser.js */ "./node_modules/process/browser.js"
                        ),
                        __webpack_require__(
                            /*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        )
                    ));

                    /***/
                },

            /***/ "./node_modules/fast-bind/bind-loop.js":
                /*!*********************************************!*\
  !*** ./node_modules/fast-bind/bind-loop.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    module.exports = function (boundThis) {
                        var f = this,
                            ret;
                        if (arguments.length < 2)
                            ret = function () {
                                if (this instanceof ret) {
                                    var ret_ = f.apply(this, arguments);
                                    return Object(ret_) === ret_ ? ret_ : this;
                                } else return f.apply(boundThis, arguments);
                            };
                        else {
                            var boundArgs = new Array(arguments.length - 1);

                            for (var i = 1; i < arguments.length; i++)
                                boundArgs[i - 1] = arguments[i];

                            ret = function () {
                                var boundLen = boundArgs.length,
                                    args = new Array(
                                        boundLen + arguments.length
                                    ),
                                    i;

                                for (i = 0; i < boundLen; i++)
                                    args[i] = boundArgs[i];

                                for (i = 0; i < arguments.length; i++)
                                    args[boundLen + i] = arguments[i];

                                if (this instanceof ret) {
                                    var ret_ = f.apply(this, args);
                                    return Object(ret_) === ret_ ? ret_ : this;
                                } else return f.apply(boundThis, args);
                            };
                        }
                        ret.prototype = f.prototype;
                        return ret;
                    };

                    /***/
                },

            /***/ "./node_modules/lodash.clone/index.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash.clone/index.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global, module) {
                        /**
                         * lodash (Custom Build) <https://lodash.com/>
                         * Build: `lodash modularize exports="npm" -o ./`
                         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
                         * Released under MIT license <https://lodash.com/license>
                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                         */

                        /** Used as the size to enable large array optimizations. */
                        var LARGE_ARRAY_SIZE = 200;
                        /** Used to stand-in for `undefined` hash values. */

                        var HASH_UNDEFINED = "__lodash_hash_undefined__";
                        /** Used as references for various `Number` constants. */

                        var MAX_SAFE_INTEGER = 9007199254740991;
                        /** `Object#toString` result references. */

                        var argsTag = "[object Arguments]",
                            arrayTag = "[object Array]",
                            boolTag = "[object Boolean]",
                            dateTag = "[object Date]",
                            errorTag = "[object Error]",
                            funcTag = "[object Function]",
                            genTag = "[object GeneratorFunction]",
                            mapTag = "[object Map]",
                            numberTag = "[object Number]",
                            objectTag = "[object Object]",
                            promiseTag = "[object Promise]",
                            regexpTag = "[object RegExp]",
                            setTag = "[object Set]",
                            stringTag = "[object String]",
                            symbolTag = "[object Symbol]",
                            weakMapTag = "[object WeakMap]";
                        var arrayBufferTag = "[object ArrayBuffer]",
                            dataViewTag = "[object DataView]",
                            float32Tag = "[object Float32Array]",
                            float64Tag = "[object Float64Array]",
                            int8Tag = "[object Int8Array]",
                            int16Tag = "[object Int16Array]",
                            int32Tag = "[object Int32Array]",
                            uint8Tag = "[object Uint8Array]",
                            uint8ClampedTag = "[object Uint8ClampedArray]",
                            uint16Tag = "[object Uint16Array]",
                            uint32Tag = "[object Uint32Array]";
                        /**
                         * Used to match `RegExp`
                         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                         */

                        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                        /** Used to match `RegExp` flags from their coerced string values. */

                        var reFlags = /\w*$/;
                        /** Used to detect host constructors (Safari). */

                        var reIsHostCtor = /^\[object .+?Constructor\]$/;
                        /** Used to detect unsigned integer values. */

                        var reIsUint = /^(?:0|[1-9]\d*)$/;
                        /** Used to identify `toStringTag` values supported by `_.clone`. */

                        var cloneableTags = {};
                        cloneableTags[argsTag] = cloneableTags[
                            arrayTag
                        ] = cloneableTags[arrayBufferTag] = cloneableTags[
                            dataViewTag
                        ] = cloneableTags[boolTag] = cloneableTags[
                            dateTag
                        ] = cloneableTags[float32Tag] = cloneableTags[
                            float64Tag
                        ] = cloneableTags[int8Tag] = cloneableTags[
                            int16Tag
                        ] = cloneableTags[int32Tag] = cloneableTags[
                            mapTag
                        ] = cloneableTags[numberTag] = cloneableTags[
                            objectTag
                        ] = cloneableTags[regexpTag] = cloneableTags[
                            setTag
                        ] = cloneableTags[stringTag] = cloneableTags[
                            symbolTag
                        ] = cloneableTags[uint8Tag] = cloneableTags[
                            uint8ClampedTag
                        ] = cloneableTags[uint16Tag] = cloneableTags[
                            uint32Tag
                        ] = true;
                        cloneableTags[errorTag] = cloneableTags[
                            funcTag
                        ] = cloneableTags[weakMapTag] = false;
                        /** Detect free variable `global` from Node.js. */

                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        /** Detect free variable `self`. */

                        var freeSelf =
                            typeof self == "object" &&
                            self &&
                            self.Object === Object &&
                            self;
                        /** Used as a reference to the global object. */

                        var root =
                            freeGlobal || freeSelf || Function("return this")();
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /**
                         * Adds the key-value `pair` to `map`.
                         *
                         * @private
                         * @param {Object} map The map to modify.
                         * @param {Array} pair The key-value pair to add.
                         * @returns {Object} Returns `map`.
                         */

                        function addMapEntry(map, pair) {
                            // Don't return `map.set` because it's not chainable in IE 11.
                            map.set(pair[0], pair[1]);
                            return map;
                        }
                        /**
                         * Adds `value` to `set`.
                         *
                         * @private
                         * @param {Object} set The set to modify.
                         * @param {*} value The value to add.
                         * @returns {Object} Returns `set`.
                         */

                        function addSetEntry(set, value) {
                            // Don't return `set.add` because it's not chainable in IE 11.
                            set.add(value);
                            return set;
                        }
                        /**
                         * A specialized version of `_.forEach` for arrays without support for
                         * iteratee shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns `array`.
                         */

                        function arrayEach(array, iteratee) {
                            var index = -1,
                                length = array ? array.length : 0;

                            while (++index < length) {
                                if (
                                    iteratee(array[index], index, array) ===
                                    false
                                ) {
                                    break;
                                }
                            }

                            return array;
                        }
                        /**
                         * Appends the elements of `values` to `array`.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to append.
                         * @returns {Array} Returns `array`.
                         */

                        function arrayPush(array, values) {
                            var index = -1,
                                length = values.length,
                                offset = array.length;

                            while (++index < length) {
                                array[offset + index] = values[index];
                            }

                            return array;
                        }
                        /**
                         * A specialized version of `_.reduce` for arrays without support for
                         * iteratee shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @param {boolean} [initAccum] Specify using the first element of `array` as
                         *  the initial value.
                         * @returns {*} Returns the accumulated value.
                         */

                        function arrayReduce(
                            array,
                            iteratee,
                            accumulator,
                            initAccum
                        ) {
                            var index = -1,
                                length = array ? array.length : 0;

                            if (initAccum && length) {
                                accumulator = array[++index];
                            }

                            while (++index < length) {
                                accumulator = iteratee(
                                    accumulator,
                                    array[index],
                                    index,
                                    array
                                );
                            }

                            return accumulator;
                        }
                        /**
                         * The base implementation of `_.times` without support for iteratee shorthands
                         * or max array length checks.
                         *
                         * @private
                         * @param {number} n The number of times to invoke `iteratee`.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns the array of results.
                         */

                        function baseTimes(n, iteratee) {
                            var index = -1,
                                result = Array(n);

                            while (++index < n) {
                                result[index] = iteratee(index);
                            }

                            return result;
                        }
                        /**
                         * Gets the value at `key` of `object`.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */

                        function getValue(object, key) {
                            return object == null ? undefined : object[key];
                        }
                        /**
                         * Checks if `value` is a host object in IE < 9.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                         */

                        function isHostObject(value) {
                            // Many host objects are `Object` objects that can coerce to strings
                            // despite having improperly defined `toString` methods.
                            var result = false;

                            if (
                                value != null &&
                                typeof value.toString != "function"
                            ) {
                                try {
                                    result = !!(value + "");
                                } catch (e) {}
                            }

                            return result;
                        }
                        /**
                         * Converts `map` to its key-value pairs.
                         *
                         * @private
                         * @param {Object} map The map to convert.
                         * @returns {Array} Returns the key-value pairs.
                         */

                        function mapToArray(map) {
                            var index = -1,
                                result = Array(map.size);
                            map.forEach(function (value, key) {
                                result[++index] = [key, value];
                            });
                            return result;
                        }
                        /**
                         * Creates a unary function that invokes `func` with its argument transformed.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {Function} transform The argument transform.
                         * @returns {Function} Returns the new function.
                         */

                        function overArg(func, transform) {
                            return function (arg) {
                                return func(transform(arg));
                            };
                        }
                        /**
                         * Converts `set` to an array of its values.
                         *
                         * @private
                         * @param {Object} set The set to convert.
                         * @returns {Array} Returns the values.
                         */

                        function setToArray(set) {
                            var index = -1,
                                result = Array(set.size);
                            set.forEach(function (value) {
                                result[++index] = value;
                            });
                            return result;
                        }
                        /** Used for built-in method references. */

                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */

                        var coreJsData = root["__core-js_shared__"];
                        /** Used to detect methods masquerading as native. */

                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(
                                (coreJsData &&
                                    coreJsData.keys &&
                                    coreJsData.keys.IE_PROTO) ||
                                    ""
                            );
                            return uid ? "Symbol(src)_1." + uid : "";
                        })();
                        /** Used to resolve the decompiled source of functions. */

                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */

                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */

                        var objectToString = objectProto.toString;
                        /** Used to detect if a method is native. */

                        var reIsNative = RegExp(
                            "^" +
                                funcToString
                                    .call(hasOwnProperty)
                                    .replace(reRegExpChar, "\\$&")
                                    .replace(
                                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                        "$1.*?"
                                    ) +
                                "$"
                        );
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined,
                            Symbol = root.Symbol,
                            Uint8Array = root.Uint8Array,
                            getPrototype = overArg(
                                Object.getPrototypeOf,
                                Object
                            ),
                            objectCreate = Object.create,
                            propertyIsEnumerable =
                                objectProto.propertyIsEnumerable,
                            splice = arrayProto.splice;
                        /* Built-in method references for those with the same name as other `lodash` methods. */

                        var nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer
                                ? Buffer.isBuffer
                                : undefined,
                            nativeKeys = overArg(Object.keys, Object);
                        /* Built-in method references that are verified to be native. */

                        var DataView = getNative(root, "DataView"),
                            Map = getNative(root, "Map"),
                            Promise = getNative(root, "Promise"),
                            Set = getNative(root, "Set"),
                            WeakMap = getNative(root, "WeakMap"),
                            nativeCreate = getNative(Object, "create");
                        /** Used to detect maps, sets, and weakmaps. */

                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);
                        /** Used to convert symbols to primitives and strings. */

                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto
                                ? symbolProto.valueOf
                                : undefined;
                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Hash(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */

                        function hashClear() {
                            this.__data__ = nativeCreate
                                ? nativeCreate(null)
                                : {};
                        }
                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function hashDelete(key) {
                            return this.has(key) && delete this.__data__[key];
                        }
                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function hashGet(key) {
                            var data = this.__data__;

                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED
                                    ? undefined
                                    : result;
                            }

                            return hasOwnProperty.call(data, key)
                                ? data[key]
                                : undefined;
                        }
                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate
                                ? data[key] !== undefined
                                : hasOwnProperty.call(data, key);
                        }
                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */

                        function hashSet(key, value) {
                            var data = this.__data__;
                            data[key] =
                                nativeCreate && value === undefined
                                    ? HASH_UNDEFINED
                                    : value;
                            return this;
                        } // Add methods to `Hash`.

                        Hash.prototype.clear = hashClear;
                        Hash.prototype["delete"] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;
                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function ListCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */

                        function listCacheClear() {
                            this.__data__ = [];
                        }
                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }

                            var lastIndex = data.length - 1;

                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }

                            return true;
                        }
                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1];
                        }
                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }
                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */

                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }

                            return this;
                        } // Add methods to `ListCache`.

                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype["delete"] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;
                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function MapCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */

                        function mapCacheClear() {
                            this.__data__ = {
                                hash: new Hash(),
                                map: new (Map || ListCache)(),
                                string: new Hash(),
                            };
                        }
                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function mapCacheDelete(key) {
                            return getMapData(this, key)["delete"](key);
                        }
                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }
                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }
                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */

                        function mapCacheSet(key, value) {
                            getMapData(this, key).set(key, value);
                            return this;
                        } // Add methods to `MapCache`.

                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype["delete"] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;
                        /**
                         * Creates a stack cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Stack(entries) {
                            this.__data__ = new ListCache(entries);
                        }
                        /**
                         * Removes all key-value entries from the stack.
                         *
                         * @private
                         * @name clear
                         * @memberOf Stack
                         */

                        function stackClear() {
                            this.__data__ = new ListCache();
                        }
                        /**
                         * Removes `key` and its value from the stack.
                         *
                         * @private
                         * @name delete
                         * @memberOf Stack
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function stackDelete(key) {
                            return this.__data__["delete"](key);
                        }
                        /**
                         * Gets the stack value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Stack
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function stackGet(key) {
                            return this.__data__.get(key);
                        }
                        /**
                         * Checks if a stack value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Stack
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function stackHas(key) {
                            return this.__data__.has(key);
                        }
                        /**
                         * Sets the stack `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Stack
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the stack cache instance.
                         */

                        function stackSet(key, value) {
                            var cache = this.__data__;

                            if (cache instanceof ListCache) {
                                var pairs = cache.__data__;

                                if (
                                    !Map ||
                                    pairs.length < LARGE_ARRAY_SIZE - 1
                                ) {
                                    pairs.push([key, value]);
                                    return this;
                                }

                                cache = this.__data__ = new MapCache(pairs);
                            }

                            cache.set(key, value);
                            return this;
                        } // Add methods to `Stack`.

                        Stack.prototype.clear = stackClear;
                        Stack.prototype["delete"] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;
                        /**
                         * Creates an array of the enumerable property names of the array-like `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @param {boolean} inherited Specify returning inherited property names.
                         * @returns {Array} Returns the array of property names.
                         */

                        function arrayLikeKeys(value, inherited) {
                            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                            // Safari 9 makes `arguments.length` enumerable in strict mode.
                            var result =
                                isArray(value) || isArguments(value)
                                    ? baseTimes(value.length, String)
                                    : [];
                            var length = result.length,
                                skipIndexes = !!length;

                            for (var key in value) {
                                if (
                                    (inherited ||
                                        hasOwnProperty.call(value, key)) &&
                                    !(
                                        skipIndexes &&
                                        (key == "length" ||
                                            isIndex(key, length))
                                    )
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * Assigns `value` to `key` of `object` if the existing value is not equivalent
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */

                        function assignValue(object, key, value) {
                            var objValue = object[key];

                            if (
                                !(
                                    hasOwnProperty.call(object, key) &&
                                    eq(objValue, value)
                                ) ||
                                (value === undefined && !(key in object))
                            ) {
                                object[key] = value;
                            }
                        }
                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function assocIndexOf(array, key) {
                            var length = array.length;

                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `_.assign` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */

                        function baseAssign(object, source) {
                            return (
                                object &&
                                copyObject(source, keys(source), object)
                            );
                        }
                        /**
                         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                         * traversed objects.
                         *
                         * @private
                         * @param {*} value The value to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @param {boolean} [isFull] Specify a clone including symbols.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @param {string} [key] The key of `value`.
                         * @param {Object} [object] The parent object of `value`.
                         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                         * @returns {*} Returns the cloned value.
                         */

                        function baseClone(
                            value,
                            isDeep,
                            isFull,
                            customizer,
                            key,
                            object,
                            stack
                        ) {
                            var result;

                            if (customizer) {
                                result = object
                                    ? customizer(value, key, object, stack)
                                    : customizer(value);
                            }

                            if (result !== undefined) {
                                return result;
                            }

                            if (!isObject(value)) {
                                return value;
                            }

                            var isArr = isArray(value);

                            if (isArr) {
                                result = initCloneArray(value);

                                if (!isDeep) {
                                    return copyArray(value, result);
                                }
                            } else {
                                var tag = getTag(value),
                                    isFunc = tag == funcTag || tag == genTag;

                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep);
                                }

                                if (
                                    tag == objectTag ||
                                    tag == argsTag ||
                                    (isFunc && !object)
                                ) {
                                    if (isHostObject(value)) {
                                        return object ? value : {};
                                    }

                                    result = initCloneObject(
                                        isFunc ? {} : value
                                    );

                                    if (!isDeep) {
                                        return copySymbols(
                                            value,
                                            baseAssign(result, value)
                                        );
                                    }
                                } else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {};
                                    }

                                    result = initCloneByTag(
                                        value,
                                        tag,
                                        baseClone,
                                        isDeep
                                    );
                                }
                            } // Check for circular references and return its corresponding clone.

                            stack || (stack = new Stack());
                            var stacked = stack.get(value);

                            if (stacked) {
                                return stacked;
                            }

                            stack.set(value, result);

                            if (!isArr) {
                                var props = isFull
                                    ? getAllKeys(value)
                                    : keys(value);
                            }

                            arrayEach(props || value, function (subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key];
                                } // Recursively populate clone (susceptible to call stack limits).

                                assignValue(
                                    result,
                                    key,
                                    baseClone(
                                        subValue,
                                        isDeep,
                                        isFull,
                                        customizer,
                                        key,
                                        value,
                                        stack
                                    )
                                );
                            });
                            return result;
                        }
                        /**
                         * The base implementation of `_.create` without support for assigning
                         * properties to the created object.
                         *
                         * @private
                         * @param {Object} prototype The object to inherit from.
                         * @returns {Object} Returns the new object.
                         */

                        function baseCreate(proto) {
                            return isObject(proto) ? objectCreate(proto) : {};
                        }
                        /**
                         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @param {Function} symbolsFunc The function to get the symbols of `object`.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object)
                                ? result
                                : arrayPush(result, symbolsFunc(object));
                        }
                        /**
                         * The base implementation of `getTag`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        function baseGetTag(value) {
                            return objectToString.call(value);
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }

                            var pattern =
                                isFunction(value) || isHostObject(value)
                                    ? reIsNative
                                    : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */

                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }

                            var result = [];

                            for (var key in Object(object)) {
                                if (
                                    hasOwnProperty.call(object, key) &&
                                    key != "constructor"
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * Creates a clone of  `buffer`.
                         *
                         * @private
                         * @param {Buffer} buffer The buffer to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Buffer} Returns the cloned buffer.
                         */

                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }

                            var result = new buffer.constructor(buffer.length);
                            buffer.copy(result);
                            return result;
                        }
                        /**
                         * Creates a clone of `arrayBuffer`.
                         *
                         * @private
                         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                         * @returns {ArrayBuffer} Returns the cloned array buffer.
                         */

                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(
                                arrayBuffer.byteLength
                            );
                            new Uint8Array(result).set(
                                new Uint8Array(arrayBuffer)
                            );
                            return result;
                        }
                        /**
                         * Creates a clone of `dataView`.
                         *
                         * @private
                         * @param {Object} dataView The data view to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned data view.
                         */

                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep
                                ? cloneArrayBuffer(dataView.buffer)
                                : dataView.buffer;
                            return new dataView.constructor(
                                buffer,
                                dataView.byteOffset,
                                dataView.byteLength
                            );
                        }
                        /**
                         * Creates a clone of `map`.
                         *
                         * @private
                         * @param {Object} map The map to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned map.
                         */

                        function cloneMap(map, isDeep, cloneFunc) {
                            var array = isDeep
                                ? cloneFunc(mapToArray(map), true)
                                : mapToArray(map);
                            return arrayReduce(
                                array,
                                addMapEntry,
                                new map.constructor()
                            );
                        }
                        /**
                         * Creates a clone of `regexp`.
                         *
                         * @private
                         * @param {Object} regexp The regexp to clone.
                         * @returns {Object} Returns the cloned regexp.
                         */

                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(
                                regexp.source,
                                reFlags.exec(regexp)
                            );
                            result.lastIndex = regexp.lastIndex;
                            return result;
                        }
                        /**
                         * Creates a clone of `set`.
                         *
                         * @private
                         * @param {Object} set The set to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned set.
                         */

                        function cloneSet(set, isDeep, cloneFunc) {
                            var array = isDeep
                                ? cloneFunc(setToArray(set), true)
                                : setToArray(set);
                            return arrayReduce(
                                array,
                                addSetEntry,
                                new set.constructor()
                            );
                        }
                        /**
                         * Creates a clone of the `symbol` object.
                         *
                         * @private
                         * @param {Object} symbol The symbol object to clone.
                         * @returns {Object} Returns the cloned symbol object.
                         */

                        function cloneSymbol(symbol) {
                            return symbolValueOf
                                ? Object(symbolValueOf.call(symbol))
                                : {};
                        }
                        /**
                         * Creates a clone of `typedArray`.
                         *
                         * @private
                         * @param {Object} typedArray The typed array to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned typed array.
                         */

                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep
                                ? cloneArrayBuffer(typedArray.buffer)
                                : typedArray.buffer;
                            return new typedArray.constructor(
                                buffer,
                                typedArray.byteOffset,
                                typedArray.length
                            );
                        }
                        /**
                         * Copies the values of `source` to `array`.
                         *
                         * @private
                         * @param {Array} source The array to copy values from.
                         * @param {Array} [array=[]] The array to copy values to.
                         * @returns {Array} Returns `array`.
                         */

                        function copyArray(source, array) {
                            var index = -1,
                                length = source.length;
                            array || (array = Array(length));

                            while (++index < length) {
                                array[index] = source[index];
                            }

                            return array;
                        }
                        /**
                         * Copies properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy properties from.
                         * @param {Array} props The property identifiers to copy.
                         * @param {Object} [object={}] The object to copy properties to.
                         * @param {Function} [customizer] The function to customize copied values.
                         * @returns {Object} Returns `object`.
                         */

                        function copyObject(source, props, object, customizer) {
                            object || (object = {});
                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];
                                var newValue = customizer
                                    ? customizer(
                                          object[key],
                                          source[key],
                                          key,
                                          object,
                                          source
                                      )
                                    : undefined;
                                assignValue(
                                    object,
                                    key,
                                    newValue === undefined
                                        ? source[key]
                                        : newValue
                                );
                            }

                            return object;
                        }
                        /**
                         * Copies own symbol properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */

                        function copySymbols(source, object) {
                            return copyObject(
                                source,
                                getSymbols(source),
                                object
                            );
                        }
                        /**
                         * Creates an array of own enumerable property names and symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }
                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */

                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[
                                      typeof key == "string" ? "string" : "hash"
                                  ]
                                : data.map;
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * Creates an array of the own enumerable symbol properties of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */

                        var getSymbols = nativeGetSymbols
                            ? overArg(nativeGetSymbols, Object)
                            : stubArray;
                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
                        // for data views in Edge < 14, and promises in Node.js.

                        if (
                            (DataView &&
                                getTag(new DataView(new ArrayBuffer(1))) !=
                                    dataViewTag) ||
                            (Map && getTag(new Map()) != mapTag) ||
                            (Promise &&
                                getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set()) != setTag) ||
                            (WeakMap && getTag(new WeakMap()) != weakMapTag)
                        ) {
                            getTag = function (value) {
                                var result = objectToString.call(value),
                                    Ctor =
                                        result == objectTag
                                            ? value.constructor
                                            : undefined,
                                    ctorString = Ctor
                                        ? toSource(Ctor)
                                        : undefined;

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;

                                        case mapCtorString:
                                            return mapTag;

                                        case promiseCtorString:
                                            return promiseTag;

                                        case setCtorString:
                                            return setTag;

                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }

                                return result;
                            };
                        }
                        /**
                         * Initializes an array clone.
                         *
                         * @private
                         * @param {Array} array The array to clone.
                         * @returns {Array} Returns the initialized clone.
                         */

                        function initCloneArray(array) {
                            var length = array.length,
                                result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

                            if (
                                length &&
                                typeof array[0] == "string" &&
                                hasOwnProperty.call(array, "index")
                            ) {
                                result.index = array.index;
                                result.input = array.input;
                            }

                            return result;
                        }
                        /**
                         * Initializes an object clone.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @returns {Object} Returns the initialized clone.
                         */

                        function initCloneObject(object) {
                            return typeof object.constructor == "function" &&
                                !isPrototype(object)
                                ? baseCreate(getPrototype(object))
                                : {};
                        }
                        /**
                         * Initializes an object clone based on its `toStringTag`.
                         *
                         * **Note:** This function only supports cloning values with tags of
                         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @param {string} tag The `toStringTag` of the object to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the initialized clone.
                         */

                        function initCloneByTag(
                            object,
                            tag,
                            cloneFunc,
                            isDeep
                        ) {
                            var Ctor = object.constructor;

                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);

                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);

                                case dataViewTag:
                                    return cloneDataView(object, isDeep);

                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);

                                case mapTag:
                                    return cloneMap(object, isDeep, cloneFunc);

                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);

                                case regexpTag:
                                    return cloneRegExp(object);

                                case setTag:
                                    return cloneSet(object, isDeep, cloneFunc);

                                case symbolTag:
                                    return cloneSymbol(object);
                            }
                        }
                        /**
                         * Checks if `value` is a valid array-like index.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                         */

                        function isIndex(value, length) {
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return (
                                !!length &&
                                (typeof value == "number" ||
                                    reIsUint.test(value)) &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value < length
                            );
                        }
                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */

                        function isKeyable(value) {
                            var type = typeof value;
                            return type == "string" ||
                                type == "number" ||
                                type == "symbol" ||
                                type == "boolean"
                                ? value !== "__proto__"
                                : value === null;
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func;
                        }
                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */

                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto =
                                    (typeof Ctor == "function" &&
                                        Ctor.prototype) ||
                                    objectProto;
                            return value === proto;
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to process.
                         * @returns {string} Returns the source code.
                         */

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}

                                try {
                                    return func + "";
                                } catch (e) {}
                            }

                            return "";
                        }
                        /**
                         * Creates a shallow clone of `value`.
                         *
                         * **Note:** This method is loosely based on the
                         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
                         * and supports cloning arrays, array buffers, booleans, date objects, maps,
                         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
                         * arrays. The own enumerable properties of `arguments` objects are cloned
                         * as plain objects. An empty object is returned for uncloneable values such
                         * as error objects, functions, DOM nodes, and WeakMaps.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to clone.
                         * @returns {*} Returns the cloned value.
                         * @see _.cloneDeep
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var shallow = _.clone(objects);
                         * console.log(shallow[0] === objects[0]);
                         * // => true
                         */

                        function clone(value) {
                            return baseClone(value, false, true);
                        }
                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */

                        function eq(value, other) {
                            return (
                                value === other ||
                                (value !== value && other !== other)
                            );
                        }
                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */

                        function isArguments(value) {
                            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                            return (
                                isArrayLikeObject(value) &&
                                hasOwnProperty.call(value, "callee") &&
                                (!propertyIsEnumerable.call(value, "callee") ||
                                    objectToString.call(value) == argsTag)
                            );
                        }
                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */

                        var isArray = Array.isArray;
                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */

                        function isArrayLike(value) {
                            return (
                                value != null &&
                                isLength(value.length) &&
                                !isFunction(value)
                            );
                        }
                        /**
                         * This method is like `_.isArrayLike` except that it also checks if `value`
                         * is an object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array-like object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArrayLikeObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLikeObject(document.body.children);
                         * // => true
                         *
                         * _.isArrayLikeObject('abc');
                         * // => false
                         *
                         * _.isArrayLikeObject(_.noop);
                         * // => false
                         */

                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */

                        var isBuffer = nativeIsBuffer || stubFalse;
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */

                        function isFunction(value) {
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 8-9 which returns 'object' for typed array and other constructors.
                            var tag = isObject(value)
                                ? objectToString.call(value)
                                : "";
                            return tag == funcTag || tag == genTag;
                        }
                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */

                        function isLength(value) {
                            return (
                                typeof value == "number" &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value <= MAX_SAFE_INTEGER
                            );
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */

                        function isObject(value) {
                            var type = typeof value;
                            return (
                                !!value &&
                                (type == "object" || type == "function")
                            );
                        }
                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */

                        function isObjectLike(value) {
                            return !!value && typeof value == "object";
                        }
                        /**
                         * Creates an array of the own enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects. See the
                         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * for more details.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keys(new Foo);
                         * // => ['a', 'b'] (iteration order is not guaranteed)
                         *
                         * _.keys('hi');
                         * // => ['0', '1']
                         */

                        function keys(object) {
                            return isArrayLike(object)
                                ? arrayLikeKeys(object)
                                : baseKeys(object);
                        }
                        /**
                         * This method returns a new empty array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Array} Returns the new empty array.
                         * @example
                         *
                         * var arrays = _.times(2, _.stubArray);
                         *
                         * console.log(arrays);
                         * // => [[], []]
                         *
                         * console.log(arrays[0] === arrays[1]);
                         * // => false
                         */

                        function stubArray() {
                            return [];
                        }
                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */

                        function stubFalse() {
                            return false;
                        }

                        module.exports = clone;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        ),
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash.clonedeep/index.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash.clonedeep/index.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global, module) {
                        /**
                         * lodash (Custom Build) <https://lodash.com/>
                         * Build: `lodash modularize exports="npm" -o ./`
                         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
                         * Released under MIT license <https://lodash.com/license>
                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                         */

                        /** Used as the size to enable large array optimizations. */
                        var LARGE_ARRAY_SIZE = 200;
                        /** Used to stand-in for `undefined` hash values. */

                        var HASH_UNDEFINED = "__lodash_hash_undefined__";
                        /** Used as references for various `Number` constants. */

                        var MAX_SAFE_INTEGER = 9007199254740991;
                        /** `Object#toString` result references. */

                        var argsTag = "[object Arguments]",
                            arrayTag = "[object Array]",
                            boolTag = "[object Boolean]",
                            dateTag = "[object Date]",
                            errorTag = "[object Error]",
                            funcTag = "[object Function]",
                            genTag = "[object GeneratorFunction]",
                            mapTag = "[object Map]",
                            numberTag = "[object Number]",
                            objectTag = "[object Object]",
                            promiseTag = "[object Promise]",
                            regexpTag = "[object RegExp]",
                            setTag = "[object Set]",
                            stringTag = "[object String]",
                            symbolTag = "[object Symbol]",
                            weakMapTag = "[object WeakMap]";
                        var arrayBufferTag = "[object ArrayBuffer]",
                            dataViewTag = "[object DataView]",
                            float32Tag = "[object Float32Array]",
                            float64Tag = "[object Float64Array]",
                            int8Tag = "[object Int8Array]",
                            int16Tag = "[object Int16Array]",
                            int32Tag = "[object Int32Array]",
                            uint8Tag = "[object Uint8Array]",
                            uint8ClampedTag = "[object Uint8ClampedArray]",
                            uint16Tag = "[object Uint16Array]",
                            uint32Tag = "[object Uint32Array]";
                        /**
                         * Used to match `RegExp`
                         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                         */

                        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                        /** Used to match `RegExp` flags from their coerced string values. */

                        var reFlags = /\w*$/;
                        /** Used to detect host constructors (Safari). */

                        var reIsHostCtor = /^\[object .+?Constructor\]$/;
                        /** Used to detect unsigned integer values. */

                        var reIsUint = /^(?:0|[1-9]\d*)$/;
                        /** Used to identify `toStringTag` values supported by `_.clone`. */

                        var cloneableTags = {};
                        cloneableTags[argsTag] = cloneableTags[
                            arrayTag
                        ] = cloneableTags[arrayBufferTag] = cloneableTags[
                            dataViewTag
                        ] = cloneableTags[boolTag] = cloneableTags[
                            dateTag
                        ] = cloneableTags[float32Tag] = cloneableTags[
                            float64Tag
                        ] = cloneableTags[int8Tag] = cloneableTags[
                            int16Tag
                        ] = cloneableTags[int32Tag] = cloneableTags[
                            mapTag
                        ] = cloneableTags[numberTag] = cloneableTags[
                            objectTag
                        ] = cloneableTags[regexpTag] = cloneableTags[
                            setTag
                        ] = cloneableTags[stringTag] = cloneableTags[
                            symbolTag
                        ] = cloneableTags[uint8Tag] = cloneableTags[
                            uint8ClampedTag
                        ] = cloneableTags[uint16Tag] = cloneableTags[
                            uint32Tag
                        ] = true;
                        cloneableTags[errorTag] = cloneableTags[
                            funcTag
                        ] = cloneableTags[weakMapTag] = false;
                        /** Detect free variable `global` from Node.js. */

                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        /** Detect free variable `self`. */

                        var freeSelf =
                            typeof self == "object" &&
                            self &&
                            self.Object === Object &&
                            self;
                        /** Used as a reference to the global object. */

                        var root =
                            freeGlobal || freeSelf || Function("return this")();
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /**
                         * Adds the key-value `pair` to `map`.
                         *
                         * @private
                         * @param {Object} map The map to modify.
                         * @param {Array} pair The key-value pair to add.
                         * @returns {Object} Returns `map`.
                         */

                        function addMapEntry(map, pair) {
                            // Don't return `map.set` because it's not chainable in IE 11.
                            map.set(pair[0], pair[1]);
                            return map;
                        }
                        /**
                         * Adds `value` to `set`.
                         *
                         * @private
                         * @param {Object} set The set to modify.
                         * @param {*} value The value to add.
                         * @returns {Object} Returns `set`.
                         */

                        function addSetEntry(set, value) {
                            // Don't return `set.add` because it's not chainable in IE 11.
                            set.add(value);
                            return set;
                        }
                        /**
                         * A specialized version of `_.forEach` for arrays without support for
                         * iteratee shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns `array`.
                         */

                        function arrayEach(array, iteratee) {
                            var index = -1,
                                length = array ? array.length : 0;

                            while (++index < length) {
                                if (
                                    iteratee(array[index], index, array) ===
                                    false
                                ) {
                                    break;
                                }
                            }

                            return array;
                        }
                        /**
                         * Appends the elements of `values` to `array`.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to append.
                         * @returns {Array} Returns `array`.
                         */

                        function arrayPush(array, values) {
                            var index = -1,
                                length = values.length,
                                offset = array.length;

                            while (++index < length) {
                                array[offset + index] = values[index];
                            }

                            return array;
                        }
                        /**
                         * A specialized version of `_.reduce` for arrays without support for
                         * iteratee shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @param {*} [accumulator] The initial value.
                         * @param {boolean} [initAccum] Specify using the first element of `array` as
                         *  the initial value.
                         * @returns {*} Returns the accumulated value.
                         */

                        function arrayReduce(
                            array,
                            iteratee,
                            accumulator,
                            initAccum
                        ) {
                            var index = -1,
                                length = array ? array.length : 0;

                            if (initAccum && length) {
                                accumulator = array[++index];
                            }

                            while (++index < length) {
                                accumulator = iteratee(
                                    accumulator,
                                    array[index],
                                    index,
                                    array
                                );
                            }

                            return accumulator;
                        }
                        /**
                         * The base implementation of `_.times` without support for iteratee shorthands
                         * or max array length checks.
                         *
                         * @private
                         * @param {number} n The number of times to invoke `iteratee`.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns the array of results.
                         */

                        function baseTimes(n, iteratee) {
                            var index = -1,
                                result = Array(n);

                            while (++index < n) {
                                result[index] = iteratee(index);
                            }

                            return result;
                        }
                        /**
                         * Gets the value at `key` of `object`.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */

                        function getValue(object, key) {
                            return object == null ? undefined : object[key];
                        }
                        /**
                         * Checks if `value` is a host object in IE < 9.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                         */

                        function isHostObject(value) {
                            // Many host objects are `Object` objects that can coerce to strings
                            // despite having improperly defined `toString` methods.
                            var result = false;

                            if (
                                value != null &&
                                typeof value.toString != "function"
                            ) {
                                try {
                                    result = !!(value + "");
                                } catch (e) {}
                            }

                            return result;
                        }
                        /**
                         * Converts `map` to its key-value pairs.
                         *
                         * @private
                         * @param {Object} map The map to convert.
                         * @returns {Array} Returns the key-value pairs.
                         */

                        function mapToArray(map) {
                            var index = -1,
                                result = Array(map.size);
                            map.forEach(function (value, key) {
                                result[++index] = [key, value];
                            });
                            return result;
                        }
                        /**
                         * Creates a unary function that invokes `func` with its argument transformed.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {Function} transform The argument transform.
                         * @returns {Function} Returns the new function.
                         */

                        function overArg(func, transform) {
                            return function (arg) {
                                return func(transform(arg));
                            };
                        }
                        /**
                         * Converts `set` to an array of its values.
                         *
                         * @private
                         * @param {Object} set The set to convert.
                         * @returns {Array} Returns the values.
                         */

                        function setToArray(set) {
                            var index = -1,
                                result = Array(set.size);
                            set.forEach(function (value) {
                                result[++index] = value;
                            });
                            return result;
                        }
                        /** Used for built-in method references. */

                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */

                        var coreJsData = root["__core-js_shared__"];
                        /** Used to detect methods masquerading as native. */

                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(
                                (coreJsData &&
                                    coreJsData.keys &&
                                    coreJsData.keys.IE_PROTO) ||
                                    ""
                            );
                            return uid ? "Symbol(src)_1." + uid : "";
                        })();
                        /** Used to resolve the decompiled source of functions. */

                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */

                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */

                        var objectToString = objectProto.toString;
                        /** Used to detect if a method is native. */

                        var reIsNative = RegExp(
                            "^" +
                                funcToString
                                    .call(hasOwnProperty)
                                    .replace(reRegExpChar, "\\$&")
                                    .replace(
                                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                        "$1.*?"
                                    ) +
                                "$"
                        );
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined,
                            Symbol = root.Symbol,
                            Uint8Array = root.Uint8Array,
                            getPrototype = overArg(
                                Object.getPrototypeOf,
                                Object
                            ),
                            objectCreate = Object.create,
                            propertyIsEnumerable =
                                objectProto.propertyIsEnumerable,
                            splice = arrayProto.splice;
                        /* Built-in method references for those with the same name as other `lodash` methods. */

                        var nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer
                                ? Buffer.isBuffer
                                : undefined,
                            nativeKeys = overArg(Object.keys, Object);
                        /* Built-in method references that are verified to be native. */

                        var DataView = getNative(root, "DataView"),
                            Map = getNative(root, "Map"),
                            Promise = getNative(root, "Promise"),
                            Set = getNative(root, "Set"),
                            WeakMap = getNative(root, "WeakMap"),
                            nativeCreate = getNative(Object, "create");
                        /** Used to detect maps, sets, and weakmaps. */

                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);
                        /** Used to convert symbols to primitives and strings. */

                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto
                                ? symbolProto.valueOf
                                : undefined;
                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Hash(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */

                        function hashClear() {
                            this.__data__ = nativeCreate
                                ? nativeCreate(null)
                                : {};
                        }
                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function hashDelete(key) {
                            return this.has(key) && delete this.__data__[key];
                        }
                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function hashGet(key) {
                            var data = this.__data__;

                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED
                                    ? undefined
                                    : result;
                            }

                            return hasOwnProperty.call(data, key)
                                ? data[key]
                                : undefined;
                        }
                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate
                                ? data[key] !== undefined
                                : hasOwnProperty.call(data, key);
                        }
                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */

                        function hashSet(key, value) {
                            var data = this.__data__;
                            data[key] =
                                nativeCreate && value === undefined
                                    ? HASH_UNDEFINED
                                    : value;
                            return this;
                        } // Add methods to `Hash`.

                        Hash.prototype.clear = hashClear;
                        Hash.prototype["delete"] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;
                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function ListCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */

                        function listCacheClear() {
                            this.__data__ = [];
                        }
                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }

                            var lastIndex = data.length - 1;

                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }

                            return true;
                        }
                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1];
                        }
                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }
                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */

                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }

                            return this;
                        } // Add methods to `ListCache`.

                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype["delete"] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;
                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function MapCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */

                        function mapCacheClear() {
                            this.__data__ = {
                                hash: new Hash(),
                                map: new (Map || ListCache)(),
                                string: new Hash(),
                            };
                        }
                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function mapCacheDelete(key) {
                            return getMapData(this, key)["delete"](key);
                        }
                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }
                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }
                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */

                        function mapCacheSet(key, value) {
                            getMapData(this, key).set(key, value);
                            return this;
                        } // Add methods to `MapCache`.

                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype["delete"] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;
                        /**
                         * Creates a stack cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Stack(entries) {
                            this.__data__ = new ListCache(entries);
                        }
                        /**
                         * Removes all key-value entries from the stack.
                         *
                         * @private
                         * @name clear
                         * @memberOf Stack
                         */

                        function stackClear() {
                            this.__data__ = new ListCache();
                        }
                        /**
                         * Removes `key` and its value from the stack.
                         *
                         * @private
                         * @name delete
                         * @memberOf Stack
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function stackDelete(key) {
                            return this.__data__["delete"](key);
                        }
                        /**
                         * Gets the stack value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Stack
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function stackGet(key) {
                            return this.__data__.get(key);
                        }
                        /**
                         * Checks if a stack value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Stack
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function stackHas(key) {
                            return this.__data__.has(key);
                        }
                        /**
                         * Sets the stack `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Stack
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the stack cache instance.
                         */

                        function stackSet(key, value) {
                            var cache = this.__data__;

                            if (cache instanceof ListCache) {
                                var pairs = cache.__data__;

                                if (
                                    !Map ||
                                    pairs.length < LARGE_ARRAY_SIZE - 1
                                ) {
                                    pairs.push([key, value]);
                                    return this;
                                }

                                cache = this.__data__ = new MapCache(pairs);
                            }

                            cache.set(key, value);
                            return this;
                        } // Add methods to `Stack`.

                        Stack.prototype.clear = stackClear;
                        Stack.prototype["delete"] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;
                        /**
                         * Creates an array of the enumerable property names of the array-like `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @param {boolean} inherited Specify returning inherited property names.
                         * @returns {Array} Returns the array of property names.
                         */

                        function arrayLikeKeys(value, inherited) {
                            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                            // Safari 9 makes `arguments.length` enumerable in strict mode.
                            var result =
                                isArray(value) || isArguments(value)
                                    ? baseTimes(value.length, String)
                                    : [];
                            var length = result.length,
                                skipIndexes = !!length;

                            for (var key in value) {
                                if (
                                    (inherited ||
                                        hasOwnProperty.call(value, key)) &&
                                    !(
                                        skipIndexes &&
                                        (key == "length" ||
                                            isIndex(key, length))
                                    )
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * Assigns `value` to `key` of `object` if the existing value is not equivalent
                         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons.
                         *
                         * @private
                         * @param {Object} object The object to modify.
                         * @param {string} key The key of the property to assign.
                         * @param {*} value The value to assign.
                         */

                        function assignValue(object, key, value) {
                            var objValue = object[key];

                            if (
                                !(
                                    hasOwnProperty.call(object, key) &&
                                    eq(objValue, value)
                                ) ||
                                (value === undefined && !(key in object))
                            ) {
                                object[key] = value;
                            }
                        }
                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function assocIndexOf(array, key) {
                            var length = array.length;

                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `_.assign` without support for multiple sources
                         * or `customizer` functions.
                         *
                         * @private
                         * @param {Object} object The destination object.
                         * @param {Object} source The source object.
                         * @returns {Object} Returns `object`.
                         */

                        function baseAssign(object, source) {
                            return (
                                object &&
                                copyObject(source, keys(source), object)
                            );
                        }
                        /**
                         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                         * traversed objects.
                         *
                         * @private
                         * @param {*} value The value to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @param {boolean} [isFull] Specify a clone including symbols.
                         * @param {Function} [customizer] The function to customize cloning.
                         * @param {string} [key] The key of `value`.
                         * @param {Object} [object] The parent object of `value`.
                         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                         * @returns {*} Returns the cloned value.
                         */

                        function baseClone(
                            value,
                            isDeep,
                            isFull,
                            customizer,
                            key,
                            object,
                            stack
                        ) {
                            var result;

                            if (customizer) {
                                result = object
                                    ? customizer(value, key, object, stack)
                                    : customizer(value);
                            }

                            if (result !== undefined) {
                                return result;
                            }

                            if (!isObject(value)) {
                                return value;
                            }

                            var isArr = isArray(value);

                            if (isArr) {
                                result = initCloneArray(value);

                                if (!isDeep) {
                                    return copyArray(value, result);
                                }
                            } else {
                                var tag = getTag(value),
                                    isFunc = tag == funcTag || tag == genTag;

                                if (isBuffer(value)) {
                                    return cloneBuffer(value, isDeep);
                                }

                                if (
                                    tag == objectTag ||
                                    tag == argsTag ||
                                    (isFunc && !object)
                                ) {
                                    if (isHostObject(value)) {
                                        return object ? value : {};
                                    }

                                    result = initCloneObject(
                                        isFunc ? {} : value
                                    );

                                    if (!isDeep) {
                                        return copySymbols(
                                            value,
                                            baseAssign(result, value)
                                        );
                                    }
                                } else {
                                    if (!cloneableTags[tag]) {
                                        return object ? value : {};
                                    }

                                    result = initCloneByTag(
                                        value,
                                        tag,
                                        baseClone,
                                        isDeep
                                    );
                                }
                            } // Check for circular references and return its corresponding clone.

                            stack || (stack = new Stack());
                            var stacked = stack.get(value);

                            if (stacked) {
                                return stacked;
                            }

                            stack.set(value, result);

                            if (!isArr) {
                                var props = isFull
                                    ? getAllKeys(value)
                                    : keys(value);
                            }

                            arrayEach(props || value, function (subValue, key) {
                                if (props) {
                                    key = subValue;
                                    subValue = value[key];
                                } // Recursively populate clone (susceptible to call stack limits).

                                assignValue(
                                    result,
                                    key,
                                    baseClone(
                                        subValue,
                                        isDeep,
                                        isFull,
                                        customizer,
                                        key,
                                        value,
                                        stack
                                    )
                                );
                            });
                            return result;
                        }
                        /**
                         * The base implementation of `_.create` without support for assigning
                         * properties to the created object.
                         *
                         * @private
                         * @param {Object} prototype The object to inherit from.
                         * @returns {Object} Returns the new object.
                         */

                        function baseCreate(proto) {
                            return isObject(proto) ? objectCreate(proto) : {};
                        }
                        /**
                         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @param {Function} symbolsFunc The function to get the symbols of `object`.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object)
                                ? result
                                : arrayPush(result, symbolsFunc(object));
                        }
                        /**
                         * The base implementation of `getTag`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        function baseGetTag(value) {
                            return objectToString.call(value);
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }

                            var pattern =
                                isFunction(value) || isHostObject(value)
                                    ? reIsNative
                                    : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */

                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }

                            var result = [];

                            for (var key in Object(object)) {
                                if (
                                    hasOwnProperty.call(object, key) &&
                                    key != "constructor"
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * Creates a clone of  `buffer`.
                         *
                         * @private
                         * @param {Buffer} buffer The buffer to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Buffer} Returns the cloned buffer.
                         */

                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }

                            var result = new buffer.constructor(buffer.length);
                            buffer.copy(result);
                            return result;
                        }
                        /**
                         * Creates a clone of `arrayBuffer`.
                         *
                         * @private
                         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                         * @returns {ArrayBuffer} Returns the cloned array buffer.
                         */

                        function cloneArrayBuffer(arrayBuffer) {
                            var result = new arrayBuffer.constructor(
                                arrayBuffer.byteLength
                            );
                            new Uint8Array(result).set(
                                new Uint8Array(arrayBuffer)
                            );
                            return result;
                        }
                        /**
                         * Creates a clone of `dataView`.
                         *
                         * @private
                         * @param {Object} dataView The data view to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned data view.
                         */

                        function cloneDataView(dataView, isDeep) {
                            var buffer = isDeep
                                ? cloneArrayBuffer(dataView.buffer)
                                : dataView.buffer;
                            return new dataView.constructor(
                                buffer,
                                dataView.byteOffset,
                                dataView.byteLength
                            );
                        }
                        /**
                         * Creates a clone of `map`.
                         *
                         * @private
                         * @param {Object} map The map to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned map.
                         */

                        function cloneMap(map, isDeep, cloneFunc) {
                            var array = isDeep
                                ? cloneFunc(mapToArray(map), true)
                                : mapToArray(map);
                            return arrayReduce(
                                array,
                                addMapEntry,
                                new map.constructor()
                            );
                        }
                        /**
                         * Creates a clone of `regexp`.
                         *
                         * @private
                         * @param {Object} regexp The regexp to clone.
                         * @returns {Object} Returns the cloned regexp.
                         */

                        function cloneRegExp(regexp) {
                            var result = new regexp.constructor(
                                regexp.source,
                                reFlags.exec(regexp)
                            );
                            result.lastIndex = regexp.lastIndex;
                            return result;
                        }
                        /**
                         * Creates a clone of `set`.
                         *
                         * @private
                         * @param {Object} set The set to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned set.
                         */

                        function cloneSet(set, isDeep, cloneFunc) {
                            var array = isDeep
                                ? cloneFunc(setToArray(set), true)
                                : setToArray(set);
                            return arrayReduce(
                                array,
                                addSetEntry,
                                new set.constructor()
                            );
                        }
                        /**
                         * Creates a clone of the `symbol` object.
                         *
                         * @private
                         * @param {Object} symbol The symbol object to clone.
                         * @returns {Object} Returns the cloned symbol object.
                         */

                        function cloneSymbol(symbol) {
                            return symbolValueOf
                                ? Object(symbolValueOf.call(symbol))
                                : {};
                        }
                        /**
                         * Creates a clone of `typedArray`.
                         *
                         * @private
                         * @param {Object} typedArray The typed array to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the cloned typed array.
                         */

                        function cloneTypedArray(typedArray, isDeep) {
                            var buffer = isDeep
                                ? cloneArrayBuffer(typedArray.buffer)
                                : typedArray.buffer;
                            return new typedArray.constructor(
                                buffer,
                                typedArray.byteOffset,
                                typedArray.length
                            );
                        }
                        /**
                         * Copies the values of `source` to `array`.
                         *
                         * @private
                         * @param {Array} source The array to copy values from.
                         * @param {Array} [array=[]] The array to copy values to.
                         * @returns {Array} Returns `array`.
                         */

                        function copyArray(source, array) {
                            var index = -1,
                                length = source.length;
                            array || (array = Array(length));

                            while (++index < length) {
                                array[index] = source[index];
                            }

                            return array;
                        }
                        /**
                         * Copies properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy properties from.
                         * @param {Array} props The property identifiers to copy.
                         * @param {Object} [object={}] The object to copy properties to.
                         * @param {Function} [customizer] The function to customize copied values.
                         * @returns {Object} Returns `object`.
                         */

                        function copyObject(source, props, object, customizer) {
                            object || (object = {});
                            var index = -1,
                                length = props.length;

                            while (++index < length) {
                                var key = props[index];
                                var newValue = customizer
                                    ? customizer(
                                          object[key],
                                          source[key],
                                          key,
                                          object,
                                          source
                                      )
                                    : undefined;
                                assignValue(
                                    object,
                                    key,
                                    newValue === undefined
                                        ? source[key]
                                        : newValue
                                );
                            }

                            return object;
                        }
                        /**
                         * Copies own symbol properties of `source` to `object`.
                         *
                         * @private
                         * @param {Object} source The object to copy symbols from.
                         * @param {Object} [object={}] The object to copy symbols to.
                         * @returns {Object} Returns `object`.
                         */

                        function copySymbols(source, object) {
                            return copyObject(
                                source,
                                getSymbols(source),
                                object
                            );
                        }
                        /**
                         * Creates an array of own enumerable property names and symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }
                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */

                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[
                                      typeof key == "string" ? "string" : "hash"
                                  ]
                                : data.map;
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * Creates an array of the own enumerable symbol properties of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */

                        var getSymbols = nativeGetSymbols
                            ? overArg(nativeGetSymbols, Object)
                            : stubArray;
                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
                        // for data views in Edge < 14, and promises in Node.js.

                        if (
                            (DataView &&
                                getTag(new DataView(new ArrayBuffer(1))) !=
                                    dataViewTag) ||
                            (Map && getTag(new Map()) != mapTag) ||
                            (Promise &&
                                getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set()) != setTag) ||
                            (WeakMap && getTag(new WeakMap()) != weakMapTag)
                        ) {
                            getTag = function (value) {
                                var result = objectToString.call(value),
                                    Ctor =
                                        result == objectTag
                                            ? value.constructor
                                            : undefined,
                                    ctorString = Ctor
                                        ? toSource(Ctor)
                                        : undefined;

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;

                                        case mapCtorString:
                                            return mapTag;

                                        case promiseCtorString:
                                            return promiseTag;

                                        case setCtorString:
                                            return setTag;

                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }

                                return result;
                            };
                        }
                        /**
                         * Initializes an array clone.
                         *
                         * @private
                         * @param {Array} array The array to clone.
                         * @returns {Array} Returns the initialized clone.
                         */

                        function initCloneArray(array) {
                            var length = array.length,
                                result = array.constructor(length); // Add properties assigned by `RegExp#exec`.

                            if (
                                length &&
                                typeof array[0] == "string" &&
                                hasOwnProperty.call(array, "index")
                            ) {
                                result.index = array.index;
                                result.input = array.input;
                            }

                            return result;
                        }
                        /**
                         * Initializes an object clone.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @returns {Object} Returns the initialized clone.
                         */

                        function initCloneObject(object) {
                            return typeof object.constructor == "function" &&
                                !isPrototype(object)
                                ? baseCreate(getPrototype(object))
                                : {};
                        }
                        /**
                         * Initializes an object clone based on its `toStringTag`.
                         *
                         * **Note:** This function only supports cloning values with tags of
                         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to clone.
                         * @param {string} tag The `toStringTag` of the object to clone.
                         * @param {Function} cloneFunc The function to clone values.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Object} Returns the initialized clone.
                         */

                        function initCloneByTag(
                            object,
                            tag,
                            cloneFunc,
                            isDeep
                        ) {
                            var Ctor = object.constructor;

                            switch (tag) {
                                case arrayBufferTag:
                                    return cloneArrayBuffer(object);

                                case boolTag:
                                case dateTag:
                                    return new Ctor(+object);

                                case dataViewTag:
                                    return cloneDataView(object, isDeep);

                                case float32Tag:
                                case float64Tag:
                                case int8Tag:
                                case int16Tag:
                                case int32Tag:
                                case uint8Tag:
                                case uint8ClampedTag:
                                case uint16Tag:
                                case uint32Tag:
                                    return cloneTypedArray(object, isDeep);

                                case mapTag:
                                    return cloneMap(object, isDeep, cloneFunc);

                                case numberTag:
                                case stringTag:
                                    return new Ctor(object);

                                case regexpTag:
                                    return cloneRegExp(object);

                                case setTag:
                                    return cloneSet(object, isDeep, cloneFunc);

                                case symbolTag:
                                    return cloneSymbol(object);
                            }
                        }
                        /**
                         * Checks if `value` is a valid array-like index.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                         */

                        function isIndex(value, length) {
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return (
                                !!length &&
                                (typeof value == "number" ||
                                    reIsUint.test(value)) &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value < length
                            );
                        }
                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */

                        function isKeyable(value) {
                            var type = typeof value;
                            return type == "string" ||
                                type == "number" ||
                                type == "symbol" ||
                                type == "boolean"
                                ? value !== "__proto__"
                                : value === null;
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func;
                        }
                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */

                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto =
                                    (typeof Ctor == "function" &&
                                        Ctor.prototype) ||
                                    objectProto;
                            return value === proto;
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to process.
                         * @returns {string} Returns the source code.
                         */

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}

                                try {
                                    return func + "";
                                } catch (e) {}
                            }

                            return "";
                        }
                        /**
                         * This method is like `_.clone` except that it recursively clones `value`.
                         *
                         * @static
                         * @memberOf _
                         * @since 1.0.0
                         * @category Lang
                         * @param {*} value The value to recursively clone.
                         * @returns {*} Returns the deep cloned value.
                         * @see _.clone
                         * @example
                         *
                         * var objects = [{ 'a': 1 }, { 'b': 2 }];
                         *
                         * var deep = _.cloneDeep(objects);
                         * console.log(deep[0] === objects[0]);
                         * // => false
                         */

                        function cloneDeep(value) {
                            return baseClone(value, true, true);
                        }
                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */

                        function eq(value, other) {
                            return (
                                value === other ||
                                (value !== value && other !== other)
                            );
                        }
                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */

                        function isArguments(value) {
                            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                            return (
                                isArrayLikeObject(value) &&
                                hasOwnProperty.call(value, "callee") &&
                                (!propertyIsEnumerable.call(value, "callee") ||
                                    objectToString.call(value) == argsTag)
                            );
                        }
                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */

                        var isArray = Array.isArray;
                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */

                        function isArrayLike(value) {
                            return (
                                value != null &&
                                isLength(value.length) &&
                                !isFunction(value)
                            );
                        }
                        /**
                         * This method is like `_.isArrayLike` except that it also checks if `value`
                         * is an object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array-like object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArrayLikeObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLikeObject(document.body.children);
                         * // => true
                         *
                         * _.isArrayLikeObject('abc');
                         * // => false
                         *
                         * _.isArrayLikeObject(_.noop);
                         * // => false
                         */

                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */

                        var isBuffer = nativeIsBuffer || stubFalse;
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */

                        function isFunction(value) {
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 8-9 which returns 'object' for typed array and other constructors.
                            var tag = isObject(value)
                                ? objectToString.call(value)
                                : "";
                            return tag == funcTag || tag == genTag;
                        }
                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */

                        function isLength(value) {
                            return (
                                typeof value == "number" &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value <= MAX_SAFE_INTEGER
                            );
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */

                        function isObject(value) {
                            var type = typeof value;
                            return (
                                !!value &&
                                (type == "object" || type == "function")
                            );
                        }
                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */

                        function isObjectLike(value) {
                            return !!value && typeof value == "object";
                        }
                        /**
                         * Creates an array of the own enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects. See the
                         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * for more details.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keys(new Foo);
                         * // => ['a', 'b'] (iteration order is not guaranteed)
                         *
                         * _.keys('hi');
                         * // => ['0', '1']
                         */

                        function keys(object) {
                            return isArrayLike(object)
                                ? arrayLikeKeys(object)
                                : baseKeys(object);
                        }
                        /**
                         * This method returns a new empty array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Array} Returns the new empty array.
                         * @example
                         *
                         * var arrays = _.times(2, _.stubArray);
                         *
                         * console.log(arrays);
                         * // => [[], []]
                         *
                         * console.log(arrays[0] === arrays[1]);
                         * // => false
                         */

                        function stubArray() {
                            return [];
                        }
                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */

                        function stubFalse() {
                            return false;
                        }

                        module.exports = cloneDeep;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        ),
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash.isempty/index.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash.isempty/index.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global, module) {
                        /**
                         * lodash (Custom Build) <https://lodash.com/>
                         * Build: `lodash modularize exports="npm" -o ./`
                         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
                         * Released under MIT license <https://lodash.com/license>
                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                         */

                        /** Used as references for various `Number` constants. */
                        var MAX_SAFE_INTEGER = 9007199254740991;
                        /** `Object#toString` result references. */

                        var argsTag = "[object Arguments]",
                            funcTag = "[object Function]",
                            genTag = "[object GeneratorFunction]",
                            mapTag = "[object Map]",
                            objectTag = "[object Object]",
                            promiseTag = "[object Promise]",
                            setTag = "[object Set]",
                            weakMapTag = "[object WeakMap]";
                        var dataViewTag = "[object DataView]";
                        /**
                         * Used to match `RegExp`
                         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                         */

                        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                        /** Used to detect host constructors (Safari). */

                        var reIsHostCtor = /^\[object .+?Constructor\]$/;
                        /** Detect free variable `global` from Node.js. */

                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        /** Detect free variable `self`. */

                        var freeSelf =
                            typeof self == "object" &&
                            self &&
                            self.Object === Object &&
                            self;
                        /** Used as a reference to the global object. */

                        var root =
                            freeGlobal || freeSelf || Function("return this")();
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /**
                         * Gets the value at `key` of `object`.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */

                        function getValue(object, key) {
                            return object == null ? undefined : object[key];
                        }
                        /**
                         * Checks if `value` is a host object in IE < 9.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                         */

                        function isHostObject(value) {
                            // Many host objects are `Object` objects that can coerce to strings
                            // despite having improperly defined `toString` methods.
                            var result = false;

                            if (
                                value != null &&
                                typeof value.toString != "function"
                            ) {
                                try {
                                    result = !!(value + "");
                                } catch (e) {}
                            }

                            return result;
                        }
                        /**
                         * Creates a unary function that invokes `func` with its argument transformed.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {Function} transform The argument transform.
                         * @returns {Function} Returns the new function.
                         */

                        function overArg(func, transform) {
                            return function (arg) {
                                return func(transform(arg));
                            };
                        }
                        /** Used for built-in method references. */

                        var funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */

                        var coreJsData = root["__core-js_shared__"];
                        /** Used to detect methods masquerading as native. */

                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(
                                (coreJsData &&
                                    coreJsData.keys &&
                                    coreJsData.keys.IE_PROTO) ||
                                    ""
                            );
                            return uid ? "Symbol(src)_1." + uid : "";
                        })();
                        /** Used to resolve the decompiled source of functions. */

                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */

                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */

                        var objectToString = objectProto.toString;
                        /** Used to detect if a method is native. */

                        var reIsNative = RegExp(
                            "^" +
                                funcToString
                                    .call(hasOwnProperty)
                                    .replace(reRegExpChar, "\\$&")
                                    .replace(
                                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                        "$1.*?"
                                    ) +
                                "$"
                        );
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined,
                            propertyIsEnumerable =
                                objectProto.propertyIsEnumerable;
                        /* Built-in method references for those with the same name as other `lodash` methods. */

                        var nativeIsBuffer = Buffer
                                ? Buffer.isBuffer
                                : undefined,
                            nativeKeys = overArg(Object.keys, Object);
                        /* Built-in method references that are verified to be native. */

                        var DataView = getNative(root, "DataView"),
                            Map = getNative(root, "Map"),
                            Promise = getNative(root, "Promise"),
                            Set = getNative(root, "Set"),
                            WeakMap = getNative(root, "WeakMap");
                        /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */

                        var nonEnumShadows = !propertyIsEnumerable.call(
                            {
                                valueOf: 1,
                            },
                            "valueOf"
                        );
                        /** Used to detect maps, sets, and weakmaps. */

                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);
                        /**
                         * The base implementation of `getTag`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        function baseGetTag(value) {
                            return objectToString.call(value);
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }

                            var pattern =
                                isFunction(value) || isHostObject(value)
                                    ? reIsNative
                                    : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,
                        // for data views in Edge < 14, and promises in Node.js.

                        if (
                            (DataView &&
                                getTag(new DataView(new ArrayBuffer(1))) !=
                                    dataViewTag) ||
                            (Map && getTag(new Map()) != mapTag) ||
                            (Promise &&
                                getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set()) != setTag) ||
                            (WeakMap && getTag(new WeakMap()) != weakMapTag)
                        ) {
                            getTag = function (value) {
                                var result = objectToString.call(value),
                                    Ctor =
                                        result == objectTag
                                            ? value.constructor
                                            : undefined,
                                    ctorString = Ctor
                                        ? toSource(Ctor)
                                        : undefined;

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;

                                        case mapCtorString:
                                            return mapTag;

                                        case promiseCtorString:
                                            return promiseTag;

                                        case setCtorString:
                                            return setTag;

                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }

                                return result;
                            };
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func;
                        }
                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */

                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto =
                                    (typeof Ctor == "function" &&
                                        Ctor.prototype) ||
                                    objectProto;
                            return value === proto;
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to process.
                         * @returns {string} Returns the source code.
                         */

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}

                                try {
                                    return func + "";
                                } catch (e) {}
                            }

                            return "";
                        }
                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */

                        function isArguments(value) {
                            // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
                            return (
                                isArrayLikeObject(value) &&
                                hasOwnProperty.call(value, "callee") &&
                                (!propertyIsEnumerable.call(value, "callee") ||
                                    objectToString.call(value) == argsTag)
                            );
                        }
                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */

                        var isArray = Array.isArray;
                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */

                        function isArrayLike(value) {
                            return (
                                value != null &&
                                isLength(value.length) &&
                                !isFunction(value)
                            );
                        }
                        /**
                         * This method is like `_.isArrayLike` except that it also checks if `value`
                         * is an object.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array-like object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArrayLikeObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLikeObject(document.body.children);
                         * // => true
                         *
                         * _.isArrayLikeObject('abc');
                         * // => false
                         *
                         * _.isArrayLikeObject(_.noop);
                         * // => false
                         */

                        function isArrayLikeObject(value) {
                            return isObjectLike(value) && isArrayLike(value);
                        }
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */

                        var isBuffer = nativeIsBuffer || stubFalse;
                        /**
                         * Checks if `value` is an empty object, collection, map, or set.
                         *
                         * Objects are considered empty if they have no own enumerable string keyed
                         * properties.
                         *
                         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
                         * jQuery-like collections are considered empty if they have a `length` of `0`.
                         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
                         * @example
                         *
                         * _.isEmpty(null);
                         * // => true
                         *
                         * _.isEmpty(true);
                         * // => true
                         *
                         * _.isEmpty(1);
                         * // => true
                         *
                         * _.isEmpty([1, 2, 3]);
                         * // => false
                         *
                         * _.isEmpty({ 'a': 1 });
                         * // => false
                         */

                        function isEmpty(value) {
                            if (
                                isArrayLike(value) &&
                                (isArray(value) ||
                                    typeof value == "string" ||
                                    typeof value.splice == "function" ||
                                    isBuffer(value) ||
                                    isArguments(value))
                            ) {
                                return !value.length;
                            }

                            var tag = getTag(value);

                            if (tag == mapTag || tag == setTag) {
                                return !value.size;
                            }

                            if (nonEnumShadows || isPrototype(value)) {
                                return !nativeKeys(value).length;
                            }

                            for (var key in value) {
                                if (hasOwnProperty.call(value, key)) {
                                    return false;
                                }
                            }

                            return true;
                        }
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */

                        function isFunction(value) {
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 8-9 which returns 'object' for typed array and other constructors.
                            var tag = isObject(value)
                                ? objectToString.call(value)
                                : "";
                            return tag == funcTag || tag == genTag;
                        }
                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */

                        function isLength(value) {
                            return (
                                typeof value == "number" &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value <= MAX_SAFE_INTEGER
                            );
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */

                        function isObject(value) {
                            var type = typeof value;
                            return (
                                !!value &&
                                (type == "object" || type == "function")
                            );
                        }
                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */

                        function isObjectLike(value) {
                            return !!value && typeof value == "object";
                        }
                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */

                        function stubFalse() {
                            return false;
                        }

                        module.exports = isEmpty;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        ),
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash.isequal/index.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash.isequal/index.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global, module) {
                        /**
                         * Lodash (Custom Build) <https://lodash.com/>
                         * Build: `lodash modularize exports="npm" -o ./`
                         * Copyright JS Foundation and other contributors <https://js.foundation/>
                         * Released under MIT license <https://lodash.com/license>
                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                         */

                        /** Used as the size to enable large array optimizations. */
                        var LARGE_ARRAY_SIZE = 200;
                        /** Used to stand-in for `undefined` hash values. */

                        var HASH_UNDEFINED = "__lodash_hash_undefined__";
                        /** Used to compose bitmasks for value comparisons. */

                        var COMPARE_PARTIAL_FLAG = 1,
                            COMPARE_UNORDERED_FLAG = 2;
                        /** Used as references for various `Number` constants. */

                        var MAX_SAFE_INTEGER = 9007199254740991;
                        /** `Object#toString` result references. */

                        var argsTag = "[object Arguments]",
                            arrayTag = "[object Array]",
                            asyncTag = "[object AsyncFunction]",
                            boolTag = "[object Boolean]",
                            dateTag = "[object Date]",
                            errorTag = "[object Error]",
                            funcTag = "[object Function]",
                            genTag = "[object GeneratorFunction]",
                            mapTag = "[object Map]",
                            numberTag = "[object Number]",
                            nullTag = "[object Null]",
                            objectTag = "[object Object]",
                            promiseTag = "[object Promise]",
                            proxyTag = "[object Proxy]",
                            regexpTag = "[object RegExp]",
                            setTag = "[object Set]",
                            stringTag = "[object String]",
                            symbolTag = "[object Symbol]",
                            undefinedTag = "[object Undefined]",
                            weakMapTag = "[object WeakMap]";
                        var arrayBufferTag = "[object ArrayBuffer]",
                            dataViewTag = "[object DataView]",
                            float32Tag = "[object Float32Array]",
                            float64Tag = "[object Float64Array]",
                            int8Tag = "[object Int8Array]",
                            int16Tag = "[object Int16Array]",
                            int32Tag = "[object Int32Array]",
                            uint8Tag = "[object Uint8Array]",
                            uint8ClampedTag = "[object Uint8ClampedArray]",
                            uint16Tag = "[object Uint16Array]",
                            uint32Tag = "[object Uint32Array]";
                        /**
                         * Used to match `RegExp`
                         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                         */

                        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                        /** Used to detect host constructors (Safari). */

                        var reIsHostCtor = /^\[object .+?Constructor\]$/;
                        /** Used to detect unsigned integer values. */

                        var reIsUint = /^(?:0|[1-9]\d*)$/;
                        /** Used to identify `toStringTag` values of typed arrays. */

                        var typedArrayTags = {};
                        typedArrayTags[float32Tag] = typedArrayTags[
                            float64Tag
                        ] = typedArrayTags[int8Tag] = typedArrayTags[
                            int16Tag
                        ] = typedArrayTags[int32Tag] = typedArrayTags[
                            uint8Tag
                        ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
                            uint16Tag
                        ] = typedArrayTags[uint32Tag] = true;
                        typedArrayTags[argsTag] = typedArrayTags[
                            arrayTag
                        ] = typedArrayTags[arrayBufferTag] = typedArrayTags[
                            boolTag
                        ] = typedArrayTags[dataViewTag] = typedArrayTags[
                            dateTag
                        ] = typedArrayTags[errorTag] = typedArrayTags[
                            funcTag
                        ] = typedArrayTags[mapTag] = typedArrayTags[
                            numberTag
                        ] = typedArrayTags[objectTag] = typedArrayTags[
                            regexpTag
                        ] = typedArrayTags[setTag] = typedArrayTags[
                            stringTag
                        ] = typedArrayTags[weakMapTag] = false;
                        /** Detect free variable `global` from Node.js. */

                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        /** Detect free variable `self`. */

                        var freeSelf =
                            typeof self == "object" &&
                            self &&
                            self.Object === Object &&
                            self;
                        /** Used as a reference to the global object. */

                        var root =
                            freeGlobal || freeSelf || Function("return this")();
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /** Detect free variable `process` from Node.js. */

                        var freeProcess = moduleExports && freeGlobal.process;
                        /** Used to access faster Node.js helpers. */

                        var nodeUtil = (function () {
                            try {
                                return (
                                    freeProcess &&
                                    freeProcess.binding &&
                                    freeProcess.binding("util")
                                );
                            } catch (e) {}
                        })();
                        /* Node.js helper references. */

                        var nodeIsTypedArray =
                            nodeUtil && nodeUtil.isTypedArray;
                        /**
                         * A specialized version of `_.filter` for arrays without support for
                         * iteratee shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {Array} Returns the new filtered array.
                         */

                        function arrayFilter(array, predicate) {
                            var index = -1,
                                length = array == null ? 0 : array.length,
                                resIndex = 0,
                                result = [];

                            while (++index < length) {
                                var value = array[index];

                                if (predicate(value, index, array)) {
                                    result[resIndex++] = value;
                                }
                            }

                            return result;
                        }
                        /**
                         * Appends the elements of `values` to `array`.
                         *
                         * @private
                         * @param {Array} array The array to modify.
                         * @param {Array} values The values to append.
                         * @returns {Array} Returns `array`.
                         */

                        function arrayPush(array, values) {
                            var index = -1,
                                length = values.length,
                                offset = array.length;

                            while (++index < length) {
                                array[offset + index] = values[index];
                            }

                            return array;
                        }
                        /**
                         * A specialized version of `_.some` for arrays without support for iteratee
                         * shorthands.
                         *
                         * @private
                         * @param {Array} [array] The array to iterate over.
                         * @param {Function} predicate The function invoked per iteration.
                         * @returns {boolean} Returns `true` if any element passes the predicate check,
                         *  else `false`.
                         */

                        function arraySome(array, predicate) {
                            var index = -1,
                                length = array == null ? 0 : array.length;

                            while (++index < length) {
                                if (predicate(array[index], index, array)) {
                                    return true;
                                }
                            }

                            return false;
                        }
                        /**
                         * The base implementation of `_.times` without support for iteratee shorthands
                         * or max array length checks.
                         *
                         * @private
                         * @param {number} n The number of times to invoke `iteratee`.
                         * @param {Function} iteratee The function invoked per iteration.
                         * @returns {Array} Returns the array of results.
                         */

                        function baseTimes(n, iteratee) {
                            var index = -1,
                                result = Array(n);

                            while (++index < n) {
                                result[index] = iteratee(index);
                            }

                            return result;
                        }
                        /**
                         * The base implementation of `_.unary` without support for storing metadata.
                         *
                         * @private
                         * @param {Function} func The function to cap arguments for.
                         * @returns {Function} Returns the new capped function.
                         */

                        function baseUnary(func) {
                            return function (value) {
                                return func(value);
                            };
                        }
                        /**
                         * Checks if a `cache` value for `key` exists.
                         *
                         * @private
                         * @param {Object} cache The cache to query.
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function cacheHas(cache, key) {
                            return cache.has(key);
                        }
                        /**
                         * Gets the value at `key` of `object`.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */

                        function getValue(object, key) {
                            return object == null ? undefined : object[key];
                        }
                        /**
                         * Converts `map` to its key-value pairs.
                         *
                         * @private
                         * @param {Object} map The map to convert.
                         * @returns {Array} Returns the key-value pairs.
                         */

                        function mapToArray(map) {
                            var index = -1,
                                result = Array(map.size);
                            map.forEach(function (value, key) {
                                result[++index] = [key, value];
                            });
                            return result;
                        }
                        /**
                         * Creates a unary function that invokes `func` with its argument transformed.
                         *
                         * @private
                         * @param {Function} func The function to wrap.
                         * @param {Function} transform The argument transform.
                         * @returns {Function} Returns the new function.
                         */

                        function overArg(func, transform) {
                            return function (arg) {
                                return func(transform(arg));
                            };
                        }
                        /**
                         * Converts `set` to an array of its values.
                         *
                         * @private
                         * @param {Object} set The set to convert.
                         * @returns {Array} Returns the values.
                         */

                        function setToArray(set) {
                            var index = -1,
                                result = Array(set.size);
                            set.forEach(function (value) {
                                result[++index] = value;
                            });
                            return result;
                        }
                        /** Used for built-in method references. */

                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */

                        var coreJsData = root["__core-js_shared__"];
                        /** Used to resolve the decompiled source of functions. */

                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */

                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /** Used to detect methods masquerading as native. */

                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(
                                (coreJsData &&
                                    coreJsData.keys &&
                                    coreJsData.keys.IE_PROTO) ||
                                    ""
                            );
                            return uid ? "Symbol(src)_1." + uid : "";
                        })();
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */

                        var nativeObjectToString = objectProto.toString;
                        /** Used to detect if a method is native. */

                        var reIsNative = RegExp(
                            "^" +
                                funcToString
                                    .call(hasOwnProperty)
                                    .replace(reRegExpChar, "\\$&")
                                    .replace(
                                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                        "$1.*?"
                                    ) +
                                "$"
                        );
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined,
                            Symbol = root.Symbol,
                            Uint8Array = root.Uint8Array,
                            propertyIsEnumerable =
                                objectProto.propertyIsEnumerable,
                            splice = arrayProto.splice,
                            symToStringTag = Symbol
                                ? Symbol.toStringTag
                                : undefined;
                        /* Built-in method references for those with the same name as other `lodash` methods. */

                        var nativeGetSymbols = Object.getOwnPropertySymbols,
                            nativeIsBuffer = Buffer
                                ? Buffer.isBuffer
                                : undefined,
                            nativeKeys = overArg(Object.keys, Object);
                        /* Built-in method references that are verified to be native. */

                        var DataView = getNative(root, "DataView"),
                            Map = getNative(root, "Map"),
                            Promise = getNative(root, "Promise"),
                            Set = getNative(root, "Set"),
                            WeakMap = getNative(root, "WeakMap"),
                            nativeCreate = getNative(Object, "create");
                        /** Used to detect maps, sets, and weakmaps. */

                        var dataViewCtorString = toSource(DataView),
                            mapCtorString = toSource(Map),
                            promiseCtorString = toSource(Promise),
                            setCtorString = toSource(Set),
                            weakMapCtorString = toSource(WeakMap);
                        /** Used to convert symbols to primitives and strings. */

                        var symbolProto = Symbol ? Symbol.prototype : undefined,
                            symbolValueOf = symbolProto
                                ? symbolProto.valueOf
                                : undefined;
                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Hash(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */

                        function hashClear() {
                            this.__data__ = nativeCreate
                                ? nativeCreate(null)
                                : {};
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function hashDelete(key) {
                            var result =
                                this.has(key) && delete this.__data__[key];
                            this.size -= result ? 1 : 0;
                            return result;
                        }
                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function hashGet(key) {
                            var data = this.__data__;

                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED
                                    ? undefined
                                    : result;
                            }

                            return hasOwnProperty.call(data, key)
                                ? data[key]
                                : undefined;
                        }
                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate
                                ? data[key] !== undefined
                                : hasOwnProperty.call(data, key);
                        }
                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */

                        function hashSet(key, value) {
                            var data = this.__data__;
                            this.size += this.has(key) ? 0 : 1;
                            data[key] =
                                nativeCreate && value === undefined
                                    ? HASH_UNDEFINED
                                    : value;
                            return this;
                        } // Add methods to `Hash`.

                        Hash.prototype.clear = hashClear;
                        Hash.prototype["delete"] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;
                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function ListCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */

                        function listCacheClear() {
                            this.__data__ = [];
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }

                            var lastIndex = data.length - 1;

                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }

                            --this.size;
                            return true;
                        }
                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1];
                        }
                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }
                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */

                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                ++this.size;
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }

                            return this;
                        } // Add methods to `ListCache`.

                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype["delete"] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;
                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function MapCache(entries) {
                            var index = -1,
                                length = entries == null ? 0 : entries.length;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */

                        function mapCacheClear() {
                            this.size = 0;
                            this.__data__ = {
                                hash: new Hash(),
                                map: new (Map || ListCache)(),
                                string: new Hash(),
                            };
                        }
                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function mapCacheDelete(key) {
                            var result = getMapData(this, key)["delete"](key);
                            this.size -= result ? 1 : 0;
                            return result;
                        }
                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }
                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }
                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */

                        function mapCacheSet(key, value) {
                            var data = getMapData(this, key),
                                size = data.size;
                            data.set(key, value);
                            this.size += data.size == size ? 0 : 1;
                            return this;
                        } // Add methods to `MapCache`.

                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype["delete"] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;
                        /**
                         *
                         * Creates an array cache object to store unique values.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [values] The values to cache.
                         */

                        function SetCache(values) {
                            var index = -1,
                                length = values == null ? 0 : values.length;
                            this.__data__ = new MapCache();

                            while (++index < length) {
                                this.add(values[index]);
                            }
                        }
                        /**
                         * Adds `value` to the array cache.
                         *
                         * @private
                         * @name add
                         * @memberOf SetCache
                         * @alias push
                         * @param {*} value The value to cache.
                         * @returns {Object} Returns the cache instance.
                         */

                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);

                            return this;
                        }
                        /**
                         * Checks if `value` is in the array cache.
                         *
                         * @private
                         * @name has
                         * @memberOf SetCache
                         * @param {*} value The value to search for.
                         * @returns {number} Returns `true` if `value` is found, else `false`.
                         */

                        function setCacheHas(value) {
                            return this.__data__.has(value);
                        } // Add methods to `SetCache`.

                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;
                        /**
                         * Creates a stack cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Stack(entries) {
                            var data = (this.__data__ = new ListCache(entries));
                            this.size = data.size;
                        }
                        /**
                         * Removes all key-value entries from the stack.
                         *
                         * @private
                         * @name clear
                         * @memberOf Stack
                         */

                        function stackClear() {
                            this.__data__ = new ListCache();
                            this.size = 0;
                        }
                        /**
                         * Removes `key` and its value from the stack.
                         *
                         * @private
                         * @name delete
                         * @memberOf Stack
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function stackDelete(key) {
                            var data = this.__data__,
                                result = data["delete"](key);
                            this.size = data.size;
                            return result;
                        }
                        /**
                         * Gets the stack value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Stack
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function stackGet(key) {
                            return this.__data__.get(key);
                        }
                        /**
                         * Checks if a stack value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Stack
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function stackHas(key) {
                            return this.__data__.has(key);
                        }
                        /**
                         * Sets the stack `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Stack
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the stack cache instance.
                         */

                        function stackSet(key, value) {
                            var data = this.__data__;

                            if (data instanceof ListCache) {
                                var pairs = data.__data__;

                                if (
                                    !Map ||
                                    pairs.length < LARGE_ARRAY_SIZE - 1
                                ) {
                                    pairs.push([key, value]);
                                    this.size = ++data.size;
                                    return this;
                                }

                                data = this.__data__ = new MapCache(pairs);
                            }

                            data.set(key, value);
                            this.size = data.size;
                            return this;
                        } // Add methods to `Stack`.

                        Stack.prototype.clear = stackClear;
                        Stack.prototype["delete"] = stackDelete;
                        Stack.prototype.get = stackGet;
                        Stack.prototype.has = stackHas;
                        Stack.prototype.set = stackSet;
                        /**
                         * Creates an array of the enumerable property names of the array-like `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @param {boolean} inherited Specify returning inherited property names.
                         * @returns {Array} Returns the array of property names.
                         */

                        function arrayLikeKeys(value, inherited) {
                            var isArr = isArray(value),
                                isArg = !isArr && isArguments(value),
                                isBuff = !isArr && !isArg && isBuffer(value),
                                isType =
                                    !isArr &&
                                    !isArg &&
                                    !isBuff &&
                                    isTypedArray(value),
                                skipIndexes =
                                    isArr || isArg || isBuff || isType,
                                result = skipIndexes
                                    ? baseTimes(value.length, String)
                                    : [],
                                length = result.length;

                            for (var key in value) {
                                if (
                                    (inherited ||
                                        hasOwnProperty.call(value, key)) &&
                                    !(
                                        skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                                        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                                            (isBuff &&
                                                (key == "offset" ||
                                                    key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                            (isType &&
                                                (key == "buffer" ||
                                                    key == "byteLength" ||
                                                    key == "byteOffset")) || // Skip index properties.
                                            isIndex(key, length))
                                    )
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function assocIndexOf(array, key) {
                            var length = array.length;

                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                         * symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {Function} keysFunc The function to get the keys of `object`.
                         * @param {Function} symbolsFunc The function to get the symbols of `object`.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                            var result = keysFunc(object);
                            return isArray(object)
                                ? result
                                : arrayPush(result, symbolsFunc(object));
                        }
                        /**
                         * The base implementation of `getTag` without fallbacks for buggy environments.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        function baseGetTag(value) {
                            if (value == null) {
                                return value === undefined
                                    ? undefinedTag
                                    : nullTag;
                            }

                            return symToStringTag &&
                                symToStringTag in Object(value)
                                ? getRawTag(value)
                                : objectToString(value);
                        }
                        /**
                         * The base implementation of `_.isArguments`.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         */

                        function baseIsArguments(value) {
                            return (
                                isObjectLike(value) &&
                                baseGetTag(value) == argsTag
                            );
                        }
                        /**
                         * The base implementation of `_.isEqual` which supports partial comparisons
                         * and tracks traversed objects.
                         *
                         * @private
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @param {boolean} bitmask The bitmask flags.
                         *  1 - Unordered comparison
                         *  2 - Partial comparison
                         * @param {Function} [customizer] The function to customize comparisons.
                         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         */

                        function baseIsEqual(
                            value,
                            other,
                            bitmask,
                            customizer,
                            stack
                        ) {
                            if (value === other) {
                                return true;
                            }

                            if (
                                value == null ||
                                other == null ||
                                (!isObjectLike(value) && !isObjectLike(other))
                            ) {
                                return value !== value && other !== other;
                            }

                            return baseIsEqualDeep(
                                value,
                                other,
                                bitmask,
                                customizer,
                                baseIsEqual,
                                stack
                            );
                        }
                        /**
                         * A specialized version of `baseIsEqual` for arrays and objects which performs
                         * deep comparisons and tracks traversed objects enabling objects with circular
                         * references to be compared.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */

                        function baseIsEqualDeep(
                            object,
                            other,
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        ) {
                            var objIsArr = isArray(object),
                                othIsArr = isArray(other),
                                objTag = objIsArr ? arrayTag : getTag(object),
                                othTag = othIsArr ? arrayTag : getTag(other);
                            objTag = objTag == argsTag ? objectTag : objTag;
                            othTag = othTag == argsTag ? objectTag : othTag;
                            var objIsObj = objTag == objectTag,
                                othIsObj = othTag == objectTag,
                                isSameTag = objTag == othTag;

                            if (isSameTag && isBuffer(object)) {
                                if (!isBuffer(other)) {
                                    return false;
                                }

                                objIsArr = true;
                                objIsObj = false;
                            }

                            if (isSameTag && !objIsObj) {
                                stack || (stack = new Stack());
                                return objIsArr || isTypedArray(object)
                                    ? equalArrays(
                                          object,
                                          other,
                                          bitmask,
                                          customizer,
                                          equalFunc,
                                          stack
                                      )
                                    : equalByTag(
                                          object,
                                          other,
                                          objTag,
                                          bitmask,
                                          customizer,
                                          equalFunc,
                                          stack
                                      );
                            }

                            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                                var objIsWrapped =
                                        objIsObj &&
                                        hasOwnProperty.call(
                                            object,
                                            "__wrapped__"
                                        ),
                                    othIsWrapped =
                                        othIsObj &&
                                        hasOwnProperty.call(
                                            other,
                                            "__wrapped__"
                                        );

                                if (objIsWrapped || othIsWrapped) {
                                    var objUnwrapped = objIsWrapped
                                            ? object.value()
                                            : object,
                                        othUnwrapped = othIsWrapped
                                            ? other.value()
                                            : other;
                                    stack || (stack = new Stack());
                                    return equalFunc(
                                        objUnwrapped,
                                        othUnwrapped,
                                        bitmask,
                                        customizer,
                                        stack
                                    );
                                }
                            }

                            if (!isSameTag) {
                                return false;
                            }

                            stack || (stack = new Stack());
                            return equalObjects(
                                object,
                                other,
                                bitmask,
                                customizer,
                                equalFunc,
                                stack
                            );
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }

                            var pattern = isFunction(value)
                                ? reIsNative
                                : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * The base implementation of `_.isTypedArray` without Node.js optimizations.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         */

                        function baseIsTypedArray(value) {
                            return (
                                isObjectLike(value) &&
                                isLength(value.length) &&
                                !!typedArrayTags[baseGetTag(value)]
                            );
                        }
                        /**
                         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         */

                        function baseKeys(object) {
                            if (!isPrototype(object)) {
                                return nativeKeys(object);
                            }

                            var result = [];

                            for (var key in Object(object)) {
                                if (
                                    hasOwnProperty.call(object, key) &&
                                    key != "constructor"
                                ) {
                                    result.push(key);
                                }
                            }

                            return result;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for arrays with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Array} array The array to compare.
                         * @param {Array} other The other array to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `array` and `other` objects.
                         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
                         */

                        function equalArrays(
                            array,
                            other,
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        ) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                arrLength = array.length,
                                othLength = other.length;

                            if (
                                arrLength != othLength &&
                                !(isPartial && othLength > arrLength)
                            ) {
                                return false;
                            } // Assume cyclic values are equal.

                            var stacked = stack.get(array);

                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }

                            var index = -1,
                                result = true,
                                seen =
                                    bitmask & COMPARE_UNORDERED_FLAG
                                        ? new SetCache()
                                        : undefined;
                            stack.set(array, other);
                            stack.set(other, array); // Ignore non-index properties.

                            while (++index < arrLength) {
                                var arrValue = array[index],
                                    othValue = other[index];

                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(
                                              othValue,
                                              arrValue,
                                              index,
                                              other,
                                              array,
                                              stack
                                          )
                                        : customizer(
                                              arrValue,
                                              othValue,
                                              index,
                                              array,
                                              other,
                                              stack
                                          );
                                }

                                if (compared !== undefined) {
                                    if (compared) {
                                        continue;
                                    }

                                    result = false;
                                    break;
                                } // Recursively compare arrays (susceptible to call stack limits).

                                if (seen) {
                                    if (
                                        !arraySome(other, function (
                                            othValue,
                                            othIndex
                                        ) {
                                            if (
                                                !cacheHas(seen, othIndex) &&
                                                (arrValue === othValue ||
                                                    equalFunc(
                                                        arrValue,
                                                        othValue,
                                                        bitmask,
                                                        customizer,
                                                        stack
                                                    ))
                                            ) {
                                                return seen.push(othIndex);
                                            }
                                        })
                                    ) {
                                        result = false;
                                        break;
                                    }
                                } else if (
                                    !(
                                        arrValue === othValue ||
                                        equalFunc(
                                            arrValue,
                                            othValue,
                                            bitmask,
                                            customizer,
                                            stack
                                        )
                                    )
                                ) {
                                    result = false;
                                    break;
                                }
                            }

                            stack["delete"](array);
                            stack["delete"](other);
                            return result;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for comparing objects of
                         * the same `toStringTag`.
                         *
                         * **Note:** This function only supports comparing values with tags of
                         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {string} tag The `toStringTag` of the objects to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */

                        function equalByTag(
                            object,
                            other,
                            tag,
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        ) {
                            switch (tag) {
                                case dataViewTag:
                                    if (
                                        object.byteLength != other.byteLength ||
                                        object.byteOffset != other.byteOffset
                                    ) {
                                        return false;
                                    }

                                    object = object.buffer;
                                    other = other.buffer;

                                case arrayBufferTag:
                                    if (
                                        object.byteLength != other.byteLength ||
                                        !equalFunc(
                                            new Uint8Array(object),
                                            new Uint8Array(other)
                                        )
                                    ) {
                                        return false;
                                    }

                                    return true;

                                case boolTag:
                                case dateTag:
                                case numberTag:
                                    // Coerce booleans to `1` or `0` and dates to milliseconds.
                                    // Invalid dates are coerced to `NaN`.
                                    return eq(+object, +other);

                                case errorTag:
                                    return (
                                        object.name == other.name &&
                                        object.message == other.message
                                    );

                                case regexpTag:
                                case stringTag:
                                    // Coerce regexes to strings and treat strings, primitives and objects,
                                    // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                                    // for more details.
                                    return object == other + "";

                                case mapTag:
                                    var convert = mapToArray;

                                case setTag:
                                    var isPartial =
                                        bitmask & COMPARE_PARTIAL_FLAG;
                                    convert || (convert = setToArray);

                                    if (
                                        object.size != other.size &&
                                        !isPartial
                                    ) {
                                        return false;
                                    } // Assume cyclic values are equal.

                                    var stacked = stack.get(object);

                                    if (stacked) {
                                        return stacked == other;
                                    }

                                    bitmask |= COMPARE_UNORDERED_FLAG; // Recursively compare objects (susceptible to call stack limits).

                                    stack.set(object, other);
                                    var result = equalArrays(
                                        convert(object),
                                        convert(other),
                                        bitmask,
                                        customizer,
                                        equalFunc,
                                        stack
                                    );
                                    stack["delete"](object);
                                    return result;

                                case symbolTag:
                                    if (symbolValueOf) {
                                        return (
                                            symbolValueOf.call(object) ==
                                            symbolValueOf.call(other)
                                        );
                                    }
                            }

                            return false;
                        }
                        /**
                         * A specialized version of `baseIsEqualDeep` for objects with support for
                         * partial deep comparisons.
                         *
                         * @private
                         * @param {Object} object The object to compare.
                         * @param {Object} other The other object to compare.
                         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
                         * @param {Function} customizer The function to customize comparisons.
                         * @param {Function} equalFunc The function to determine equivalents of values.
                         * @param {Object} stack Tracks traversed `object` and `other` objects.
                         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
                         */

                        function equalObjects(
                            object,
                            other,
                            bitmask,
                            customizer,
                            equalFunc,
                            stack
                        ) {
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                                objProps = getAllKeys(object),
                                objLength = objProps.length,
                                othProps = getAllKeys(other),
                                othLength = othProps.length;

                            if (objLength != othLength && !isPartial) {
                                return false;
                            }

                            var index = objLength;

                            while (index--) {
                                var key = objProps[index];

                                if (
                                    !(isPartial
                                        ? key in other
                                        : hasOwnProperty.call(other, key))
                                ) {
                                    return false;
                                }
                            } // Assume cyclic values are equal.

                            var stacked = stack.get(object);

                            if (stacked && stack.get(other)) {
                                return stacked == other;
                            }

                            var result = true;
                            stack.set(object, other);
                            stack.set(other, object);
                            var skipCtor = isPartial;

                            while (++index < objLength) {
                                key = objProps[index];
                                var objValue = object[key],
                                    othValue = other[key];

                                if (customizer) {
                                    var compared = isPartial
                                        ? customizer(
                                              othValue,
                                              objValue,
                                              key,
                                              other,
                                              object,
                                              stack
                                          )
                                        : customizer(
                                              objValue,
                                              othValue,
                                              key,
                                              object,
                                              other,
                                              stack
                                          );
                                } // Recursively compare objects (susceptible to call stack limits).

                                if (
                                    !(compared === undefined
                                        ? objValue === othValue ||
                                          equalFunc(
                                              objValue,
                                              othValue,
                                              bitmask,
                                              customizer,
                                              stack
                                          )
                                        : compared)
                                ) {
                                    result = false;
                                    break;
                                }

                                skipCtor || (skipCtor = key == "constructor");
                            }

                            if (result && !skipCtor) {
                                var objCtor = object.constructor,
                                    othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.

                                if (
                                    objCtor != othCtor &&
                                    "constructor" in object &&
                                    "constructor" in other &&
                                    !(
                                        typeof objCtor == "function" &&
                                        objCtor instanceof objCtor &&
                                        typeof othCtor == "function" &&
                                        othCtor instanceof othCtor
                                    )
                                ) {
                                    result = false;
                                }
                            }

                            stack["delete"](object);
                            stack["delete"](other);
                            return result;
                        }
                        /**
                         * Creates an array of own enumerable property names and symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names and symbols.
                         */

                        function getAllKeys(object) {
                            return baseGetAllKeys(object, keys, getSymbols);
                        }
                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */

                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[
                                      typeof key == "string" ? "string" : "hash"
                                  ]
                                : data.map;
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the raw `toStringTag`.
                         */

                        function getRawTag(value) {
                            var isOwn = hasOwnProperty.call(
                                    value,
                                    symToStringTag
                                ),
                                tag = value[symToStringTag];

                            try {
                                value[symToStringTag] = undefined;
                                var unmasked = true;
                            } catch (e) {}

                            var result = nativeObjectToString.call(value);

                            if (unmasked) {
                                if (isOwn) {
                                    value[symToStringTag] = tag;
                                } else {
                                    delete value[symToStringTag];
                                }
                            }

                            return result;
                        }
                        /**
                         * Creates an array of the own enumerable symbols of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of symbols.
                         */

                        var getSymbols = !nativeGetSymbols
                            ? stubArray
                            : function (object) {
                                  if (object == null) {
                                      return [];
                                  }

                                  object = Object(object);
                                  return arrayFilter(
                                      nativeGetSymbols(object),
                                      function (symbol) {
                                          return propertyIsEnumerable.call(
                                              object,
                                              symbol
                                          );
                                      }
                                  );
                              };
                        /**
                         * Gets the `toStringTag` of `value`.
                         *
                         * @private
                         * @param {*} value The value to query.
                         * @returns {string} Returns the `toStringTag`.
                         */

                        var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

                        if (
                            (DataView &&
                                getTag(new DataView(new ArrayBuffer(1))) !=
                                    dataViewTag) ||
                            (Map && getTag(new Map()) != mapTag) ||
                            (Promise &&
                                getTag(Promise.resolve()) != promiseTag) ||
                            (Set && getTag(new Set()) != setTag) ||
                            (WeakMap && getTag(new WeakMap()) != weakMapTag)
                        ) {
                            getTag = function (value) {
                                var result = baseGetTag(value),
                                    Ctor =
                                        result == objectTag
                                            ? value.constructor
                                            : undefined,
                                    ctorString = Ctor ? toSource(Ctor) : "";

                                if (ctorString) {
                                    switch (ctorString) {
                                        case dataViewCtorString:
                                            return dataViewTag;

                                        case mapCtorString:
                                            return mapTag;

                                        case promiseCtorString:
                                            return promiseTag;

                                        case setCtorString:
                                            return setTag;

                                        case weakMapCtorString:
                                            return weakMapTag;
                                    }
                                }

                                return result;
                            };
                        }
                        /**
                         * Checks if `value` is a valid array-like index.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                         */

                        function isIndex(value, length) {
                            length = length == null ? MAX_SAFE_INTEGER : length;
                            return (
                                !!length &&
                                (typeof value == "number" ||
                                    reIsUint.test(value)) &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value < length
                            );
                        }
                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */

                        function isKeyable(value) {
                            var type = typeof value;
                            return type == "string" ||
                                type == "number" ||
                                type == "symbol" ||
                                type == "boolean"
                                ? value !== "__proto__"
                                : value === null;
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func;
                        }
                        /**
                         * Checks if `value` is likely a prototype object.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                         */

                        function isPrototype(value) {
                            var Ctor = value && value.constructor,
                                proto =
                                    (typeof Ctor == "function" &&
                                        Ctor.prototype) ||
                                    objectProto;
                            return value === proto;
                        }
                        /**
                         * Converts `value` to a string using `Object.prototype.toString`.
                         *
                         * @private
                         * @param {*} value The value to convert.
                         * @returns {string} Returns the converted string.
                         */

                        function objectToString(value) {
                            return nativeObjectToString.call(value);
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to convert.
                         * @returns {string} Returns the source code.
                         */

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}

                                try {
                                    return func + "";
                                } catch (e) {}
                            }

                            return "";
                        }
                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */

                        function eq(value, other) {
                            return (
                                value === other ||
                                (value !== value && other !== other)
                            );
                        }
                        /**
                         * Checks if `value` is likely an `arguments` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                         *  else `false`.
                         * @example
                         *
                         * _.isArguments(function() { return arguments; }());
                         * // => true
                         *
                         * _.isArguments([1, 2, 3]);
                         * // => false
                         */

                        var isArguments = baseIsArguments(
                            (function () {
                                return arguments;
                            })()
                        )
                            ? baseIsArguments
                            : function (value) {
                                  return (
                                      isObjectLike(value) &&
                                      hasOwnProperty.call(value, "callee") &&
                                      !propertyIsEnumerable.call(
                                          value,
                                          "callee"
                                      )
                                  );
                              };
                        /**
                         * Checks if `value` is classified as an `Array` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                         * @example
                         *
                         * _.isArray([1, 2, 3]);
                         * // => true
                         *
                         * _.isArray(document.body.children);
                         * // => false
                         *
                         * _.isArray('abc');
                         * // => false
                         *
                         * _.isArray(_.noop);
                         * // => false
                         */

                        var isArray = Array.isArray;
                        /**
                         * Checks if `value` is array-like. A value is considered array-like if it's
                         * not a function and has a `value.length` that's an integer greater than or
                         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                         * @example
                         *
                         * _.isArrayLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isArrayLike(document.body.children);
                         * // => true
                         *
                         * _.isArrayLike('abc');
                         * // => true
                         *
                         * _.isArrayLike(_.noop);
                         * // => false
                         */

                        function isArrayLike(value) {
                            return (
                                value != null &&
                                isLength(value.length) &&
                                !isFunction(value)
                            );
                        }
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */

                        var isBuffer = nativeIsBuffer || stubFalse;
                        /**
                         * Performs a deep comparison between two values to determine if they are
                         * equivalent.
                         *
                         * **Note:** This method supports comparing arrays, array buffers, booleans,
                         * date objects, error objects, maps, numbers, `Object` objects, regexes,
                         * sets, strings, symbols, and typed arrays. `Object` objects are compared
                         * by their own, not inherited, enumerable properties. Functions and DOM
                         * nodes are compared by strict equality, i.e. `===`.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.isEqual(object, other);
                         * // => true
                         *
                         * object === other;
                         * // => false
                         */

                        function isEqual(value, other) {
                            return baseIsEqual(value, other);
                        }
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */

                        function isFunction(value) {
                            if (!isObject(value)) {
                                return false;
                            } // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 9 which returns 'object' for typed arrays and other constructors.

                            var tag = baseGetTag(value);
                            return (
                                tag == funcTag ||
                                tag == genTag ||
                                tag == asyncTag ||
                                tag == proxyTag
                            );
                        }
                        /**
                         * Checks if `value` is a valid array-like length.
                         *
                         * **Note:** This method is loosely based on
                         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                         * @example
                         *
                         * _.isLength(3);
                         * // => true
                         *
                         * _.isLength(Number.MIN_VALUE);
                         * // => false
                         *
                         * _.isLength(Infinity);
                         * // => false
                         *
                         * _.isLength('3');
                         * // => false
                         */

                        function isLength(value) {
                            return (
                                typeof value == "number" &&
                                value > -1 &&
                                value % 1 == 0 &&
                                value <= MAX_SAFE_INTEGER
                            );
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */

                        function isObject(value) {
                            var type = typeof value;
                            return (
                                value != null &&
                                (type == "object" || type == "function")
                            );
                        }
                        /**
                         * Checks if `value` is object-like. A value is object-like if it's not `null`
                         * and has a `typeof` result of "object".
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                         * @example
                         *
                         * _.isObjectLike({});
                         * // => true
                         *
                         * _.isObjectLike([1, 2, 3]);
                         * // => true
                         *
                         * _.isObjectLike(_.noop);
                         * // => false
                         *
                         * _.isObjectLike(null);
                         * // => false
                         */

                        function isObjectLike(value) {
                            return value != null && typeof value == "object";
                        }
                        /**
                         * Checks if `value` is classified as a typed array.
                         *
                         * @static
                         * @memberOf _
                         * @since 3.0.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                         * @example
                         *
                         * _.isTypedArray(new Uint8Array);
                         * // => true
                         *
                         * _.isTypedArray([]);
                         * // => false
                         */

                        var isTypedArray = nodeIsTypedArray
                            ? baseUnary(nodeIsTypedArray)
                            : baseIsTypedArray;
                        /**
                         * Creates an array of the own enumerable property names of `object`.
                         *
                         * **Note:** Non-object values are coerced to objects. See the
                         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                         * for more details.
                         *
                         * @static
                         * @since 0.1.0
                         * @memberOf _
                         * @category Object
                         * @param {Object} object The object to query.
                         * @returns {Array} Returns the array of property names.
                         * @example
                         *
                         * function Foo() {
                         *   this.a = 1;
                         *   this.b = 2;
                         * }
                         *
                         * Foo.prototype.c = 3;
                         *
                         * _.keys(new Foo);
                         * // => ['a', 'b'] (iteration order is not guaranteed)
                         *
                         * _.keys('hi');
                         * // => ['0', '1']
                         */

                        function keys(object) {
                            return isArrayLike(object)
                                ? arrayLikeKeys(object)
                                : baseKeys(object);
                        }
                        /**
                         * This method returns a new empty array.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {Array} Returns the new empty array.
                         * @example
                         *
                         * var arrays = _.times(2, _.stubArray);
                         *
                         * console.log(arrays);
                         * // => [[], []]
                         *
                         * console.log(arrays[0] === arrays[1]);
                         * // => false
                         */

                        function stubArray() {
                            return [];
                        }
                        /**
                         * This method returns `false`.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.13.0
                         * @category Util
                         * @returns {boolean} Returns `false`.
                         * @example
                         *
                         * _.times(2, _.stubFalse);
                         * // => [false, false]
                         */

                        function stubFalse() {
                            return false;
                        }

                        module.exports = isEqual;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        ),
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash.uniq/index.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash.uniq/index.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global) {
                        /**
                         * lodash (Custom Build) <https://lodash.com/>
                         * Build: `lodash modularize exports="npm" -o ./`
                         * Copyright jQuery Foundation and other contributors <https://jquery.org/>
                         * Released under MIT license <https://lodash.com/license>
                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                         */

                        /** Used as the size to enable large array optimizations. */
                        var LARGE_ARRAY_SIZE = 200;
                        /** Used to stand-in for `undefined` hash values. */

                        var HASH_UNDEFINED = "__lodash_hash_undefined__";
                        /** Used as references for various `Number` constants. */

                        var INFINITY = 1 / 0;
                        /** `Object#toString` result references. */

                        var funcTag = "[object Function]",
                            genTag = "[object GeneratorFunction]";
                        /**
                         * Used to match `RegExp`
                         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                         */

                        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                        /** Used to detect host constructors (Safari). */

                        var reIsHostCtor = /^\[object .+?Constructor\]$/;
                        /** Detect free variable `global` from Node.js. */

                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        /** Detect free variable `self`. */

                        var freeSelf =
                            typeof self == "object" &&
                            self &&
                            self.Object === Object &&
                            self;
                        /** Used as a reference to the global object. */

                        var root =
                            freeGlobal || freeSelf || Function("return this")();
                        /**
                         * A specialized version of `_.includes` for arrays without support for
                         * specifying an index to search from.
                         *
                         * @private
                         * @param {Array} [array] The array to inspect.
                         * @param {*} target The value to search for.
                         * @returns {boolean} Returns `true` if `target` is found, else `false`.
                         */

                        function arrayIncludes(array, value) {
                            var length = array ? array.length : 0;
                            return (
                                !!length && baseIndexOf(array, value, 0) > -1
                            );
                        }
                        /**
                         * This function is like `arrayIncludes` except that it accepts a comparator.
                         *
                         * @private
                         * @param {Array} [array] The array to inspect.
                         * @param {*} target The value to search for.
                         * @param {Function} comparator The comparator invoked per element.
                         * @returns {boolean} Returns `true` if `target` is found, else `false`.
                         */

                        function arrayIncludesWith(array, value, comparator) {
                            var index = -1,
                                length = array ? array.length : 0;

                            while (++index < length) {
                                if (comparator(value, array[index])) {
                                    return true;
                                }
                            }

                            return false;
                        }
                        /**
                         * The base implementation of `_.findIndex` and `_.findLastIndex` without
                         * support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} predicate The function invoked per iteration.
                         * @param {number} fromIndex The index to search from.
                         * @param {boolean} [fromRight] Specify iterating from right to left.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function baseFindIndex(
                            array,
                            predicate,
                            fromIndex,
                            fromRight
                        ) {
                            var length = array.length,
                                index = fromIndex + (fromRight ? 1 : -1);

                            while (fromRight ? index-- : ++index < length) {
                                if (predicate(array[index], index, array)) {
                                    return index;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} value The value to search for.
                         * @param {number} fromIndex The index to search from.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function baseIndexOf(array, value, fromIndex) {
                            if (value !== value) {
                                return baseFindIndex(
                                    array,
                                    baseIsNaN,
                                    fromIndex
                                );
                            }

                            var index = fromIndex - 1,
                                length = array.length;

                            while (++index < length) {
                                if (array[index] === value) {
                                    return index;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `_.isNaN` without support for number objects.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
                         */

                        function baseIsNaN(value) {
                            return value !== value;
                        }
                        /**
                         * Checks if a cache value for `key` exists.
                         *
                         * @private
                         * @param {Object} cache The cache to query.
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function cacheHas(cache, key) {
                            return cache.has(key);
                        }
                        /**
                         * Gets the value at `key` of `object`.
                         *
                         * @private
                         * @param {Object} [object] The object to query.
                         * @param {string} key The key of the property to get.
                         * @returns {*} Returns the property value.
                         */

                        function getValue(object, key) {
                            return object == null ? undefined : object[key];
                        }
                        /**
                         * Checks if `value` is a host object in IE < 9.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
                         */

                        function isHostObject(value) {
                            // Many host objects are `Object` objects that can coerce to strings
                            // despite having improperly defined `toString` methods.
                            var result = false;

                            if (
                                value != null &&
                                typeof value.toString != "function"
                            ) {
                                try {
                                    result = !!(value + "");
                                } catch (e) {}
                            }

                            return result;
                        }
                        /**
                         * Converts `set` to an array of its values.
                         *
                         * @private
                         * @param {Object} set The set to convert.
                         * @returns {Array} Returns the values.
                         */

                        function setToArray(set) {
                            var index = -1,
                                result = Array(set.size);
                            set.forEach(function (value) {
                                result[++index] = value;
                            });
                            return result;
                        }
                        /** Used for built-in method references. */

                        var arrayProto = Array.prototype,
                            funcProto = Function.prototype,
                            objectProto = Object.prototype;
                        /** Used to detect overreaching core-js shims. */

                        var coreJsData = root["__core-js_shared__"];
                        /** Used to detect methods masquerading as native. */

                        var maskSrcKey = (function () {
                            var uid = /[^.]+$/.exec(
                                (coreJsData &&
                                    coreJsData.keys &&
                                    coreJsData.keys.IE_PROTO) ||
                                    ""
                            );
                            return uid ? "Symbol(src)_1." + uid : "";
                        })();
                        /** Used to resolve the decompiled source of functions. */

                        var funcToString = funcProto.toString;
                        /** Used to check objects for own properties. */

                        var hasOwnProperty = objectProto.hasOwnProperty;
                        /**
                         * Used to resolve the
                         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                         * of values.
                         */

                        var objectToString = objectProto.toString;
                        /** Used to detect if a method is native. */

                        var reIsNative = RegExp(
                            "^" +
                                funcToString
                                    .call(hasOwnProperty)
                                    .replace(reRegExpChar, "\\$&")
                                    .replace(
                                        /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                        "$1.*?"
                                    ) +
                                "$"
                        );
                        /** Built-in value references. */

                        var splice = arrayProto.splice;
                        /* Built-in method references that are verified to be native. */

                        var Map = getNative(root, "Map"),
                            Set = getNative(root, "Set"),
                            nativeCreate = getNative(Object, "create");
                        /**
                         * Creates a hash object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function Hash(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the hash.
                         *
                         * @private
                         * @name clear
                         * @memberOf Hash
                         */

                        function hashClear() {
                            this.__data__ = nativeCreate
                                ? nativeCreate(null)
                                : {};
                        }
                        /**
                         * Removes `key` and its value from the hash.
                         *
                         * @private
                         * @name delete
                         * @memberOf Hash
                         * @param {Object} hash The hash to modify.
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function hashDelete(key) {
                            return this.has(key) && delete this.__data__[key];
                        }
                        /**
                         * Gets the hash value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf Hash
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function hashGet(key) {
                            var data = this.__data__;

                            if (nativeCreate) {
                                var result = data[key];
                                return result === HASH_UNDEFINED
                                    ? undefined
                                    : result;
                            }

                            return hasOwnProperty.call(data, key)
                                ? data[key]
                                : undefined;
                        }
                        /**
                         * Checks if a hash value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf Hash
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function hashHas(key) {
                            var data = this.__data__;
                            return nativeCreate
                                ? data[key] !== undefined
                                : hasOwnProperty.call(data, key);
                        }
                        /**
                         * Sets the hash `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf Hash
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the hash instance.
                         */

                        function hashSet(key, value) {
                            var data = this.__data__;
                            data[key] =
                                nativeCreate && value === undefined
                                    ? HASH_UNDEFINED
                                    : value;
                            return this;
                        } // Add methods to `Hash`.

                        Hash.prototype.clear = hashClear;
                        Hash.prototype["delete"] = hashDelete;
                        Hash.prototype.get = hashGet;
                        Hash.prototype.has = hashHas;
                        Hash.prototype.set = hashSet;
                        /**
                         * Creates an list cache object.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function ListCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the list cache.
                         *
                         * @private
                         * @name clear
                         * @memberOf ListCache
                         */

                        function listCacheClear() {
                            this.__data__ = [];
                        }
                        /**
                         * Removes `key` and its value from the list cache.
                         *
                         * @private
                         * @name delete
                         * @memberOf ListCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function listCacheDelete(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                return false;
                            }

                            var lastIndex = data.length - 1;

                            if (index == lastIndex) {
                                data.pop();
                            } else {
                                splice.call(data, index, 1);
                            }

                            return true;
                        }
                        /**
                         * Gets the list cache value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf ListCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function listCacheGet(key) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);
                            return index < 0 ? undefined : data[index][1];
                        }
                        /**
                         * Checks if a list cache value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf ListCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function listCacheHas(key) {
                            return assocIndexOf(this.__data__, key) > -1;
                        }
                        /**
                         * Sets the list cache `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf ListCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the list cache instance.
                         */

                        function listCacheSet(key, value) {
                            var data = this.__data__,
                                index = assocIndexOf(data, key);

                            if (index < 0) {
                                data.push([key, value]);
                            } else {
                                data[index][1] = value;
                            }

                            return this;
                        } // Add methods to `ListCache`.

                        ListCache.prototype.clear = listCacheClear;
                        ListCache.prototype["delete"] = listCacheDelete;
                        ListCache.prototype.get = listCacheGet;
                        ListCache.prototype.has = listCacheHas;
                        ListCache.prototype.set = listCacheSet;
                        /**
                         * Creates a map cache object to store key-value pairs.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [entries] The key-value pairs to cache.
                         */

                        function MapCache(entries) {
                            var index = -1,
                                length = entries ? entries.length : 0;
                            this.clear();

                            while (++index < length) {
                                var entry = entries[index];
                                this.set(entry[0], entry[1]);
                            }
                        }
                        /**
                         * Removes all key-value entries from the map.
                         *
                         * @private
                         * @name clear
                         * @memberOf MapCache
                         */

                        function mapCacheClear() {
                            this.__data__ = {
                                hash: new Hash(),
                                map: new (Map || ListCache)(),
                                string: new Hash(),
                            };
                        }
                        /**
                         * Removes `key` and its value from the map.
                         *
                         * @private
                         * @name delete
                         * @memberOf MapCache
                         * @param {string} key The key of the value to remove.
                         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                         */

                        function mapCacheDelete(key) {
                            return getMapData(this, key)["delete"](key);
                        }
                        /**
                         * Gets the map value for `key`.
                         *
                         * @private
                         * @name get
                         * @memberOf MapCache
                         * @param {string} key The key of the value to get.
                         * @returns {*} Returns the entry value.
                         */

                        function mapCacheGet(key) {
                            return getMapData(this, key).get(key);
                        }
                        /**
                         * Checks if a map value for `key` exists.
                         *
                         * @private
                         * @name has
                         * @memberOf MapCache
                         * @param {string} key The key of the entry to check.
                         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                         */

                        function mapCacheHas(key) {
                            return getMapData(this, key).has(key);
                        }
                        /**
                         * Sets the map `key` to `value`.
                         *
                         * @private
                         * @name set
                         * @memberOf MapCache
                         * @param {string} key The key of the value to set.
                         * @param {*} value The value to set.
                         * @returns {Object} Returns the map cache instance.
                         */

                        function mapCacheSet(key, value) {
                            getMapData(this, key).set(key, value);
                            return this;
                        } // Add methods to `MapCache`.

                        MapCache.prototype.clear = mapCacheClear;
                        MapCache.prototype["delete"] = mapCacheDelete;
                        MapCache.prototype.get = mapCacheGet;
                        MapCache.prototype.has = mapCacheHas;
                        MapCache.prototype.set = mapCacheSet;
                        /**
                         *
                         * Creates an array cache object to store unique values.
                         *
                         * @private
                         * @constructor
                         * @param {Array} [values] The values to cache.
                         */

                        function SetCache(values) {
                            var index = -1,
                                length = values ? values.length : 0;
                            this.__data__ = new MapCache();

                            while (++index < length) {
                                this.add(values[index]);
                            }
                        }
                        /**
                         * Adds `value` to the array cache.
                         *
                         * @private
                         * @name add
                         * @memberOf SetCache
                         * @alias push
                         * @param {*} value The value to cache.
                         * @returns {Object} Returns the cache instance.
                         */

                        function setCacheAdd(value) {
                            this.__data__.set(value, HASH_UNDEFINED);

                            return this;
                        }
                        /**
                         * Checks if `value` is in the array cache.
                         *
                         * @private
                         * @name has
                         * @memberOf SetCache
                         * @param {*} value The value to search for.
                         * @returns {number} Returns `true` if `value` is found, else `false`.
                         */

                        function setCacheHas(value) {
                            return this.__data__.has(value);
                        } // Add methods to `SetCache`.

                        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
                        SetCache.prototype.has = setCacheHas;
                        /**
                         * Gets the index at which the `key` is found in `array` of key-value pairs.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {*} key The key to search for.
                         * @returns {number} Returns the index of the matched value, else `-1`.
                         */

                        function assocIndexOf(array, key) {
                            var length = array.length;

                            while (length--) {
                                if (eq(array[length][0], key)) {
                                    return length;
                                }
                            }

                            return -1;
                        }
                        /**
                         * The base implementation of `_.isNative` without bad shim checks.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a native function,
                         *  else `false`.
                         */

                        function baseIsNative(value) {
                            if (!isObject(value) || isMasked(value)) {
                                return false;
                            }

                            var pattern =
                                isFunction(value) || isHostObject(value)
                                    ? reIsNative
                                    : reIsHostCtor;
                            return pattern.test(toSource(value));
                        }
                        /**
                         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
                         *
                         * @private
                         * @param {Array} array The array to inspect.
                         * @param {Function} [iteratee] The iteratee invoked per element.
                         * @param {Function} [comparator] The comparator invoked per element.
                         * @returns {Array} Returns the new duplicate free array.
                         */

                        function baseUniq(array, iteratee, comparator) {
                            var index = -1,
                                includes = arrayIncludes,
                                length = array.length,
                                isCommon = true,
                                result = [],
                                seen = result;

                            if (comparator) {
                                isCommon = false;
                                includes = arrayIncludesWith;
                            } else if (length >= LARGE_ARRAY_SIZE) {
                                var set = iteratee ? null : createSet(array);

                                if (set) {
                                    return setToArray(set);
                                }

                                isCommon = false;
                                includes = cacheHas;
                                seen = new SetCache();
                            } else {
                                seen = iteratee ? [] : result;
                            }

                            outer: while (++index < length) {
                                var value = array[index],
                                    computed = iteratee
                                        ? iteratee(value)
                                        : value;
                                value = comparator || value !== 0 ? value : 0;

                                if (isCommon && computed === computed) {
                                    var seenIndex = seen.length;

                                    while (seenIndex--) {
                                        if (seen[seenIndex] === computed) {
                                            continue outer;
                                        }
                                    }

                                    if (iteratee) {
                                        seen.push(computed);
                                    }

                                    result.push(value);
                                } else if (
                                    !includes(seen, computed, comparator)
                                ) {
                                    if (seen !== result) {
                                        seen.push(computed);
                                    }

                                    result.push(value);
                                }
                            }

                            return result;
                        }
                        /**
                         * Creates a set object of `values`.
                         *
                         * @private
                         * @param {Array} values The values to add to the set.
                         * @returns {Object} Returns the new set.
                         */

                        var createSet = !(
                            Set &&
                            1 / setToArray(new Set([, -0]))[1] == INFINITY
                        )
                            ? noop
                            : function (values) {
                                  return new Set(values);
                              };
                        /**
                         * Gets the data for `map`.
                         *
                         * @private
                         * @param {Object} map The map to query.
                         * @param {string} key The reference key.
                         * @returns {*} Returns the map data.
                         */

                        function getMapData(map, key) {
                            var data = map.__data__;
                            return isKeyable(key)
                                ? data[
                                      typeof key == "string" ? "string" : "hash"
                                  ]
                                : data.map;
                        }
                        /**
                         * Gets the native function at `key` of `object`.
                         *
                         * @private
                         * @param {Object} object The object to query.
                         * @param {string} key The key of the method to get.
                         * @returns {*} Returns the function if it's native, else `undefined`.
                         */

                        function getNative(object, key) {
                            var value = getValue(object, key);
                            return baseIsNative(value) ? value : undefined;
                        }
                        /**
                         * Checks if `value` is suitable for use as unique object key.
                         *
                         * @private
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                         */

                        function isKeyable(value) {
                            var type = typeof value;
                            return type == "string" ||
                                type == "number" ||
                                type == "symbol" ||
                                type == "boolean"
                                ? value !== "__proto__"
                                : value === null;
                        }
                        /**
                         * Checks if `func` has its source masked.
                         *
                         * @private
                         * @param {Function} func The function to check.
                         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                         */

                        function isMasked(func) {
                            return !!maskSrcKey && maskSrcKey in func;
                        }
                        /**
                         * Converts `func` to its source code.
                         *
                         * @private
                         * @param {Function} func The function to process.
                         * @returns {string} Returns the source code.
                         */

                        function toSource(func) {
                            if (func != null) {
                                try {
                                    return funcToString.call(func);
                                } catch (e) {}

                                try {
                                    return func + "";
                                } catch (e) {}
                            }

                            return "";
                        }
                        /**
                         * Creates a duplicate-free version of an array, using
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * for equality comparisons, in which only the first occurrence of each
                         * element is kept.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Array
                         * @param {Array} array The array to inspect.
                         * @returns {Array} Returns the new duplicate free array.
                         * @example
                         *
                         * _.uniq([2, 1, 2]);
                         * // => [2, 1]
                         */

                        function uniq(array) {
                            return array && array.length ? baseUniq(array) : [];
                        }
                        /**
                         * Performs a
                         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                         * comparison between two values to determine if they are equivalent.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.0.0
                         * @category Lang
                         * @param {*} value The value to compare.
                         * @param {*} other The other value to compare.
                         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                         * @example
                         *
                         * var object = { 'a': 1 };
                         * var other = { 'a': 1 };
                         *
                         * _.eq(object, object);
                         * // => true
                         *
                         * _.eq(object, other);
                         * // => false
                         *
                         * _.eq('a', 'a');
                         * // => true
                         *
                         * _.eq('a', Object('a'));
                         * // => false
                         *
                         * _.eq(NaN, NaN);
                         * // => true
                         */

                        function eq(value, other) {
                            return (
                                value === other ||
                                (value !== value && other !== other)
                            );
                        }
                        /**
                         * Checks if `value` is classified as a `Function` object.
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                         * @example
                         *
                         * _.isFunction(_);
                         * // => true
                         *
                         * _.isFunction(/abc/);
                         * // => false
                         */

                        function isFunction(value) {
                            // The use of `Object#toString` avoids issues with the `typeof` operator
                            // in Safari 8-9 which returns 'object' for typed array and other constructors.
                            var tag = isObject(value)
                                ? objectToString.call(value)
                                : "";
                            return tag == funcTag || tag == genTag;
                        }
                        /**
                         * Checks if `value` is the
                         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                         *
                         * @static
                         * @memberOf _
                         * @since 0.1.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                         * @example
                         *
                         * _.isObject({});
                         * // => true
                         *
                         * _.isObject([1, 2, 3]);
                         * // => true
                         *
                         * _.isObject(_.noop);
                         * // => true
                         *
                         * _.isObject(null);
                         * // => false
                         */

                        function isObject(value) {
                            var type = typeof value;
                            return (
                                !!value &&
                                (type == "object" || type == "function")
                            );
                        }
                        /**
                         * This method returns `undefined`.
                         *
                         * @static
                         * @memberOf _
                         * @since 2.3.0
                         * @category Util
                         * @example
                         *
                         * _.times(2, _.noop);
                         * // => [undefined, undefined]
                         */

                        function noop() {
                            // No operation performed.
                        }

                        module.exports = uniq;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        )
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash/_DataView.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                        ),
                        root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                    /* Built-in method references that are verified to be native. */

                    var DataView = getNative(root, "DataView");
                    module.exports = DataView;

                    /***/
                },

            /***/ "./node_modules/lodash/_Hash.js":
                /*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var hashClear = __webpack_require__(
                            /*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"
                        ),
                        hashDelete = __webpack_require__(
                            /*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"
                        ),
                        hashGet = __webpack_require__(
                            /*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"
                        ),
                        hashHas = __webpack_require__(
                            /*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"
                        ),
                        hashSet = __webpack_require__(
                            /*! ./_hashSet */ "./node_modules/lodash/_hashSet.js"
                        );
                    /**
                     * Creates a hash object.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */

                    function Hash(entries) {
                        var index = -1,
                            length = entries == null ? 0 : entries.length;
                        this.clear();

                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    } // Add methods to `Hash`.

                    Hash.prototype.clear = hashClear;
                    Hash.prototype["delete"] = hashDelete;
                    Hash.prototype.get = hashGet;
                    Hash.prototype.has = hashHas;
                    Hash.prototype.set = hashSet;
                    module.exports = Hash;

                    /***/
                },

            /***/ "./node_modules/lodash/_ListCache.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var listCacheClear = __webpack_require__(
                            /*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"
                        ),
                        listCacheDelete = __webpack_require__(
                            /*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"
                        ),
                        listCacheGet = __webpack_require__(
                            /*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"
                        ),
                        listCacheHas = __webpack_require__(
                            /*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"
                        ),
                        listCacheSet = __webpack_require__(
                            /*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js"
                        );
                    /**
                     * Creates an list cache object.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */

                    function ListCache(entries) {
                        var index = -1,
                            length = entries == null ? 0 : entries.length;
                        this.clear();

                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    } // Add methods to `ListCache`.

                    ListCache.prototype.clear = listCacheClear;
                    ListCache.prototype["delete"] = listCacheDelete;
                    ListCache.prototype.get = listCacheGet;
                    ListCache.prototype.has = listCacheHas;
                    ListCache.prototype.set = listCacheSet;
                    module.exports = ListCache;

                    /***/
                },

            /***/ "./node_modules/lodash/_Map.js":
                /*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                        ),
                        root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                    /* Built-in method references that are verified to be native. */

                    var Map = getNative(root, "Map");
                    module.exports = Map;

                    /***/
                },

            /***/ "./node_modules/lodash/_MapCache.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var mapCacheClear = __webpack_require__(
                            /*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"
                        ),
                        mapCacheDelete = __webpack_require__(
                            /*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"
                        ),
                        mapCacheGet = __webpack_require__(
                            /*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"
                        ),
                        mapCacheHas = __webpack_require__(
                            /*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"
                        ),
                        mapCacheSet = __webpack_require__(
                            /*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js"
                        );
                    /**
                     * Creates a map cache object to store key-value pairs.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */

                    function MapCache(entries) {
                        var index = -1,
                            length = entries == null ? 0 : entries.length;
                        this.clear();

                        while (++index < length) {
                            var entry = entries[index];
                            this.set(entry[0], entry[1]);
                        }
                    } // Add methods to `MapCache`.

                    MapCache.prototype.clear = mapCacheClear;
                    MapCache.prototype["delete"] = mapCacheDelete;
                    MapCache.prototype.get = mapCacheGet;
                    MapCache.prototype.has = mapCacheHas;
                    MapCache.prototype.set = mapCacheSet;
                    module.exports = MapCache;

                    /***/
                },

            /***/ "./node_modules/lodash/_Promise.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                        ),
                        root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                    /* Built-in method references that are verified to be native. */

                    var Promise = getNative(root, "Promise");
                    module.exports = Promise;

                    /***/
                },

            /***/ "./node_modules/lodash/_Set.js":
                /*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                        ),
                        root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                    /* Built-in method references that are verified to be native. */

                    var Set = getNative(root, "Set");
                    module.exports = Set;

                    /***/
                },

            /***/ "./node_modules/lodash/_Stack.js":
                /*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var ListCache = __webpack_require__(
                            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
                        ),
                        stackClear = __webpack_require__(
                            /*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"
                        ),
                        stackDelete = __webpack_require__(
                            /*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"
                        ),
                        stackGet = __webpack_require__(
                            /*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"
                        ),
                        stackHas = __webpack_require__(
                            /*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"
                        ),
                        stackSet = __webpack_require__(
                            /*! ./_stackSet */ "./node_modules/lodash/_stackSet.js"
                        );
                    /**
                     * Creates a stack cache object to store key-value pairs.
                     *
                     * @private
                     * @constructor
                     * @param {Array} [entries] The key-value pairs to cache.
                     */

                    function Stack(entries) {
                        var data = (this.__data__ = new ListCache(entries));
                        this.size = data.size;
                    } // Add methods to `Stack`.

                    Stack.prototype.clear = stackClear;
                    Stack.prototype["delete"] = stackDelete;
                    Stack.prototype.get = stackGet;
                    Stack.prototype.has = stackHas;
                    Stack.prototype.set = stackSet;
                    module.exports = Stack;

                    /***/
                },

            /***/ "./node_modules/lodash/_Symbol.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var root = __webpack_require__(
                        /*! ./_root */ "./node_modules/lodash/_root.js"
                    );
                    /** Built-in value references. */

                    var Symbol = root.Symbol;
                    module.exports = Symbol;

                    /***/
                },

            /***/ "./node_modules/lodash/_Uint8Array.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var root = __webpack_require__(
                        /*! ./_root */ "./node_modules/lodash/_root.js"
                    );
                    /** Built-in value references. */

                    var Uint8Array = root.Uint8Array;
                    module.exports = Uint8Array;

                    /***/
                },

            /***/ "./node_modules/lodash/_WeakMap.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                            /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                        ),
                        root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                    /* Built-in method references that are verified to be native. */

                    var WeakMap = getNative(root, "WeakMap");
                    module.exports = WeakMap;

                    /***/
                },

            /***/ "./node_modules/lodash/_apply.js":
                /*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * A faster alternative to `Function#apply`, this function invokes `func`
                     * with the `this` binding of `thisArg` and the arguments of `args`.
                     *
                     * @private
                     * @param {Function} func The function to invoke.
                     * @param {*} thisArg The `this` binding of `func`.
                     * @param {Array} args The arguments to invoke `func` with.
                     * @returns {*} Returns the result of `func`.
                     */
                    function apply(func, thisArg, args) {
                        switch (args.length) {
                            case 0:
                                return func.call(thisArg);

                            case 1:
                                return func.call(thisArg, args[0]);

                            case 2:
                                return func.call(thisArg, args[0], args[1]);

                            case 3:
                                return func.call(
                                    thisArg,
                                    args[0],
                                    args[1],
                                    args[2]
                                );
                        }

                        return func.apply(thisArg, args);
                    }

                    module.exports = apply;

                    /***/
                },

            /***/ "./node_modules/lodash/_arrayEach.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * A specialized version of `_.forEach` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayEach(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length;

                        while (++index < length) {
                            if (
                                iteratee(array[index], index, array) === false
                            ) {
                                break;
                            }
                        }

                        return array;
                    }

                    module.exports = arrayEach;

                    /***/
                },

            /***/ "./node_modules/lodash/_arrayFilter.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * A specialized version of `_.filter` for arrays without support for
                     * iteratee shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} predicate The function invoked per iteration.
                     * @returns {Array} Returns the new filtered array.
                     */
                    function arrayFilter(array, predicate) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            resIndex = 0,
                            result = [];

                        while (++index < length) {
                            var value = array[index];

                            if (predicate(value, index, array)) {
                                result[resIndex++] = value;
                            }
                        }

                        return result;
                    }

                    module.exports = arrayFilter;

                    /***/
                },

            /***/ "./node_modules/lodash/_arrayLikeKeys.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseTimes = __webpack_require__(
                            /*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"
                        ),
                        isArguments = __webpack_require__(
                            /*! ./isArguments */ "./node_modules/lodash/isArguments.js"
                        ),
                        isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        ),
                        isBuffer = __webpack_require__(
                            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
                        ),
                        isIndex = __webpack_require__(
                            /*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"
                        ),
                        isTypedArray = __webpack_require__(
                            /*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Creates an array of the enumerable property names of the array-like `value`.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @param {boolean} inherited Specify returning inherited property names.
                     * @returns {Array} Returns the array of property names.
                     */

                    function arrayLikeKeys(value, inherited) {
                        var isArr = isArray(value),
                            isArg = !isArr && isArguments(value),
                            isBuff = !isArr && !isArg && isBuffer(value),
                            isType =
                                !isArr &&
                                !isArg &&
                                !isBuff &&
                                isTypedArray(value),
                            skipIndexes = isArr || isArg || isBuff || isType,
                            result = skipIndexes
                                ? baseTimes(value.length, String)
                                : [],
                            length = result.length;

                        for (var key in value) {
                            if (
                                (inherited ||
                                    hasOwnProperty.call(value, key)) &&
                                !(
                                    skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
                                    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
                                        (isBuff &&
                                            (key == "offset" ||
                                                key == "parent")) || // PhantomJS 2 has enumerable non-index properties on typed arrays.
                                        (isType &&
                                            (key == "buffer" ||
                                                key == "byteLength" ||
                                                key == "byteOffset")) || // Skip index properties.
                                        isIndex(key, length))
                                )
                            ) {
                                result.push(key);
                            }
                        }

                        return result;
                    }

                    module.exports = arrayLikeKeys;

                    /***/
                },

            /***/ "./node_modules/lodash/_arrayMap.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * A specialized version of `_.map` for arrays without support for iteratee
                     * shorthands.
                     *
                     * @private
                     * @param {Array} [array] The array to iterate over.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the new mapped array.
                     */
                    function arrayMap(array, iteratee) {
                        var index = -1,
                            length = array == null ? 0 : array.length,
                            result = Array(length);

                        while (++index < length) {
                            result[index] = iteratee(
                                array[index],
                                index,
                                array
                            );
                        }

                        return result;
                    }

                    module.exports = arrayMap;

                    /***/
                },

            /***/ "./node_modules/lodash/_arrayPush.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Appends the elements of `values` to `array`.
                     *
                     * @private
                     * @param {Array} array The array to modify.
                     * @param {Array} values The values to append.
                     * @returns {Array} Returns `array`.
                     */
                    function arrayPush(array, values) {
                        var index = -1,
                            length = values.length,
                            offset = array.length;

                        while (++index < length) {
                            array[offset + index] = values[index];
                        }

                        return array;
                    }

                    module.exports = arrayPush;

                    /***/
                },

            /***/ "./node_modules/lodash/_assignValue.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseAssignValue = __webpack_require__(
                            /*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"
                        ),
                        eq = __webpack_require__(
                            /*! ./eq */ "./node_modules/lodash/eq.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Assigns `value` to `key` of `object` if the existing value is not equivalent
                     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                     * for equality comparisons.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {string} key The key of the property to assign.
                     * @param {*} value The value to assign.
                     */

                    function assignValue(object, key, value) {
                        var objValue = object[key];

                        if (
                            !(
                                hasOwnProperty.call(object, key) &&
                                eq(objValue, value)
                            ) ||
                            (value === undefined && !(key in object))
                        ) {
                            baseAssignValue(object, key, value);
                        }
                    }

                    module.exports = assignValue;

                    /***/
                },

            /***/ "./node_modules/lodash/_assocIndexOf.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var eq = __webpack_require__(
                        /*! ./eq */ "./node_modules/lodash/eq.js"
                    );
                    /**
                     * Gets the index at which the `key` is found in `array` of key-value pairs.
                     *
                     * @private
                     * @param {Array} array The array to inspect.
                     * @param {*} key The key to search for.
                     * @returns {number} Returns the index of the matched value, else `-1`.
                     */

                    function assocIndexOf(array, key) {
                        var length = array.length;

                        while (length--) {
                            if (eq(array[length][0], key)) {
                                return length;
                            }
                        }

                        return -1;
                    }

                    module.exports = assocIndexOf;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseAssign.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var copyObject = __webpack_require__(
                            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
                        ),
                        keys = __webpack_require__(
                            /*! ./keys */ "./node_modules/lodash/keys.js"
                        );
                    /**
                     * The base implementation of `_.assign` without support for multiple sources
                     * or `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */

                    function baseAssign(object, source) {
                        return (
                            object && copyObject(source, keys(source), object)
                        );
                    }

                    module.exports = baseAssign;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseAssignIn.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var copyObject = __webpack_require__(
                            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
                        ),
                        keysIn = __webpack_require__(
                            /*! ./keysIn */ "./node_modules/lodash/keysIn.js"
                        );
                    /**
                     * The base implementation of `_.assignIn` without support for multiple sources
                     * or `customizer` functions.
                     *
                     * @private
                     * @param {Object} object The destination object.
                     * @param {Object} source The source object.
                     * @returns {Object} Returns `object`.
                     */

                    function baseAssignIn(object, source) {
                        return (
                            object && copyObject(source, keysIn(source), object)
                        );
                    }

                    module.exports = baseAssignIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseAssignValue.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var defineProperty = __webpack_require__(
                        /*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"
                    );
                    /**
                     * The base implementation of `assignValue` and `assignMergeValue` without
                     * value checks.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {string} key The key of the property to assign.
                     * @param {*} value The value to assign.
                     */

                    function baseAssignValue(object, key, value) {
                        if (key == "__proto__" && defineProperty) {
                            defineProperty(object, key, {
                                configurable: true,
                                enumerable: true,
                                value: value,
                                writable: true,
                            });
                        } else {
                            object[key] = value;
                        }
                    }

                    module.exports = baseAssignValue;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseClone.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Stack = __webpack_require__(
                            /*! ./_Stack */ "./node_modules/lodash/_Stack.js"
                        ),
                        arrayEach = __webpack_require__(
                            /*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"
                        ),
                        assignValue = __webpack_require__(
                            /*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"
                        ),
                        baseAssign = __webpack_require__(
                            /*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"
                        ),
                        baseAssignIn = __webpack_require__(
                            /*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"
                        ),
                        cloneBuffer = __webpack_require__(
                            /*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"
                        ),
                        copyArray = __webpack_require__(
                            /*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"
                        ),
                        copySymbols = __webpack_require__(
                            /*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"
                        ),
                        copySymbolsIn = __webpack_require__(
                            /*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"
                        ),
                        getAllKeys = __webpack_require__(
                            /*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"
                        ),
                        getAllKeysIn = __webpack_require__(
                            /*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"
                        ),
                        getTag = __webpack_require__(
                            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
                        ),
                        initCloneArray = __webpack_require__(
                            /*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"
                        ),
                        initCloneByTag = __webpack_require__(
                            /*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"
                        ),
                        initCloneObject = __webpack_require__(
                            /*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"
                        ),
                        isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        ),
                        isBuffer = __webpack_require__(
                            /*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"
                        ),
                        isMap = __webpack_require__(
                            /*! ./isMap */ "./node_modules/lodash/isMap.js"
                        ),
                        isObject = __webpack_require__(
                            /*! ./isObject */ "./node_modules/lodash/isObject.js"
                        ),
                        isSet = __webpack_require__(
                            /*! ./isSet */ "./node_modules/lodash/isSet.js"
                        ),
                        keys = __webpack_require__(
                            /*! ./keys */ "./node_modules/lodash/keys.js"
                        );
                    /** Used to compose bitmasks for cloning. */

                    var CLONE_DEEP_FLAG = 1,
                        CLONE_FLAT_FLAG = 2,
                        CLONE_SYMBOLS_FLAG = 4;
                    /** `Object#toString` result references. */

                    var argsTag = "[object Arguments]",
                        arrayTag = "[object Array]",
                        boolTag = "[object Boolean]",
                        dateTag = "[object Date]",
                        errorTag = "[object Error]",
                        funcTag = "[object Function]",
                        genTag = "[object GeneratorFunction]",
                        mapTag = "[object Map]",
                        numberTag = "[object Number]",
                        objectTag = "[object Object]",
                        regexpTag = "[object RegExp]",
                        setTag = "[object Set]",
                        stringTag = "[object String]",
                        symbolTag = "[object Symbol]",
                        weakMapTag = "[object WeakMap]";
                    var arrayBufferTag = "[object ArrayBuffer]",
                        dataViewTag = "[object DataView]",
                        float32Tag = "[object Float32Array]",
                        float64Tag = "[object Float64Array]",
                        int8Tag = "[object Int8Array]",
                        int16Tag = "[object Int16Array]",
                        int32Tag = "[object Int32Array]",
                        uint8Tag = "[object Uint8Array]",
                        uint8ClampedTag = "[object Uint8ClampedArray]",
                        uint16Tag = "[object Uint16Array]",
                        uint32Tag = "[object Uint32Array]";
                    /** Used to identify `toStringTag` values supported by `_.clone`. */

                    var cloneableTags = {};
                    cloneableTags[argsTag] = cloneableTags[
                        arrayTag
                    ] = cloneableTags[arrayBufferTag] = cloneableTags[
                        dataViewTag
                    ] = cloneableTags[boolTag] = cloneableTags[
                        dateTag
                    ] = cloneableTags[float32Tag] = cloneableTags[
                        float64Tag
                    ] = cloneableTags[int8Tag] = cloneableTags[
                        int16Tag
                    ] = cloneableTags[int32Tag] = cloneableTags[
                        mapTag
                    ] = cloneableTags[numberTag] = cloneableTags[
                        objectTag
                    ] = cloneableTags[regexpTag] = cloneableTags[
                        setTag
                    ] = cloneableTags[stringTag] = cloneableTags[
                        symbolTag
                    ] = cloneableTags[uint8Tag] = cloneableTags[
                        uint8ClampedTag
                    ] = cloneableTags[uint16Tag] = cloneableTags[
                        uint32Tag
                    ] = true;
                    cloneableTags[errorTag] = cloneableTags[
                        funcTag
                    ] = cloneableTags[weakMapTag] = false;
                    /**
                     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
                     * traversed objects.
                     *
                     * @private
                     * @param {*} value The value to clone.
                     * @param {boolean} bitmask The bitmask flags.
                     *  1 - Deep clone
                     *  2 - Flatten inherited properties
                     *  4 - Clone symbols
                     * @param {Function} [customizer] The function to customize cloning.
                     * @param {string} [key] The key of `value`.
                     * @param {Object} [object] The parent object of `value`.
                     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
                     * @returns {*} Returns the cloned value.
                     */

                    function baseClone(
                        value,
                        bitmask,
                        customizer,
                        key,
                        object,
                        stack
                    ) {
                        var result,
                            isDeep = bitmask & CLONE_DEEP_FLAG,
                            isFlat = bitmask & CLONE_FLAT_FLAG,
                            isFull = bitmask & CLONE_SYMBOLS_FLAG;

                        if (customizer) {
                            result = object
                                ? customizer(value, key, object, stack)
                                : customizer(value);
                        }

                        if (result !== undefined) {
                            return result;
                        }

                        if (!isObject(value)) {
                            return value;
                        }

                        var isArr = isArray(value);

                        if (isArr) {
                            result = initCloneArray(value);

                            if (!isDeep) {
                                return copyArray(value, result);
                            }
                        } else {
                            var tag = getTag(value),
                                isFunc = tag == funcTag || tag == genTag;

                            if (isBuffer(value)) {
                                return cloneBuffer(value, isDeep);
                            }

                            if (
                                tag == objectTag ||
                                tag == argsTag ||
                                (isFunc && !object)
                            ) {
                                result =
                                    isFlat || isFunc
                                        ? {}
                                        : initCloneObject(value);

                                if (!isDeep) {
                                    return isFlat
                                        ? copySymbolsIn(
                                              value,
                                              baseAssignIn(result, value)
                                          )
                                        : copySymbols(
                                              value,
                                              baseAssign(result, value)
                                          );
                                }
                            } else {
                                if (!cloneableTags[tag]) {
                                    return object ? value : {};
                                }

                                result = initCloneByTag(value, tag, isDeep);
                            }
                        } // Check for circular references and return its corresponding clone.

                        stack || (stack = new Stack());
                        var stacked = stack.get(value);

                        if (stacked) {
                            return stacked;
                        }

                        stack.set(value, result);

                        if (isSet(value)) {
                            value.forEach(function (subValue) {
                                result.add(
                                    baseClone(
                                        subValue,
                                        bitmask,
                                        customizer,
                                        subValue,
                                        value,
                                        stack
                                    )
                                );
                            });
                        } else if (isMap(value)) {
                            value.forEach(function (subValue, key) {
                                result.set(
                                    key,
                                    baseClone(
                                        subValue,
                                        bitmask,
                                        customizer,
                                        key,
                                        value,
                                        stack
                                    )
                                );
                            });
                        }

                        var keysFunc = isFull
                            ? isFlat
                                ? getAllKeysIn
                                : getAllKeys
                            : isFlat
                            ? keysIn
                            : keys;
                        var props = isArr ? undefined : keysFunc(value);
                        arrayEach(props || value, function (subValue, key) {
                            if (props) {
                                key = subValue;
                                subValue = value[key];
                            } // Recursively populate clone (susceptible to call stack limits).

                            assignValue(
                                result,
                                key,
                                baseClone(
                                    subValue,
                                    bitmask,
                                    customizer,
                                    key,
                                    value,
                                    stack
                                )
                            );
                        });
                        return result;
                    }

                    module.exports = baseClone;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseCreate.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isObject = __webpack_require__(
                        /*! ./isObject */ "./node_modules/lodash/isObject.js"
                    );
                    /** Built-in value references. */

                    var objectCreate = Object.create;
                    /**
                     * The base implementation of `_.create` without support for assigning
                     * properties to the created object.
                     *
                     * @private
                     * @param {Object} proto The object to inherit from.
                     * @returns {Object} Returns the new object.
                     */

                    var baseCreate = (function () {
                        function object() {}

                        return function (proto) {
                            if (!isObject(proto)) {
                                return {};
                            }

                            if (objectCreate) {
                                return objectCreate(proto);
                            }

                            object.prototype = proto;
                            var result = new object();
                            object.prototype = undefined;
                            return result;
                        };
                    })();

                    module.exports = baseCreate;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseFlatten.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayPush = __webpack_require__(
                            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
                        ),
                        isFlattenable = __webpack_require__(
                            /*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js"
                        );
                    /**
                     * The base implementation of `_.flatten` with support for restricting flattening.
                     *
                     * @private
                     * @param {Array} array The array to flatten.
                     * @param {number} depth The maximum recursion depth.
                     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
                     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
                     * @param {Array} [result=[]] The initial result value.
                     * @returns {Array} Returns the new flattened array.
                     */

                    function baseFlatten(
                        array,
                        depth,
                        predicate,
                        isStrict,
                        result
                    ) {
                        var index = -1,
                            length = array.length;
                        predicate || (predicate = isFlattenable);
                        result || (result = []);

                        while (++index < length) {
                            var value = array[index];

                            if (depth > 0 && predicate(value)) {
                                if (depth > 1) {
                                    // Recursively flatten arrays (susceptible to call stack limits).
                                    baseFlatten(
                                        value,
                                        depth - 1,
                                        predicate,
                                        isStrict,
                                        result
                                    );
                                } else {
                                    arrayPush(result, value);
                                }
                            } else if (!isStrict) {
                                result[result.length] = value;
                            }
                        }

                        return result;
                    }

                    module.exports = baseFlatten;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseGet.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var castPath = __webpack_require__(
                            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
                        ),
                        toKey = __webpack_require__(
                            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
                        );
                    /**
                     * The base implementation of `_.get` without support for default values.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array|string} path The path of the property to get.
                     * @returns {*} Returns the resolved value.
                     */

                    function baseGet(object, path) {
                        path = castPath(path, object);
                        var index = 0,
                            length = path.length;

                        while (object != null && index < length) {
                            object = object[toKey(path[index++])];
                        }

                        return index && index == length ? object : undefined;
                    }

                    module.exports = baseGet;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseGetAllKeys.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayPush = __webpack_require__(
                            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
                        ),
                        isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        );
                    /**
                     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
                     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
                     * symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Function} keysFunc The function to get the keys of `object`.
                     * @param {Function} symbolsFunc The function to get the symbols of `object`.
                     * @returns {Array} Returns the array of property names and symbols.
                     */

                    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                        var result = keysFunc(object);
                        return isArray(object)
                            ? result
                            : arrayPush(result, symbolsFunc(object));
                    }

                    module.exports = baseGetAllKeys;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseGetTag.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Symbol = __webpack_require__(
                            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
                        ),
                        getRawTag = __webpack_require__(
                            /*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"
                        ),
                        objectToString = __webpack_require__(
                            /*! ./_objectToString */ "./node_modules/lodash/_objectToString.js"
                        );
                    /** `Object#toString` result references. */

                    var nullTag = "[object Null]",
                        undefinedTag = "[object Undefined]";
                    /** Built-in value references. */

                    var symToStringTag = Symbol
                        ? Symbol.toStringTag
                        : undefined;
                    /**
                     * The base implementation of `getTag` without fallbacks for buggy environments.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the `toStringTag`.
                     */

                    function baseGetTag(value) {
                        if (value == null) {
                            return value === undefined ? undefinedTag : nullTag;
                        }

                        return symToStringTag && symToStringTag in Object(value)
                            ? getRawTag(value)
                            : objectToString(value);
                    }

                    module.exports = baseGetTag;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseIsArguments.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var argsTag = "[object Arguments]";
                    /**
                     * The base implementation of `_.isArguments`.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                     */

                    function baseIsArguments(value) {
                        return (
                            isObjectLike(value) && baseGetTag(value) == argsTag
                        );
                    }

                    module.exports = baseIsArguments;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseIsMap.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getTag = __webpack_require__(
                            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var mapTag = "[object Map]";
                    /**
                     * The base implementation of `_.isMap` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                     */

                    function baseIsMap(value) {
                        return isObjectLike(value) && getTag(value) == mapTag;
                    }

                    module.exports = baseIsMap;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseIsNative.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isFunction = __webpack_require__(
                            /*! ./isFunction */ "./node_modules/lodash/isFunction.js"
                        ),
                        isMasked = __webpack_require__(
                            /*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"
                        ),
                        isObject = __webpack_require__(
                            /*! ./isObject */ "./node_modules/lodash/isObject.js"
                        ),
                        toSource = __webpack_require__(
                            /*! ./_toSource */ "./node_modules/lodash/_toSource.js"
                        );
                    /**
                     * Used to match `RegExp`
                     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
                     */

                    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
                    /** Used to detect host constructors (Safari). */

                    var reIsHostCtor = /^\[object .+?Constructor\]$/;
                    /** Used for built-in method references. */

                    var funcProto = Function.prototype,
                        objectProto = Object.prototype;
                    /** Used to resolve the decompiled source of functions. */

                    var funcToString = funcProto.toString;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /** Used to detect if a method is native. */

                    var reIsNative = RegExp(
                        "^" +
                            funcToString
                                .call(hasOwnProperty)
                                .replace(reRegExpChar, "\\$&")
                                .replace(
                                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                                    "$1.*?"
                                ) +
                            "$"
                    );
                    /**
                     * The base implementation of `_.isNative` without bad shim checks.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a native function,
                     *  else `false`.
                     */

                    function baseIsNative(value) {
                        if (!isObject(value) || isMasked(value)) {
                            return false;
                        }

                        var pattern = isFunction(value)
                            ? reIsNative
                            : reIsHostCtor;
                        return pattern.test(toSource(value));
                    }

                    module.exports = baseIsNative;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseIsSet.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getTag = __webpack_require__(
                            /*! ./_getTag */ "./node_modules/lodash/_getTag.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var setTag = "[object Set]";
                    /**
                     * The base implementation of `_.isSet` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                     */

                    function baseIsSet(value) {
                        return isObjectLike(value) && getTag(value) == setTag;
                    }

                    module.exports = baseIsSet;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseIsTypedArray.js":
                /*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        isLength = __webpack_require__(
                            /*! ./isLength */ "./node_modules/lodash/isLength.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var argsTag = "[object Arguments]",
                        arrayTag = "[object Array]",
                        boolTag = "[object Boolean]",
                        dateTag = "[object Date]",
                        errorTag = "[object Error]",
                        funcTag = "[object Function]",
                        mapTag = "[object Map]",
                        numberTag = "[object Number]",
                        objectTag = "[object Object]",
                        regexpTag = "[object RegExp]",
                        setTag = "[object Set]",
                        stringTag = "[object String]",
                        weakMapTag = "[object WeakMap]";
                    var arrayBufferTag = "[object ArrayBuffer]",
                        dataViewTag = "[object DataView]",
                        float32Tag = "[object Float32Array]",
                        float64Tag = "[object Float64Array]",
                        int8Tag = "[object Int8Array]",
                        int16Tag = "[object Int16Array]",
                        int32Tag = "[object Int32Array]",
                        uint8Tag = "[object Uint8Array]",
                        uint8ClampedTag = "[object Uint8ClampedArray]",
                        uint16Tag = "[object Uint16Array]",
                        uint32Tag = "[object Uint32Array]";
                    /** Used to identify `toStringTag` values of typed arrays. */

                    var typedArrayTags = {};
                    typedArrayTags[float32Tag] = typedArrayTags[
                        float64Tag
                    ] = typedArrayTags[int8Tag] = typedArrayTags[
                        int16Tag
                    ] = typedArrayTags[int32Tag] = typedArrayTags[
                        uint8Tag
                    ] = typedArrayTags[uint8ClampedTag] = typedArrayTags[
                        uint16Tag
                    ] = typedArrayTags[uint32Tag] = true;
                    typedArrayTags[argsTag] = typedArrayTags[
                        arrayTag
                    ] = typedArrayTags[arrayBufferTag] = typedArrayTags[
                        boolTag
                    ] = typedArrayTags[dataViewTag] = typedArrayTags[
                        dateTag
                    ] = typedArrayTags[errorTag] = typedArrayTags[
                        funcTag
                    ] = typedArrayTags[mapTag] = typedArrayTags[
                        numberTag
                    ] = typedArrayTags[objectTag] = typedArrayTags[
                        regexpTag
                    ] = typedArrayTags[setTag] = typedArrayTags[
                        stringTag
                    ] = typedArrayTags[weakMapTag] = false;
                    /**
                     * The base implementation of `_.isTypedArray` without Node.js optimizations.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                     */

                    function baseIsTypedArray(value) {
                        return (
                            isObjectLike(value) &&
                            isLength(value.length) &&
                            !!typedArrayTags[baseGetTag(value)]
                        );
                    }

                    module.exports = baseIsTypedArray;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseKeys.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isPrototype = __webpack_require__(
                            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
                        ),
                        nativeKeys = __webpack_require__(
                            /*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */

                    function baseKeys(object) {
                        if (!isPrototype(object)) {
                            return nativeKeys(object);
                        }

                        var result = [];

                        for (var key in Object(object)) {
                            if (
                                hasOwnProperty.call(object, key) &&
                                key != "constructor"
                            ) {
                                result.push(key);
                            }
                        }

                        return result;
                    }

                    module.exports = baseKeys;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseKeysIn.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isObject = __webpack_require__(
                            /*! ./isObject */ "./node_modules/lodash/isObject.js"
                        ),
                        isPrototype = __webpack_require__(
                            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
                        ),
                        nativeKeysIn = __webpack_require__(
                            /*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */

                    function baseKeysIn(object) {
                        if (!isObject(object)) {
                            return nativeKeysIn(object);
                        }

                        var isProto = isPrototype(object),
                            result = [];

                        for (var key in object) {
                            if (
                                !(
                                    key == "constructor" &&
                                    (isProto ||
                                        !hasOwnProperty.call(object, key))
                                )
                            ) {
                                result.push(key);
                            }
                        }

                        return result;
                    }

                    module.exports = baseKeysIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseSetToString.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var constant = __webpack_require__(
                            /*! ./constant */ "./node_modules/lodash/constant.js"
                        ),
                        defineProperty = __webpack_require__(
                            /*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"
                        ),
                        identity = __webpack_require__(
                            /*! ./identity */ "./node_modules/lodash/identity.js"
                        );
                    /**
                     * The base implementation of `setToString` without support for hot loop shorting.
                     *
                     * @private
                     * @param {Function} func The function to modify.
                     * @param {Function} string The `toString` result.
                     * @returns {Function} Returns `func`.
                     */

                    var baseSetToString = !defineProperty
                        ? identity
                        : function (func, string) {
                              return defineProperty(func, "toString", {
                                  configurable: true,
                                  enumerable: false,
                                  value: constant(string),
                                  writable: true,
                              });
                          };
                    module.exports = baseSetToString;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseSlice.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseSlice.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * The base implementation of `_.slice` without an iteratee call guard.
                     *
                     * @private
                     * @param {Array} array The array to slice.
                     * @param {number} [start=0] The start position.
                     * @param {number} [end=array.length] The end position.
                     * @returns {Array} Returns the slice of `array`.
                     */
                    function baseSlice(array, start, end) {
                        var index = -1,
                            length = array.length;

                        if (start < 0) {
                            start = -start > length ? 0 : length + start;
                        }

                        end = end > length ? length : end;

                        if (end < 0) {
                            end += length;
                        }

                        length = start > end ? 0 : (end - start) >>> 0;
                        start >>>= 0;
                        var result = Array(length);

                        while (++index < length) {
                            result[index] = array[index + start];
                        }

                        return result;
                    }

                    module.exports = baseSlice;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseTimes.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * The base implementation of `_.times` without support for iteratee shorthands
                     * or max array length checks.
                     *
                     * @private
                     * @param {number} n The number of times to invoke `iteratee`.
                     * @param {Function} iteratee The function invoked per iteration.
                     * @returns {Array} Returns the array of results.
                     */
                    function baseTimes(n, iteratee) {
                        var index = -1,
                            result = Array(n);

                        while (++index < n) {
                            result[index] = iteratee(index);
                        }

                        return result;
                    }

                    module.exports = baseTimes;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseToString.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Symbol = __webpack_require__(
                            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
                        ),
                        arrayMap = __webpack_require__(
                            /*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"
                        ),
                        isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        ),
                        isSymbol = __webpack_require__(
                            /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
                        );
                    /** Used as references for various `Number` constants. */

                    var INFINITY = 1 / 0;
                    /** Used to convert symbols to primitives and strings. */

                    var symbolProto = Symbol ? Symbol.prototype : undefined,
                        symbolToString = symbolProto
                            ? symbolProto.toString
                            : undefined;
                    /**
                     * The base implementation of `_.toString` which doesn't convert nullish
                     * values to empty strings.
                     *
                     * @private
                     * @param {*} value The value to process.
                     * @returns {string} Returns the string.
                     */

                    function baseToString(value) {
                        // Exit early for strings to avoid a performance hit in some environments.
                        if (typeof value == "string") {
                            return value;
                        }

                        if (isArray(value)) {
                            // Recursively convert values (susceptible to call stack limits).
                            return arrayMap(value, baseToString) + "";
                        }

                        if (isSymbol(value)) {
                            return symbolToString
                                ? symbolToString.call(value)
                                : "";
                        }

                        var result = value + "";
                        return result == "0" && 1 / value == -INFINITY
                            ? "-0"
                            : result;
                    }

                    module.exports = baseToString;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseUnary.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * The base implementation of `_.unary` without support for storing metadata.
                     *
                     * @private
                     * @param {Function} func The function to cap arguments for.
                     * @returns {Function} Returns the new capped function.
                     */
                    function baseUnary(func) {
                        return function (value) {
                            return func(value);
                        };
                    }

                    module.exports = baseUnary;

                    /***/
                },

            /***/ "./node_modules/lodash/_baseUnset.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnset.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var castPath = __webpack_require__(
                            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
                        ),
                        last = __webpack_require__(
                            /*! ./last */ "./node_modules/lodash/last.js"
                        ),
                        parent = __webpack_require__(
                            /*! ./_parent */ "./node_modules/lodash/_parent.js"
                        ),
                        toKey = __webpack_require__(
                            /*! ./_toKey */ "./node_modules/lodash/_toKey.js"
                        );
                    /**
                     * The base implementation of `_.unset`.
                     *
                     * @private
                     * @param {Object} object The object to modify.
                     * @param {Array|string} path The property path to unset.
                     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
                     */

                    function baseUnset(object, path) {
                        path = castPath(path, object);
                        object = parent(object, path);
                        return (
                            object == null || delete object[toKey(last(path))]
                        );
                    }

                    module.exports = baseUnset;

                    /***/
                },

            /***/ "./node_modules/lodash/_castPath.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        ),
                        isKey = __webpack_require__(
                            /*! ./_isKey */ "./node_modules/lodash/_isKey.js"
                        ),
                        stringToPath = __webpack_require__(
                            /*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"
                        ),
                        toString = __webpack_require__(
                            /*! ./toString */ "./node_modules/lodash/toString.js"
                        );
                    /**
                     * Casts `value` to a path array if it's not one.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {Array} Returns the cast property path array.
                     */

                    function castPath(value, object) {
                        if (isArray(value)) {
                            return value;
                        }

                        return isKey(value, object)
                            ? [value]
                            : stringToPath(toString(value));
                    }

                    module.exports = castPath;

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneArrayBuffer.js":
                /*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Uint8Array = __webpack_require__(
                        /*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"
                    );
                    /**
                     * Creates a clone of `arrayBuffer`.
                     *
                     * @private
                     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
                     * @returns {ArrayBuffer} Returns the cloned array buffer.
                     */

                    function cloneArrayBuffer(arrayBuffer) {
                        var result = new arrayBuffer.constructor(
                            arrayBuffer.byteLength
                        );
                        new Uint8Array(result).set(new Uint8Array(arrayBuffer));
                        return result;
                    }

                    module.exports = cloneArrayBuffer;

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneBuffer.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (module) {
                        var root = __webpack_require__(
                            /*! ./_root */ "./node_modules/lodash/_root.js"
                        );
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined,
                            allocUnsafe = Buffer
                                ? Buffer.allocUnsafe
                                : undefined;
                        /**
                         * Creates a clone of  `buffer`.
                         *
                         * @private
                         * @param {Buffer} buffer The buffer to clone.
                         * @param {boolean} [isDeep] Specify a deep clone.
                         * @returns {Buffer} Returns the cloned buffer.
                         */

                        function cloneBuffer(buffer, isDeep) {
                            if (isDeep) {
                                return buffer.slice();
                            }

                            var length = buffer.length,
                                result = allocUnsafe
                                    ? allocUnsafe(length)
                                    : new buffer.constructor(length);
                            buffer.copy(result);
                            return result;
                        }

                        module.exports = cloneBuffer;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneDataView.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var cloneArrayBuffer = __webpack_require__(
                        /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
                    );
                    /**
                     * Creates a clone of `dataView`.
                     *
                     * @private
                     * @param {Object} dataView The data view to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the cloned data view.
                     */

                    function cloneDataView(dataView, isDeep) {
                        var buffer = isDeep
                            ? cloneArrayBuffer(dataView.buffer)
                            : dataView.buffer;
                        return new dataView.constructor(
                            buffer,
                            dataView.byteOffset,
                            dataView.byteLength
                        );
                    }

                    module.exports = cloneDataView;

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneRegExp.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used to match `RegExp` flags from their coerced string values. */
                    var reFlags = /\w*$/;
                    /**
                     * Creates a clone of `regexp`.
                     *
                     * @private
                     * @param {Object} regexp The regexp to clone.
                     * @returns {Object} Returns the cloned regexp.
                     */

                    function cloneRegExp(regexp) {
                        var result = new regexp.constructor(
                            regexp.source,
                            reFlags.exec(regexp)
                        );
                        result.lastIndex = regexp.lastIndex;
                        return result;
                    }

                    module.exports = cloneRegExp;

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneSymbol.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Symbol = __webpack_require__(
                        /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
                    );
                    /** Used to convert symbols to primitives and strings. */

                    var symbolProto = Symbol ? Symbol.prototype : undefined,
                        symbolValueOf = symbolProto
                            ? symbolProto.valueOf
                            : undefined;
                    /**
                     * Creates a clone of the `symbol` object.
                     *
                     * @private
                     * @param {Object} symbol The symbol object to clone.
                     * @returns {Object} Returns the cloned symbol object.
                     */

                    function cloneSymbol(symbol) {
                        return symbolValueOf
                            ? Object(symbolValueOf.call(symbol))
                            : {};
                    }

                    module.exports = cloneSymbol;

                    /***/
                },

            /***/ "./node_modules/lodash/_cloneTypedArray.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var cloneArrayBuffer = __webpack_require__(
                        /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
                    );
                    /**
                     * Creates a clone of `typedArray`.
                     *
                     * @private
                     * @param {Object} typedArray The typed array to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the cloned typed array.
                     */

                    function cloneTypedArray(typedArray, isDeep) {
                        var buffer = isDeep
                            ? cloneArrayBuffer(typedArray.buffer)
                            : typedArray.buffer;
                        return new typedArray.constructor(
                            buffer,
                            typedArray.byteOffset,
                            typedArray.length
                        );
                    }

                    module.exports = cloneTypedArray;

                    /***/
                },

            /***/ "./node_modules/lodash/_copyArray.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Copies the values of `source` to `array`.
                     *
                     * @private
                     * @param {Array} source The array to copy values from.
                     * @param {Array} [array=[]] The array to copy values to.
                     * @returns {Array} Returns `array`.
                     */
                    function copyArray(source, array) {
                        var index = -1,
                            length = source.length;
                        array || (array = Array(length));

                        while (++index < length) {
                            array[index] = source[index];
                        }

                        return array;
                    }

                    module.exports = copyArray;

                    /***/
                },

            /***/ "./node_modules/lodash/_copyObject.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var assignValue = __webpack_require__(
                            /*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"
                        ),
                        baseAssignValue = __webpack_require__(
                            /*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"
                        );
                    /**
                     * Copies properties of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy properties from.
                     * @param {Array} props The property identifiers to copy.
                     * @param {Object} [object={}] The object to copy properties to.
                     * @param {Function} [customizer] The function to customize copied values.
                     * @returns {Object} Returns `object`.
                     */

                    function copyObject(source, props, object, customizer) {
                        var isNew = !object;
                        object || (object = {});
                        var index = -1,
                            length = props.length;

                        while (++index < length) {
                            var key = props[index];
                            var newValue = customizer
                                ? customizer(
                                      object[key],
                                      source[key],
                                      key,
                                      object,
                                      source
                                  )
                                : undefined;

                            if (newValue === undefined) {
                                newValue = source[key];
                            }

                            if (isNew) {
                                baseAssignValue(object, key, newValue);
                            } else {
                                assignValue(object, key, newValue);
                            }
                        }

                        return object;
                    }

                    module.exports = copyObject;

                    /***/
                },

            /***/ "./node_modules/lodash/_copySymbols.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var copyObject = __webpack_require__(
                            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
                        ),
                        getSymbols = __webpack_require__(
                            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
                        );
                    /**
                     * Copies own symbols of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy symbols from.
                     * @param {Object} [object={}] The object to copy symbols to.
                     * @returns {Object} Returns `object`.
                     */

                    function copySymbols(source, object) {
                        return copyObject(source, getSymbols(source), object);
                    }

                    module.exports = copySymbols;

                    /***/
                },

            /***/ "./node_modules/lodash/_copySymbolsIn.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var copyObject = __webpack_require__(
                            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
                        ),
                        getSymbolsIn = __webpack_require__(
                            /*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"
                        );
                    /**
                     * Copies own and inherited symbols of `source` to `object`.
                     *
                     * @private
                     * @param {Object} source The object to copy symbols from.
                     * @param {Object} [object={}] The object to copy symbols to.
                     * @returns {Object} Returns `object`.
                     */

                    function copySymbolsIn(source, object) {
                        return copyObject(source, getSymbolsIn(source), object);
                    }

                    module.exports = copySymbolsIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_coreJsData.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var root = __webpack_require__(
                        /*! ./_root */ "./node_modules/lodash/_root.js"
                    );
                    /** Used to detect overreaching core-js shims. */

                    var coreJsData = root["__core-js_shared__"];
                    module.exports = coreJsData;

                    /***/
                },

            /***/ "./node_modules/lodash/_customOmitClone.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_customOmitClone.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isPlainObject = __webpack_require__(
                        /*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"
                    );
                    /**
                     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
                     * objects.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @param {string} key The key of the property to inspect.
                     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
                     */

                    function customOmitClone(value) {
                        return isPlainObject(value) ? undefined : value;
                    }

                    module.exports = customOmitClone;

                    /***/
                },

            /***/ "./node_modules/lodash/_defineProperty.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                        /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                    );

                    var defineProperty = (function () {
                        try {
                            var func = getNative(Object, "defineProperty");
                            func({}, "", {});
                            return func;
                        } catch (e) {}
                    })();

                    module.exports = defineProperty;

                    /***/
                },

            /***/ "./node_modules/lodash/_flatRest.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var flatten = __webpack_require__(
                            /*! ./flatten */ "./node_modules/lodash/flatten.js"
                        ),
                        overRest = __webpack_require__(
                            /*! ./_overRest */ "./node_modules/lodash/_overRest.js"
                        ),
                        setToString = __webpack_require__(
                            /*! ./_setToString */ "./node_modules/lodash/_setToString.js"
                        );
                    /**
                     * A specialized version of `baseRest` which flattens the rest array.
                     *
                     * @private
                     * @param {Function} func The function to apply a rest parameter to.
                     * @returns {Function} Returns the new function.
                     */

                    function flatRest(func) {
                        return setToString(
                            overRest(func, undefined, flatten),
                            func + ""
                        );
                    }

                    module.exports = flatRest;

                    /***/
                },

            /***/ "./node_modules/lodash/_freeGlobal.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (global) {
                        /** Detect free variable `global` from Node.js. */
                        var freeGlobal =
                            typeof global == "object" &&
                            global &&
                            global.Object === Object &&
                            global;
                        module.exports = freeGlobal;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"
                        )
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash/_getAllKeys.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetAllKeys = __webpack_require__(
                            /*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"
                        ),
                        getSymbols = __webpack_require__(
                            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
                        ),
                        keys = __webpack_require__(
                            /*! ./keys */ "./node_modules/lodash/keys.js"
                        );
                    /**
                     * Creates an array of own enumerable property names and symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names and symbols.
                     */

                    function getAllKeys(object) {
                        return baseGetAllKeys(object, keys, getSymbols);
                    }

                    module.exports = getAllKeys;

                    /***/
                },

            /***/ "./node_modules/lodash/_getAllKeysIn.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetAllKeys = __webpack_require__(
                            /*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"
                        ),
                        getSymbolsIn = __webpack_require__(
                            /*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"
                        ),
                        keysIn = __webpack_require__(
                            /*! ./keysIn */ "./node_modules/lodash/keysIn.js"
                        );
                    /**
                     * Creates an array of own and inherited enumerable property names and
                     * symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names and symbols.
                     */

                    function getAllKeysIn(object) {
                        return baseGetAllKeys(object, keysIn, getSymbolsIn);
                    }

                    module.exports = getAllKeysIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_getMapData.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isKeyable = __webpack_require__(
                        /*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js"
                    );
                    /**
                     * Gets the data for `map`.
                     *
                     * @private
                     * @param {Object} map The map to query.
                     * @param {string} key The reference key.
                     * @returns {*} Returns the map data.
                     */

                    function getMapData(map, key) {
                        var data = map.__data__;
                        return isKeyable(key)
                            ? data[typeof key == "string" ? "string" : "hash"]
                            : data.map;
                    }

                    module.exports = getMapData;

                    /***/
                },

            /***/ "./node_modules/lodash/_getNative.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseIsNative = __webpack_require__(
                            /*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"
                        ),
                        getValue = __webpack_require__(
                            /*! ./_getValue */ "./node_modules/lodash/_getValue.js"
                        );
                    /**
                     * Gets the native function at `key` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {string} key The key of the method to get.
                     * @returns {*} Returns the function if it's native, else `undefined`.
                     */

                    function getNative(object, key) {
                        var value = getValue(object, key);
                        return baseIsNative(value) ? value : undefined;
                    }

                    module.exports = getNative;

                    /***/
                },

            /***/ "./node_modules/lodash/_getPrototype.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var overArg = __webpack_require__(
                        /*! ./_overArg */ "./node_modules/lodash/_overArg.js"
                    );
                    /** Built-in value references. */

                    var getPrototype = overArg(Object.getPrototypeOf, Object);
                    module.exports = getPrototype;

                    /***/
                },

            /***/ "./node_modules/lodash/_getRawTag.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Symbol = __webpack_require__(
                        /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
                    );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Used to resolve the
                     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                     * of values.
                     */

                    var nativeObjectToString = objectProto.toString;
                    /** Built-in value references. */

                    var symToStringTag = Symbol
                        ? Symbol.toStringTag
                        : undefined;
                    /**
                     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the raw `toStringTag`.
                     */

                    function getRawTag(value) {
                        var isOwn = hasOwnProperty.call(value, symToStringTag),
                            tag = value[symToStringTag];

                        try {
                            value[symToStringTag] = undefined;
                            var unmasked = true;
                        } catch (e) {}

                        var result = nativeObjectToString.call(value);

                        if (unmasked) {
                            if (isOwn) {
                                value[symToStringTag] = tag;
                            } else {
                                delete value[symToStringTag];
                            }
                        }

                        return result;
                    }

                    module.exports = getRawTag;

                    /***/
                },

            /***/ "./node_modules/lodash/_getSymbols.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayFilter = __webpack_require__(
                            /*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"
                        ),
                        stubArray = __webpack_require__(
                            /*! ./stubArray */ "./node_modules/lodash/stubArray.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Built-in value references. */

                    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
                    /* Built-in method references for those with the same name as other `lodash` methods. */

                    var nativeGetSymbols = Object.getOwnPropertySymbols;
                    /**
                     * Creates an array of the own enumerable symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of symbols.
                     */

                    var getSymbols = !nativeGetSymbols
                        ? stubArray
                        : function (object) {
                              if (object == null) {
                                  return [];
                              }

                              object = Object(object);
                              return arrayFilter(
                                  nativeGetSymbols(object),
                                  function (symbol) {
                                      return propertyIsEnumerable.call(
                                          object,
                                          symbol
                                      );
                                  }
                              );
                          };
                    module.exports = getSymbols;

                    /***/
                },

            /***/ "./node_modules/lodash/_getSymbolsIn.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayPush = __webpack_require__(
                            /*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"
                        ),
                        getPrototype = __webpack_require__(
                            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
                        ),
                        getSymbols = __webpack_require__(
                            /*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"
                        ),
                        stubArray = __webpack_require__(
                            /*! ./stubArray */ "./node_modules/lodash/stubArray.js"
                        );
                    /* Built-in method references for those with the same name as other `lodash` methods. */

                    var nativeGetSymbols = Object.getOwnPropertySymbols;
                    /**
                     * Creates an array of the own and inherited enumerable symbols of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of symbols.
                     */

                    var getSymbolsIn = !nativeGetSymbols
                        ? stubArray
                        : function (object) {
                              var result = [];

                              while (object) {
                                  arrayPush(result, getSymbols(object));
                                  object = getPrototype(object);
                              }

                              return result;
                          };
                    module.exports = getSymbolsIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_getTag.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var DataView = __webpack_require__(
                            /*! ./_DataView */ "./node_modules/lodash/_DataView.js"
                        ),
                        Map = __webpack_require__(
                            /*! ./_Map */ "./node_modules/lodash/_Map.js"
                        ),
                        Promise = __webpack_require__(
                            /*! ./_Promise */ "./node_modules/lodash/_Promise.js"
                        ),
                        Set = __webpack_require__(
                            /*! ./_Set */ "./node_modules/lodash/_Set.js"
                        ),
                        WeakMap = __webpack_require__(
                            /*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"
                        ),
                        baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        toSource = __webpack_require__(
                            /*! ./_toSource */ "./node_modules/lodash/_toSource.js"
                        );
                    /** `Object#toString` result references. */

                    var mapTag = "[object Map]",
                        objectTag = "[object Object]",
                        promiseTag = "[object Promise]",
                        setTag = "[object Set]",
                        weakMapTag = "[object WeakMap]";
                    var dataViewTag = "[object DataView]";
                    /** Used to detect maps, sets, and weakmaps. */

                    var dataViewCtorString = toSource(DataView),
                        mapCtorString = toSource(Map),
                        promiseCtorString = toSource(Promise),
                        setCtorString = toSource(Set),
                        weakMapCtorString = toSource(WeakMap);
                    /**
                     * Gets the `toStringTag` of `value`.
                     *
                     * @private
                     * @param {*} value The value to query.
                     * @returns {string} Returns the `toStringTag`.
                     */

                    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.

                    if (
                        (DataView &&
                            getTag(new DataView(new ArrayBuffer(1))) !=
                                dataViewTag) ||
                        (Map && getTag(new Map()) != mapTag) ||
                        (Promise && getTag(Promise.resolve()) != promiseTag) ||
                        (Set && getTag(new Set()) != setTag) ||
                        (WeakMap && getTag(new WeakMap()) != weakMapTag)
                    ) {
                        getTag = function (value) {
                            var result = baseGetTag(value),
                                Ctor =
                                    result == objectTag
                                        ? value.constructor
                                        : undefined,
                                ctorString = Ctor ? toSource(Ctor) : "";

                            if (ctorString) {
                                switch (ctorString) {
                                    case dataViewCtorString:
                                        return dataViewTag;

                                    case mapCtorString:
                                        return mapTag;

                                    case promiseCtorString:
                                        return promiseTag;

                                    case setCtorString:
                                        return setTag;

                                    case weakMapCtorString:
                                        return weakMapTag;
                                }
                            }

                            return result;
                        };
                    }

                    module.exports = getTag;

                    /***/
                },

            /***/ "./node_modules/lodash/_getValue.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Gets the value at `key` of `object`.
                     *
                     * @private
                     * @param {Object} [object] The object to query.
                     * @param {string} key The key of the property to get.
                     * @returns {*} Returns the property value.
                     */
                    function getValue(object, key) {
                        return object == null ? undefined : object[key];
                    }

                    module.exports = getValue;

                    /***/
                },

            /***/ "./node_modules/lodash/_hashClear.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var nativeCreate = __webpack_require__(
                        /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
                    );
                    /**
                     * Removes all key-value entries from the hash.
                     *
                     * @private
                     * @name clear
                     * @memberOf Hash
                     */

                    function hashClear() {
                        this.__data__ = nativeCreate ? nativeCreate(null) : {};
                        this.size = 0;
                    }

                    module.exports = hashClear;

                    /***/
                },

            /***/ "./node_modules/lodash/_hashDelete.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Removes `key` and its value from the hash.
                     *
                     * @private
                     * @name delete
                     * @memberOf Hash
                     * @param {Object} hash The hash to modify.
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */
                    function hashDelete(key) {
                        var result = this.has(key) && delete this.__data__[key];
                        this.size -= result ? 1 : 0;
                        return result;
                    }

                    module.exports = hashDelete;

                    /***/
                },

            /***/ "./node_modules/lodash/_hashGet.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var nativeCreate = __webpack_require__(
                        /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
                    );
                    /** Used to stand-in for `undefined` hash values. */

                    var HASH_UNDEFINED = "__lodash_hash_undefined__";
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Gets the hash value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf Hash
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */

                    function hashGet(key) {
                        var data = this.__data__;

                        if (nativeCreate) {
                            var result = data[key];
                            return result === HASH_UNDEFINED
                                ? undefined
                                : result;
                        }

                        return hasOwnProperty.call(data, key)
                            ? data[key]
                            : undefined;
                    }

                    module.exports = hashGet;

                    /***/
                },

            /***/ "./node_modules/lodash/_hashHas.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var nativeCreate = __webpack_require__(
                        /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
                    );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Checks if a hash value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf Hash
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */

                    function hashHas(key) {
                        var data = this.__data__;
                        return nativeCreate
                            ? data[key] !== undefined
                            : hasOwnProperty.call(data, key);
                    }

                    module.exports = hashHas;

                    /***/
                },

            /***/ "./node_modules/lodash/_hashSet.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var nativeCreate = __webpack_require__(
                        /*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js"
                    );
                    /** Used to stand-in for `undefined` hash values. */

                    var HASH_UNDEFINED = "__lodash_hash_undefined__";
                    /**
                     * Sets the hash `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf Hash
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the hash instance.
                     */

                    function hashSet(key, value) {
                        var data = this.__data__;
                        this.size += this.has(key) ? 0 : 1;
                        data[key] =
                            nativeCreate && value === undefined
                                ? HASH_UNDEFINED
                                : value;
                        return this;
                    }

                    module.exports = hashSet;

                    /***/
                },

            /***/ "./node_modules/lodash/_initCloneArray.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used for built-in method references. */
                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /**
                     * Initializes an array clone.
                     *
                     * @private
                     * @param {Array} array The array to clone.
                     * @returns {Array} Returns the initialized clone.
                     */

                    function initCloneArray(array) {
                        var length = array.length,
                            result = new array.constructor(length); // Add properties assigned by `RegExp#exec`.

                        if (
                            length &&
                            typeof array[0] == "string" &&
                            hasOwnProperty.call(array, "index")
                        ) {
                            result.index = array.index;
                            result.input = array.input;
                        }

                        return result;
                    }

                    module.exports = initCloneArray;

                    /***/
                },

            /***/ "./node_modules/lodash/_initCloneByTag.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var cloneArrayBuffer = __webpack_require__(
                            /*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"
                        ),
                        cloneDataView = __webpack_require__(
                            /*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"
                        ),
                        cloneRegExp = __webpack_require__(
                            /*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"
                        ),
                        cloneSymbol = __webpack_require__(
                            /*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"
                        ),
                        cloneTypedArray = __webpack_require__(
                            /*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"
                        );
                    /** `Object#toString` result references. */

                    var boolTag = "[object Boolean]",
                        dateTag = "[object Date]",
                        mapTag = "[object Map]",
                        numberTag = "[object Number]",
                        regexpTag = "[object RegExp]",
                        setTag = "[object Set]",
                        stringTag = "[object String]",
                        symbolTag = "[object Symbol]";
                    var arrayBufferTag = "[object ArrayBuffer]",
                        dataViewTag = "[object DataView]",
                        float32Tag = "[object Float32Array]",
                        float64Tag = "[object Float64Array]",
                        int8Tag = "[object Int8Array]",
                        int16Tag = "[object Int16Array]",
                        int32Tag = "[object Int32Array]",
                        uint8Tag = "[object Uint8Array]",
                        uint8ClampedTag = "[object Uint8ClampedArray]",
                        uint16Tag = "[object Uint16Array]",
                        uint32Tag = "[object Uint32Array]";
                    /**
                     * Initializes an object clone based on its `toStringTag`.
                     *
                     * **Note:** This function only supports cloning values with tags of
                     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @param {string} tag The `toStringTag` of the object to clone.
                     * @param {boolean} [isDeep] Specify a deep clone.
                     * @returns {Object} Returns the initialized clone.
                     */

                    function initCloneByTag(object, tag, isDeep) {
                        var Ctor = object.constructor;

                        switch (tag) {
                            case arrayBufferTag:
                                return cloneArrayBuffer(object);

                            case boolTag:
                            case dateTag:
                                return new Ctor(+object);

                            case dataViewTag:
                                return cloneDataView(object, isDeep);

                            case float32Tag:
                            case float64Tag:
                            case int8Tag:
                            case int16Tag:
                            case int32Tag:
                            case uint8Tag:
                            case uint8ClampedTag:
                            case uint16Tag:
                            case uint32Tag:
                                return cloneTypedArray(object, isDeep);

                            case mapTag:
                                return new Ctor();

                            case numberTag:
                            case stringTag:
                                return new Ctor(object);

                            case regexpTag:
                                return cloneRegExp(object);

                            case setTag:
                                return new Ctor();

                            case symbolTag:
                                return cloneSymbol(object);
                        }
                    }

                    module.exports = initCloneByTag;

                    /***/
                },

            /***/ "./node_modules/lodash/_initCloneObject.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseCreate = __webpack_require__(
                            /*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"
                        ),
                        getPrototype = __webpack_require__(
                            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
                        ),
                        isPrototype = __webpack_require__(
                            /*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"
                        );
                    /**
                     * Initializes an object clone.
                     *
                     * @private
                     * @param {Object} object The object to clone.
                     * @returns {Object} Returns the initialized clone.
                     */

                    function initCloneObject(object) {
                        return typeof object.constructor == "function" &&
                            !isPrototype(object)
                            ? baseCreate(getPrototype(object))
                            : {};
                    }

                    module.exports = initCloneObject;

                    /***/
                },

            /***/ "./node_modules/lodash/_isFlattenable.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Symbol = __webpack_require__(
                            /*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"
                        ),
                        isArguments = __webpack_require__(
                            /*! ./isArguments */ "./node_modules/lodash/isArguments.js"
                        ),
                        isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        );
                    /** Built-in value references. */

                    var spreadableSymbol = Symbol
                        ? Symbol.isConcatSpreadable
                        : undefined;
                    /**
                     * Checks if `value` is a flattenable `arguments` object or array.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
                     */

                    function isFlattenable(value) {
                        return (
                            isArray(value) ||
                            isArguments(value) ||
                            !!(
                                spreadableSymbol &&
                                value &&
                                value[spreadableSymbol]
                            )
                        );
                    }

                    module.exports = isFlattenable;

                    /***/
                },

            /***/ "./node_modules/lodash/_isIndex.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used as references for various `Number` constants. */
                    var MAX_SAFE_INTEGER = 9007199254740991;
                    /** Used to detect unsigned integer values. */

                    var reIsUint = /^(?:0|[1-9]\d*)$/;
                    /**
                     * Checks if `value` is a valid array-like index.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
                     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
                     */

                    function isIndex(value, length) {
                        var type = typeof value;
                        length = length == null ? MAX_SAFE_INTEGER : length;
                        return (
                            !!length &&
                            (type == "number" ||
                                (type != "symbol" && reIsUint.test(value))) &&
                            value > -1 &&
                            value % 1 == 0 &&
                            value < length
                        );
                    }

                    module.exports = isIndex;

                    /***/
                },

            /***/ "./node_modules/lodash/_isKey.js":
                /*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isArray = __webpack_require__(
                            /*! ./isArray */ "./node_modules/lodash/isArray.js"
                        ),
                        isSymbol = __webpack_require__(
                            /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
                        );
                    /** Used to match property names within property paths. */

                    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                        reIsPlainProp = /^\w*$/;
                    /**
                     * Checks if `value` is a property name and not a property path.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @param {Object} [object] The object to query keys on.
                     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
                     */

                    function isKey(value, object) {
                        if (isArray(value)) {
                            return false;
                        }

                        var type = typeof value;

                        if (
                            type == "number" ||
                            type == "symbol" ||
                            type == "boolean" ||
                            value == null ||
                            isSymbol(value)
                        ) {
                            return true;
                        }

                        return (
                            reIsPlainProp.test(value) ||
                            !reIsDeepProp.test(value) ||
                            (object != null && value in Object(object))
                        );
                    }

                    module.exports = isKey;

                    /***/
                },

            /***/ "./node_modules/lodash/_isKeyable.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Checks if `value` is suitable for use as unique object key.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
                     */
                    function isKeyable(value) {
                        var type = typeof value;
                        return type == "string" ||
                            type == "number" ||
                            type == "symbol" ||
                            type == "boolean"
                            ? value !== "__proto__"
                            : value === null;
                    }

                    module.exports = isKeyable;

                    /***/
                },

            /***/ "./node_modules/lodash/_isMasked.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var coreJsData = __webpack_require__(
                        /*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js"
                    );
                    /** Used to detect methods masquerading as native. */

                    var maskSrcKey = (function () {
                        var uid = /[^.]+$/.exec(
                            (coreJsData &&
                                coreJsData.keys &&
                                coreJsData.keys.IE_PROTO) ||
                                ""
                        );
                        return uid ? "Symbol(src)_1." + uid : "";
                    })();
                    /**
                     * Checks if `func` has its source masked.
                     *
                     * @private
                     * @param {Function} func The function to check.
                     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
                     */

                    function isMasked(func) {
                        return !!maskSrcKey && maskSrcKey in func;
                    }

                    module.exports = isMasked;

                    /***/
                },

            /***/ "./node_modules/lodash/_isPrototype.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used for built-in method references. */
                    var objectProto = Object.prototype;
                    /**
                     * Checks if `value` is likely a prototype object.
                     *
                     * @private
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
                     */

                    function isPrototype(value) {
                        var Ctor = value && value.constructor,
                            proto =
                                (typeof Ctor == "function" && Ctor.prototype) ||
                                objectProto;
                        return value === proto;
                    }

                    module.exports = isPrototype;

                    /***/
                },

            /***/ "./node_modules/lodash/_listCacheClear.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Removes all key-value entries from the list cache.
                     *
                     * @private
                     * @name clear
                     * @memberOf ListCache
                     */
                    function listCacheClear() {
                        this.__data__ = [];
                        this.size = 0;
                    }

                    module.exports = listCacheClear;

                    /***/
                },

            /***/ "./node_modules/lodash/_listCacheDelete.js":
                /*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var assocIndexOf = __webpack_require__(
                        /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
                    );
                    /** Used for built-in method references. */

                    var arrayProto = Array.prototype;
                    /** Built-in value references. */

                    var splice = arrayProto.splice;
                    /**
                     * Removes `key` and its value from the list cache.
                     *
                     * @private
                     * @name delete
                     * @memberOf ListCache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */

                    function listCacheDelete(key) {
                        var data = this.__data__,
                            index = assocIndexOf(data, key);

                        if (index < 0) {
                            return false;
                        }

                        var lastIndex = data.length - 1;

                        if (index == lastIndex) {
                            data.pop();
                        } else {
                            splice.call(data, index, 1);
                        }

                        --this.size;
                        return true;
                    }

                    module.exports = listCacheDelete;

                    /***/
                },

            /***/ "./node_modules/lodash/_listCacheGet.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var assocIndexOf = __webpack_require__(
                        /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
                    );
                    /**
                     * Gets the list cache value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf ListCache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */

                    function listCacheGet(key) {
                        var data = this.__data__,
                            index = assocIndexOf(data, key);
                        return index < 0 ? undefined : data[index][1];
                    }

                    module.exports = listCacheGet;

                    /***/
                },

            /***/ "./node_modules/lodash/_listCacheHas.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var assocIndexOf = __webpack_require__(
                        /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
                    );
                    /**
                     * Checks if a list cache value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf ListCache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */

                    function listCacheHas(key) {
                        return assocIndexOf(this.__data__, key) > -1;
                    }

                    module.exports = listCacheHas;

                    /***/
                },

            /***/ "./node_modules/lodash/_listCacheSet.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var assocIndexOf = __webpack_require__(
                        /*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js"
                    );
                    /**
                     * Sets the list cache `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf ListCache
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the list cache instance.
                     */

                    function listCacheSet(key, value) {
                        var data = this.__data__,
                            index = assocIndexOf(data, key);

                        if (index < 0) {
                            ++this.size;
                            data.push([key, value]);
                        } else {
                            data[index][1] = value;
                        }

                        return this;
                    }

                    module.exports = listCacheSet;

                    /***/
                },

            /***/ "./node_modules/lodash/_mapCacheClear.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var Hash = __webpack_require__(
                            /*! ./_Hash */ "./node_modules/lodash/_Hash.js"
                        ),
                        ListCache = __webpack_require__(
                            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
                        ),
                        Map = __webpack_require__(
                            /*! ./_Map */ "./node_modules/lodash/_Map.js"
                        );
                    /**
                     * Removes all key-value entries from the map.
                     *
                     * @private
                     * @name clear
                     * @memberOf MapCache
                     */

                    function mapCacheClear() {
                        this.size = 0;
                        this.__data__ = {
                            hash: new Hash(),
                            map: new (Map || ListCache)(),
                            string: new Hash(),
                        };
                    }

                    module.exports = mapCacheClear;

                    /***/
                },

            /***/ "./node_modules/lodash/_mapCacheDelete.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getMapData = __webpack_require__(
                        /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
                    );
                    /**
                     * Removes `key` and its value from the map.
                     *
                     * @private
                     * @name delete
                     * @memberOf MapCache
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */

                    function mapCacheDelete(key) {
                        var result = getMapData(this, key)["delete"](key);
                        this.size -= result ? 1 : 0;
                        return result;
                    }

                    module.exports = mapCacheDelete;

                    /***/
                },

            /***/ "./node_modules/lodash/_mapCacheGet.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getMapData = __webpack_require__(
                        /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
                    );
                    /**
                     * Gets the map value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf MapCache
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */

                    function mapCacheGet(key) {
                        return getMapData(this, key).get(key);
                    }

                    module.exports = mapCacheGet;

                    /***/
                },

            /***/ "./node_modules/lodash/_mapCacheHas.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getMapData = __webpack_require__(
                        /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
                    );
                    /**
                     * Checks if a map value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf MapCache
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */

                    function mapCacheHas(key) {
                        return getMapData(this, key).has(key);
                    }

                    module.exports = mapCacheHas;

                    /***/
                },

            /***/ "./node_modules/lodash/_mapCacheSet.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getMapData = __webpack_require__(
                        /*! ./_getMapData */ "./node_modules/lodash/_getMapData.js"
                    );
                    /**
                     * Sets the map `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf MapCache
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the map cache instance.
                     */

                    function mapCacheSet(key, value) {
                        var data = getMapData(this, key),
                            size = data.size;
                        data.set(key, value);
                        this.size += data.size == size ? 0 : 1;
                        return this;
                    }

                    module.exports = mapCacheSet;

                    /***/
                },

            /***/ "./node_modules/lodash/_memoizeCapped.js":
                /*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var memoize = __webpack_require__(
                        /*! ./memoize */ "./node_modules/lodash/memoize.js"
                    );
                    /** Used as the maximum memoize cache size. */

                    var MAX_MEMOIZE_SIZE = 500;
                    /**
                     * A specialized version of `_.memoize` which clears the memoized function's
                     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
                     *
                     * @private
                     * @param {Function} func The function to have its output memoized.
                     * @returns {Function} Returns the new memoized function.
                     */

                    function memoizeCapped(func) {
                        var result = memoize(func, function (key) {
                            if (cache.size === MAX_MEMOIZE_SIZE) {
                                cache.clear();
                            }

                            return key;
                        });
                        var cache = result.cache;
                        return result;
                    }

                    module.exports = memoizeCapped;

                    /***/
                },

            /***/ "./node_modules/lodash/_nativeCreate.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var getNative = __webpack_require__(
                        /*! ./_getNative */ "./node_modules/lodash/_getNative.js"
                    );
                    /* Built-in method references that are verified to be native. */

                    var nativeCreate = getNative(Object, "create");
                    module.exports = nativeCreate;

                    /***/
                },

            /***/ "./node_modules/lodash/_nativeKeys.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var overArg = __webpack_require__(
                        /*! ./_overArg */ "./node_modules/lodash/_overArg.js"
                    );
                    /* Built-in method references for those with the same name as other `lodash` methods. */

                    var nativeKeys = overArg(Object.keys, Object);
                    module.exports = nativeKeys;

                    /***/
                },

            /***/ "./node_modules/lodash/_nativeKeysIn.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * This function is like
                     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                     * except that it includes inherited enumerable properties.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     */
                    function nativeKeysIn(object) {
                        var result = [];

                        if (object != null) {
                            for (var key in Object(object)) {
                                result.push(key);
                            }
                        }

                        return result;
                    }

                    module.exports = nativeKeysIn;

                    /***/
                },

            /***/ "./node_modules/lodash/_nodeUtil.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (module) {
                        var freeGlobal = __webpack_require__(
                            /*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js"
                        );
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /** Detect free variable `process` from Node.js. */

                        var freeProcess = moduleExports && freeGlobal.process;
                        /** Used to access faster Node.js helpers. */

                        var nodeUtil = (function () {
                            try {
                                // Use `util.types` for Node.js 10+.
                                var types =
                                    freeModule &&
                                    freeModule.require &&
                                    freeModule.require("util").types;

                                if (types) {
                                    return types;
                                } // Legacy `process.binding('util')` for Node.js < 10.

                                return (
                                    freeProcess &&
                                    freeProcess.binding &&
                                    freeProcess.binding("util")
                                );
                            } catch (e) {}
                        })();

                        module.exports = nodeUtil;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash/_objectToString.js":
                /*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used for built-in method references. */
                    var objectProto = Object.prototype;
                    /**
                     * Used to resolve the
                     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
                     * of values.
                     */

                    var nativeObjectToString = objectProto.toString;
                    /**
                     * Converts `value` to a string using `Object.prototype.toString`.
                     *
                     * @private
                     * @param {*} value The value to convert.
                     * @returns {string} Returns the converted string.
                     */

                    function objectToString(value) {
                        return nativeObjectToString.call(value);
                    }

                    module.exports = objectToString;

                    /***/
                },

            /***/ "./node_modules/lodash/_overArg.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Creates a unary function that invokes `func` with its argument transformed.
                     *
                     * @private
                     * @param {Function} func The function to wrap.
                     * @param {Function} transform The argument transform.
                     * @returns {Function} Returns the new function.
                     */
                    function overArg(func, transform) {
                        return function (arg) {
                            return func(transform(arg));
                        };
                    }

                    module.exports = overArg;

                    /***/
                },

            /***/ "./node_modules/lodash/_overRest.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var apply = __webpack_require__(
                        /*! ./_apply */ "./node_modules/lodash/_apply.js"
                    );
                    /* Built-in method references for those with the same name as other `lodash` methods. */

                    var nativeMax = Math.max;
                    /**
                     * A specialized version of `baseRest` which transforms the rest array.
                     *
                     * @private
                     * @param {Function} func The function to apply a rest parameter to.
                     * @param {number} [start=func.length-1] The start position of the rest parameter.
                     * @param {Function} transform The rest array transform.
                     * @returns {Function} Returns the new function.
                     */

                    function overRest(func, start, transform) {
                        start = nativeMax(
                            start === undefined ? func.length - 1 : start,
                            0
                        );
                        return function () {
                            var args = arguments,
                                index = -1,
                                length = nativeMax(args.length - start, 0),
                                array = Array(length);

                            while (++index < length) {
                                array[index] = args[start + index];
                            }

                            index = -1;
                            var otherArgs = Array(start + 1);

                            while (++index < start) {
                                otherArgs[index] = args[index];
                            }

                            otherArgs[start] = transform(array);
                            return apply(func, this, otherArgs);
                        };
                    }

                    module.exports = overRest;

                    /***/
                },

            /***/ "./node_modules/lodash/_parent.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/_parent.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGet = __webpack_require__(
                            /*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"
                        ),
                        baseSlice = __webpack_require__(
                            /*! ./_baseSlice */ "./node_modules/lodash/_baseSlice.js"
                        );
                    /**
                     * Gets the parent value at `path` of `object`.
                     *
                     * @private
                     * @param {Object} object The object to query.
                     * @param {Array} path The path to get the parent value of.
                     * @returns {*} Returns the parent value.
                     */

                    function parent(object, path) {
                        return path.length < 2
                            ? object
                            : baseGet(object, baseSlice(path, 0, -1));
                    }

                    module.exports = parent;

                    /***/
                },

            /***/ "./node_modules/lodash/_root.js":
                /*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var freeGlobal = __webpack_require__(
                        /*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js"
                    );
                    /** Detect free variable `self`. */

                    var freeSelf =
                        typeof self == "object" &&
                        self &&
                        self.Object === Object &&
                        self;
                    /** Used as a reference to the global object. */

                    var root =
                        freeGlobal || freeSelf || Function("return this")();
                    module.exports = root;

                    /***/
                },

            /***/ "./node_modules/lodash/_setToString.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseSetToString = __webpack_require__(
                            /*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"
                        ),
                        shortOut = __webpack_require__(
                            /*! ./_shortOut */ "./node_modules/lodash/_shortOut.js"
                        );
                    /**
                     * Sets the `toString` method of `func` to return `string`.
                     *
                     * @private
                     * @param {Function} func The function to modify.
                     * @param {Function} string The `toString` result.
                     * @returns {Function} Returns `func`.
                     */

                    var setToString = shortOut(baseSetToString);
                    module.exports = setToString;

                    /***/
                },

            /***/ "./node_modules/lodash/_shortOut.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used to detect hot functions by number of calls within a span of milliseconds. */
                    var HOT_COUNT = 800,
                        HOT_SPAN = 16;
                    /* Built-in method references for those with the same name as other `lodash` methods. */

                    var nativeNow = Date.now;
                    /**
                     * Creates a function that'll short out and invoke `identity` instead
                     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
                     * milliseconds.
                     *
                     * @private
                     * @param {Function} func The function to restrict.
                     * @returns {Function} Returns the new shortable function.
                     */

                    function shortOut(func) {
                        var count = 0,
                            lastCalled = 0;
                        return function () {
                            var stamp = nativeNow(),
                                remaining = HOT_SPAN - (stamp - lastCalled);
                            lastCalled = stamp;

                            if (remaining > 0) {
                                if (++count >= HOT_COUNT) {
                                    return arguments[0];
                                }
                            } else {
                                count = 0;
                            }

                            return func.apply(undefined, arguments);
                        };
                    }

                    module.exports = shortOut;

                    /***/
                },

            /***/ "./node_modules/lodash/_stackClear.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var ListCache = __webpack_require__(
                        /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
                    );
                    /**
                     * Removes all key-value entries from the stack.
                     *
                     * @private
                     * @name clear
                     * @memberOf Stack
                     */

                    function stackClear() {
                        this.__data__ = new ListCache();
                        this.size = 0;
                    }

                    module.exports = stackClear;

                    /***/
                },

            /***/ "./node_modules/lodash/_stackDelete.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Removes `key` and its value from the stack.
                     *
                     * @private
                     * @name delete
                     * @memberOf Stack
                     * @param {string} key The key of the value to remove.
                     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
                     */
                    function stackDelete(key) {
                        var data = this.__data__,
                            result = data["delete"](key);
                        this.size = data.size;
                        return result;
                    }

                    module.exports = stackDelete;

                    /***/
                },

            /***/ "./node_modules/lodash/_stackGet.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Gets the stack value for `key`.
                     *
                     * @private
                     * @name get
                     * @memberOf Stack
                     * @param {string} key The key of the value to get.
                     * @returns {*} Returns the entry value.
                     */
                    function stackGet(key) {
                        return this.__data__.get(key);
                    }

                    module.exports = stackGet;

                    /***/
                },

            /***/ "./node_modules/lodash/_stackHas.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Checks if a stack value for `key` exists.
                     *
                     * @private
                     * @name has
                     * @memberOf Stack
                     * @param {string} key The key of the entry to check.
                     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
                     */
                    function stackHas(key) {
                        return this.__data__.has(key);
                    }

                    module.exports = stackHas;

                    /***/
                },

            /***/ "./node_modules/lodash/_stackSet.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var ListCache = __webpack_require__(
                            /*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"
                        ),
                        Map = __webpack_require__(
                            /*! ./_Map */ "./node_modules/lodash/_Map.js"
                        ),
                        MapCache = __webpack_require__(
                            /*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"
                        );
                    /** Used as the size to enable large array optimizations. */

                    var LARGE_ARRAY_SIZE = 200;
                    /**
                     * Sets the stack `key` to `value`.
                     *
                     * @private
                     * @name set
                     * @memberOf Stack
                     * @param {string} key The key of the value to set.
                     * @param {*} value The value to set.
                     * @returns {Object} Returns the stack cache instance.
                     */

                    function stackSet(key, value) {
                        var data = this.__data__;

                        if (data instanceof ListCache) {
                            var pairs = data.__data__;

                            if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                                pairs.push([key, value]);
                                this.size = ++data.size;
                                return this;
                            }

                            data = this.__data__ = new MapCache(pairs);
                        }

                        data.set(key, value);
                        this.size = data.size;
                        return this;
                    }

                    module.exports = stackSet;

                    /***/
                },

            /***/ "./node_modules/lodash/_stringToPath.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var memoizeCapped = __webpack_require__(
                        /*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js"
                    );
                    /** Used to match property names within property paths. */

                    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
                    /** Used to match backslashes in property paths. */

                    var reEscapeChar = /\\(\\)?/g;
                    /**
                     * Converts `string` to a property path array.
                     *
                     * @private
                     * @param {string} string The string to convert.
                     * @returns {Array} Returns the property path array.
                     */

                    var stringToPath = memoizeCapped(function (string) {
                        var result = [];

                        if (
                            string.charCodeAt(0) === 46
                            /* . */
                        ) {
                            result.push("");
                        }

                        string.replace(rePropName, function (
                            match,
                            number,
                            quote,
                            subString
                        ) {
                            result.push(
                                quote
                                    ? subString.replace(reEscapeChar, "$1")
                                    : number || match
                            );
                        });
                        return result;
                    });
                    module.exports = stringToPath;

                    /***/
                },

            /***/ "./node_modules/lodash/_toKey.js":
                /*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isSymbol = __webpack_require__(
                        /*! ./isSymbol */ "./node_modules/lodash/isSymbol.js"
                    );
                    /** Used as references for various `Number` constants. */

                    var INFINITY = 1 / 0;
                    /**
                     * Converts `value` to a string key if it's not a string or symbol.
                     *
                     * @private
                     * @param {*} value The value to inspect.
                     * @returns {string|symbol} Returns the key.
                     */

                    function toKey(value) {
                        if (typeof value == "string" || isSymbol(value)) {
                            return value;
                        }

                        var result = value + "";
                        return result == "0" && 1 / value == -INFINITY
                            ? "-0"
                            : result;
                    }

                    module.exports = toKey;

                    /***/
                },

            /***/ "./node_modules/lodash/_toSource.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used for built-in method references. */
                    var funcProto = Function.prototype;
                    /** Used to resolve the decompiled source of functions. */

                    var funcToString = funcProto.toString;
                    /**
                     * Converts `func` to its source code.
                     *
                     * @private
                     * @param {Function} func The function to convert.
                     * @returns {string} Returns the source code.
                     */

                    function toSource(func) {
                        if (func != null) {
                            try {
                                return funcToString.call(func);
                            } catch (e) {}

                            try {
                                return func + "";
                            } catch (e) {}
                        }

                        return "";
                    }

                    module.exports = toSource;

                    /***/
                },

            /***/ "./node_modules/lodash/constant.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Creates a function that returns `value`.
                     *
                     * @static
                     * @memberOf _
                     * @since 2.4.0
                     * @category Util
                     * @param {*} value The value to return from the new function.
                     * @returns {Function} Returns the new constant function.
                     * @example
                     *
                     * var objects = _.times(2, _.constant({ 'a': 1 }));
                     *
                     * console.log(objects);
                     * // => [{ 'a': 1 }, { 'a': 1 }]
                     *
                     * console.log(objects[0] === objects[1]);
                     * // => true
                     */
                    function constant(value) {
                        return function () {
                            return value;
                        };
                    }

                    module.exports = constant;

                    /***/
                },

            /***/ "./node_modules/lodash/eq.js":
                /*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Performs a
                     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
                     * comparison between two values to determine if they are equivalent.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to compare.
                     * @param {*} other The other value to compare.
                     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                     * @example
                     *
                     * var object = { 'a': 1 };
                     * var other = { 'a': 1 };
                     *
                     * _.eq(object, object);
                     * // => true
                     *
                     * _.eq(object, other);
                     * // => false
                     *
                     * _.eq('a', 'a');
                     * // => true
                     *
                     * _.eq('a', Object('a'));
                     * // => false
                     *
                     * _.eq(NaN, NaN);
                     * // => true
                     */
                    function eq(value, other) {
                        return (
                            value === other ||
                            (value !== value && other !== other)
                        );
                    }

                    module.exports = eq;

                    /***/
                },

            /***/ "./node_modules/lodash/flatten.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseFlatten = __webpack_require__(
                        /*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"
                    );
                    /**
                     * Flattens `array` a single level deep.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Array
                     * @param {Array} array The array to flatten.
                     * @returns {Array} Returns the new flattened array.
                     * @example
                     *
                     * _.flatten([1, [2, [3, [4]], 5]]);
                     * // => [1, 2, [3, [4]], 5]
                     */

                    function flatten(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? baseFlatten(array, 1) : [];
                    }

                    module.exports = flatten;

                    /***/
                },

            /***/ "./node_modules/lodash/identity.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * This method returns the first argument it receives.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Util
                     * @param {*} value Any value.
                     * @returns {*} Returns `value`.
                     * @example
                     *
                     * var object = { 'a': 1 };
                     *
                     * console.log(_.identity(object) === object);
                     * // => true
                     */
                    function identity(value) {
                        return value;
                    }

                    module.exports = identity;

                    /***/
                },

            /***/ "./node_modules/lodash/isArguments.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseIsArguments = __webpack_require__(
                            /*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** Used for built-in method references. */

                    var objectProto = Object.prototype;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /** Built-in value references. */

                    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
                    /**
                     * Checks if `value` is likely an `arguments` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
                     *  else `false`.
                     * @example
                     *
                     * _.isArguments(function() { return arguments; }());
                     * // => true
                     *
                     * _.isArguments([1, 2, 3]);
                     * // => false
                     */

                    var isArguments = baseIsArguments(
                        (function () {
                            return arguments;
                        })()
                    )
                        ? baseIsArguments
                        : function (value) {
                              return (
                                  isObjectLike(value) &&
                                  hasOwnProperty.call(value, "callee") &&
                                  !propertyIsEnumerable.call(value, "callee")
                              );
                          };
                    module.exports = isArguments;

                    /***/
                },

            /***/ "./node_modules/lodash/isArray.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Checks if `value` is classified as an `Array` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
                     * @example
                     *
                     * _.isArray([1, 2, 3]);
                     * // => true
                     *
                     * _.isArray(document.body.children);
                     * // => false
                     *
                     * _.isArray('abc');
                     * // => false
                     *
                     * _.isArray(_.noop);
                     * // => false
                     */
                    var isArray = Array.isArray;
                    module.exports = isArray;

                    /***/
                },

            /***/ "./node_modules/lodash/isArrayLike.js":
                /*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var isFunction = __webpack_require__(
                            /*! ./isFunction */ "./node_modules/lodash/isFunction.js"
                        ),
                        isLength = __webpack_require__(
                            /*! ./isLength */ "./node_modules/lodash/isLength.js"
                        );
                    /**
                     * Checks if `value` is array-like. A value is considered array-like if it's
                     * not a function and has a `value.length` that's an integer greater than or
                     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
                     * @example
                     *
                     * _.isArrayLike([1, 2, 3]);
                     * // => true
                     *
                     * _.isArrayLike(document.body.children);
                     * // => true
                     *
                     * _.isArrayLike('abc');
                     * // => true
                     *
                     * _.isArrayLike(_.noop);
                     * // => false
                     */

                    function isArrayLike(value) {
                        return (
                            value != null &&
                            isLength(value.length) &&
                            !isFunction(value)
                        );
                    }

                    module.exports = isArrayLike;

                    /***/
                },

            /***/ "./node_modules/lodash/isBuffer.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    /* WEBPACK VAR INJECTION */ (function (module) {
                        var root = __webpack_require__(
                                /*! ./_root */ "./node_modules/lodash/_root.js"
                            ),
                            stubFalse = __webpack_require__(
                                /*! ./stubFalse */ "./node_modules/lodash/stubFalse.js"
                            );
                        /** Detect free variable `exports`. */

                        var freeExports =
                            true && exports && !exports.nodeType && exports;
                        /** Detect free variable `module`. */

                        var freeModule =
                            freeExports &&
                            typeof module == "object" &&
                            module &&
                            !module.nodeType &&
                            module;
                        /** Detect the popular CommonJS extension `module.exports`. */

                        var moduleExports =
                            freeModule && freeModule.exports === freeExports;
                        /** Built-in value references. */

                        var Buffer = moduleExports ? root.Buffer : undefined;
                        /* Built-in method references for those with the same name as other `lodash` methods. */

                        var nativeIsBuffer = Buffer
                            ? Buffer.isBuffer
                            : undefined;
                        /**
                         * Checks if `value` is a buffer.
                         *
                         * @static
                         * @memberOf _
                         * @since 4.3.0
                         * @category Lang
                         * @param {*} value The value to check.
                         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
                         * @example
                         *
                         * _.isBuffer(new Buffer(2));
                         * // => true
                         *
                         * _.isBuffer(new Uint8Array(2));
                         * // => false
                         */

                        var isBuffer = nativeIsBuffer || stubFalse;
                        module.exports = isBuffer;
                        /* WEBPACK VAR INJECTION */
                    }.call(
                        this,
                        __webpack_require__(
                            /*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js"
                        )(module)
                    ));

                    /***/
                },

            /***/ "./node_modules/lodash/isFunction.js":
                /*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        isObject = __webpack_require__(
                            /*! ./isObject */ "./node_modules/lodash/isObject.js"
                        );
                    /** `Object#toString` result references. */

                    var asyncTag = "[object AsyncFunction]",
                        funcTag = "[object Function]",
                        genTag = "[object GeneratorFunction]",
                        proxyTag = "[object Proxy]";
                    /**
                     * Checks if `value` is classified as a `Function` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
                     * @example
                     *
                     * _.isFunction(_);
                     * // => true
                     *
                     * _.isFunction(/abc/);
                     * // => false
                     */

                    function isFunction(value) {
                        if (!isObject(value)) {
                            return false;
                        } // The use of `Object#toString` avoids issues with the `typeof` operator
                        // in Safari 9 which returns 'object' for typed arrays and other constructors.

                        var tag = baseGetTag(value);
                        return (
                            tag == funcTag ||
                            tag == genTag ||
                            tag == asyncTag ||
                            tag == proxyTag
                        );
                    }

                    module.exports = isFunction;

                    /***/
                },

            /***/ "./node_modules/lodash/isLength.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /** Used as references for various `Number` constants. */
                    var MAX_SAFE_INTEGER = 9007199254740991;
                    /**
                     * Checks if `value` is a valid array-like length.
                     *
                     * **Note:** This method is loosely based on
                     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
                     * @example
                     *
                     * _.isLength(3);
                     * // => true
                     *
                     * _.isLength(Number.MIN_VALUE);
                     * // => false
                     *
                     * _.isLength(Infinity);
                     * // => false
                     *
                     * _.isLength('3');
                     * // => false
                     */

                    function isLength(value) {
                        return (
                            typeof value == "number" &&
                            value > -1 &&
                            value % 1 == 0 &&
                            value <= MAX_SAFE_INTEGER
                        );
                    }

                    module.exports = isLength;

                    /***/
                },

            /***/ "./node_modules/lodash/isMap.js":
                /*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseIsMap = __webpack_require__(
                            /*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"
                        ),
                        baseUnary = __webpack_require__(
                            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
                        ),
                        nodeUtil = __webpack_require__(
                            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
                        );
                    /* Node.js helper references. */

                    var nodeIsMap = nodeUtil && nodeUtil.isMap;
                    /**
                     * Checks if `value` is classified as a `Map` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.3.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
                     * @example
                     *
                     * _.isMap(new Map);
                     * // => true
                     *
                     * _.isMap(new WeakMap);
                     * // => false
                     */

                    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                    module.exports = isMap;

                    /***/
                },

            /***/ "./node_modules/lodash/isObject.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Checks if `value` is the
                     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
                     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
                     * @example
                     *
                     * _.isObject({});
                     * // => true
                     *
                     * _.isObject([1, 2, 3]);
                     * // => true
                     *
                     * _.isObject(_.noop);
                     * // => true
                     *
                     * _.isObject(null);
                     * // => false
                     */
                    function isObject(value) {
                        var type = typeof value;
                        return (
                            value != null &&
                            (type == "object" || type == "function")
                        );
                    }

                    module.exports = isObject;

                    /***/
                },

            /***/ "./node_modules/lodash/isObjectLike.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Checks if `value` is object-like. A value is object-like if it's not `null`
                     * and has a `typeof` result of "object".
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
                     * @example
                     *
                     * _.isObjectLike({});
                     * // => true
                     *
                     * _.isObjectLike([1, 2, 3]);
                     * // => true
                     *
                     * _.isObjectLike(_.noop);
                     * // => false
                     *
                     * _.isObjectLike(null);
                     * // => false
                     */
                    function isObjectLike(value) {
                        return value != null && typeof value == "object";
                    }

                    module.exports = isObjectLike;

                    /***/
                },

            /***/ "./node_modules/lodash/isPlainObject.js":
                /*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        getPrototype = __webpack_require__(
                            /*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var objectTag = "[object Object]";
                    /** Used for built-in method references. */

                    var funcProto = Function.prototype,
                        objectProto = Object.prototype;
                    /** Used to resolve the decompiled source of functions. */

                    var funcToString = funcProto.toString;
                    /** Used to check objects for own properties. */

                    var hasOwnProperty = objectProto.hasOwnProperty;
                    /** Used to infer the `Object` constructor. */

                    var objectCtorString = funcToString.call(Object);
                    /**
                     * Checks if `value` is a plain object, that is, an object created by the
                     * `Object` constructor or one with a `[[Prototype]]` of `null`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.8.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     * }
                     *
                     * _.isPlainObject(new Foo);
                     * // => false
                     *
                     * _.isPlainObject([1, 2, 3]);
                     * // => false
                     *
                     * _.isPlainObject({ 'x': 0, 'y': 0 });
                     * // => true
                     *
                     * _.isPlainObject(Object.create(null));
                     * // => true
                     */

                    function isPlainObject(value) {
                        if (
                            !isObjectLike(value) ||
                            baseGetTag(value) != objectTag
                        ) {
                            return false;
                        }

                        var proto = getPrototype(value);

                        if (proto === null) {
                            return true;
                        }

                        var Ctor =
                            hasOwnProperty.call(proto, "constructor") &&
                            proto.constructor;
                        return (
                            typeof Ctor == "function" &&
                            Ctor instanceof Ctor &&
                            funcToString.call(Ctor) == objectCtorString
                        );
                    }

                    module.exports = isPlainObject;

                    /***/
                },

            /***/ "./node_modules/lodash/isSet.js":
                /*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseIsSet = __webpack_require__(
                            /*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"
                        ),
                        baseUnary = __webpack_require__(
                            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
                        ),
                        nodeUtil = __webpack_require__(
                            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
                        );
                    /* Node.js helper references. */

                    var nodeIsSet = nodeUtil && nodeUtil.isSet;
                    /**
                     * Checks if `value` is classified as a `Set` object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.3.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
                     * @example
                     *
                     * _.isSet(new Set);
                     * // => true
                     *
                     * _.isSet(new WeakSet);
                     * // => false
                     */

                    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                    module.exports = isSet;

                    /***/
                },

            /***/ "./node_modules/lodash/isSymbol.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseGetTag = __webpack_require__(
                            /*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"
                        ),
                        isObjectLike = __webpack_require__(
                            /*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js"
                        );
                    /** `Object#toString` result references. */

                    var symbolTag = "[object Symbol]";
                    /**
                     * Checks if `value` is classified as a `Symbol` primitive or object.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
                     * @example
                     *
                     * _.isSymbol(Symbol.iterator);
                     * // => true
                     *
                     * _.isSymbol('abc');
                     * // => false
                     */

                    function isSymbol(value) {
                        return (
                            typeof value == "symbol" ||
                            (isObjectLike(value) &&
                                baseGetTag(value) == symbolTag)
                        );
                    }

                    module.exports = isSymbol;

                    /***/
                },

            /***/ "./node_modules/lodash/isTypedArray.js":
                /*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseIsTypedArray = __webpack_require__(
                            /*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"
                        ),
                        baseUnary = __webpack_require__(
                            /*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"
                        ),
                        nodeUtil = __webpack_require__(
                            /*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js"
                        );
                    /* Node.js helper references. */

                    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
                    /**
                     * Checks if `value` is classified as a typed array.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.0.0
                     * @category Lang
                     * @param {*} value The value to check.
                     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
                     * @example
                     *
                     * _.isTypedArray(new Uint8Array);
                     * // => true
                     *
                     * _.isTypedArray([]);
                     * // => false
                     */

                    var isTypedArray = nodeIsTypedArray
                        ? baseUnary(nodeIsTypedArray)
                        : baseIsTypedArray;
                    module.exports = isTypedArray;

                    /***/
                },

            /***/ "./node_modules/lodash/keys.js":
                /*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayLikeKeys = __webpack_require__(
                            /*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"
                        ),
                        baseKeys = __webpack_require__(
                            /*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"
                        ),
                        isArrayLike = __webpack_require__(
                            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
                        );
                    /**
                     * Creates an array of the own enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects. See the
                     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
                     * for more details.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keys(new Foo);
                     * // => ['a', 'b'] (iteration order is not guaranteed)
                     *
                     * _.keys('hi');
                     * // => ['0', '1']
                     */

                    function keys(object) {
                        return isArrayLike(object)
                            ? arrayLikeKeys(object)
                            : baseKeys(object);
                    }

                    module.exports = keys;

                    /***/
                },

            /***/ "./node_modules/lodash/keysIn.js":
                /*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayLikeKeys = __webpack_require__(
                            /*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"
                        ),
                        baseKeysIn = __webpack_require__(
                            /*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"
                        ),
                        isArrayLike = __webpack_require__(
                            /*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"
                        );
                    /**
                     * Creates an array of the own and inherited enumerable property names of `object`.
                     *
                     * **Note:** Non-object values are coerced to objects.
                     *
                     * @static
                     * @memberOf _
                     * @since 3.0.0
                     * @category Object
                     * @param {Object} object The object to query.
                     * @returns {Array} Returns the array of property names.
                     * @example
                     *
                     * function Foo() {
                     *   this.a = 1;
                     *   this.b = 2;
                     * }
                     *
                     * Foo.prototype.c = 3;
                     *
                     * _.keysIn(new Foo);
                     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
                     */

                    function keysIn(object) {
                        return isArrayLike(object)
                            ? arrayLikeKeys(object, true)
                            : baseKeysIn(object);
                    }

                    module.exports = keysIn;

                    /***/
                },

            /***/ "./node_modules/lodash/last.js":
                /*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Gets the last element of `array`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Array
                     * @param {Array} array The array to query.
                     * @returns {*} Returns the last element of `array`.
                     * @example
                     *
                     * _.last([1, 2, 3]);
                     * // => 3
                     */
                    function last(array) {
                        var length = array == null ? 0 : array.length;
                        return length ? array[length - 1] : undefined;
                    }

                    module.exports = last;

                    /***/
                },

            /***/ "./node_modules/lodash/memoize.js":
                /*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var MapCache = __webpack_require__(
                        /*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"
                    );
                    /** Error message constants. */

                    var FUNC_ERROR_TEXT = "Expected a function";
                    /**
                     * Creates a function that memoizes the result of `func`. If `resolver` is
                     * provided, it determines the cache key for storing the result based on the
                     * arguments provided to the memoized function. By default, the first argument
                     * provided to the memoized function is used as the map cache key. The `func`
                     * is invoked with the `this` binding of the memoized function.
                     *
                     * **Note:** The cache is exposed as the `cache` property on the memoized
                     * function. Its creation may be customized by replacing the `_.memoize.Cache`
                     * constructor with one whose instances implement the
                     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
                     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
                     *
                     * @static
                     * @memberOf _
                     * @since 0.1.0
                     * @category Function
                     * @param {Function} func The function to have its output memoized.
                     * @param {Function} [resolver] The function to resolve the cache key.
                     * @returns {Function} Returns the new memoized function.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': 2 };
                     * var other = { 'c': 3, 'd': 4 };
                     *
                     * var values = _.memoize(_.values);
                     * values(object);
                     * // => [1, 2]
                     *
                     * values(other);
                     * // => [3, 4]
                     *
                     * object.a = 2;
                     * values(object);
                     * // => [1, 2]
                     *
                     * // Modify the result cache.
                     * values.cache.set(object, ['a', 'b']);
                     * values(object);
                     * // => ['a', 'b']
                     *
                     * // Replace `_.memoize.Cache`.
                     * _.memoize.Cache = WeakMap;
                     */

                    function memoize(func, resolver) {
                        if (
                            typeof func != "function" ||
                            (resolver != null && typeof resolver != "function")
                        ) {
                            throw new TypeError(FUNC_ERROR_TEXT);
                        }

                        var memoized = function () {
                            var args = arguments,
                                key = resolver
                                    ? resolver.apply(this, args)
                                    : args[0],
                                cache = memoized.cache;

                            if (cache.has(key)) {
                                return cache.get(key);
                            }

                            var result = func.apply(this, args);
                            memoized.cache = cache.set(key, result) || cache;
                            return result;
                        };

                        memoized.cache = new (memoize.Cache || MapCache)();
                        return memoized;
                    } // Expose `MapCache`.

                    memoize.Cache = MapCache;
                    module.exports = memoize;

                    /***/
                },

            /***/ "./node_modules/lodash/omit.js":
                /*!*************************************!*\
  !*** ./node_modules/lodash/omit.js ***!
  \*************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var arrayMap = __webpack_require__(
                            /*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"
                        ),
                        baseClone = __webpack_require__(
                            /*! ./_baseClone */ "./node_modules/lodash/_baseClone.js"
                        ),
                        baseUnset = __webpack_require__(
                            /*! ./_baseUnset */ "./node_modules/lodash/_baseUnset.js"
                        ),
                        castPath = __webpack_require__(
                            /*! ./_castPath */ "./node_modules/lodash/_castPath.js"
                        ),
                        copyObject = __webpack_require__(
                            /*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"
                        ),
                        customOmitClone = __webpack_require__(
                            /*! ./_customOmitClone */ "./node_modules/lodash/_customOmitClone.js"
                        ),
                        flatRest = __webpack_require__(
                            /*! ./_flatRest */ "./node_modules/lodash/_flatRest.js"
                        ),
                        getAllKeysIn = __webpack_require__(
                            /*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"
                        );
                    /** Used to compose bitmasks for cloning. */

                    var CLONE_DEEP_FLAG = 1,
                        CLONE_FLAT_FLAG = 2,
                        CLONE_SYMBOLS_FLAG = 4;
                    /**
                     * The opposite of `_.pick`; this method creates an object composed of the
                     * own and inherited enumerable property paths of `object` that are not omitted.
                     *
                     * **Note:** This method is considerably slower than `_.pick`.
                     *
                     * @static
                     * @since 0.1.0
                     * @memberOf _
                     * @category Object
                     * @param {Object} object The source object.
                     * @param {...(string|string[])} [paths] The property paths to omit.
                     * @returns {Object} Returns the new object.
                     * @example
                     *
                     * var object = { 'a': 1, 'b': '2', 'c': 3 };
                     *
                     * _.omit(object, ['a', 'c']);
                     * // => { 'b': '2' }
                     */

                    var omit = flatRest(function (object, paths) {
                        var result = {};

                        if (object == null) {
                            return result;
                        }

                        var isDeep = false;
                        paths = arrayMap(paths, function (path) {
                            path = castPath(path, object);
                            isDeep || (isDeep = path.length > 1);
                            return path;
                        });
                        copyObject(object, getAllKeysIn(object), result);

                        if (isDeep) {
                            result = baseClone(
                                result,
                                CLONE_DEEP_FLAG |
                                    CLONE_FLAT_FLAG |
                                    CLONE_SYMBOLS_FLAG,
                                customOmitClone
                            );
                        }

                        var length = paths.length;

                        while (length--) {
                            baseUnset(result, paths[length]);
                        }

                        return result;
                    });
                    module.exports = omit;

                    /***/
                },

            /***/ "./node_modules/lodash/stubArray.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * This method returns a new empty array.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.13.0
                     * @category Util
                     * @returns {Array} Returns the new empty array.
                     * @example
                     *
                     * var arrays = _.times(2, _.stubArray);
                     *
                     * console.log(arrays);
                     * // => [[], []]
                     *
                     * console.log(arrays[0] === arrays[1]);
                     * // => false
                     */
                    function stubArray() {
                        return [];
                    }

                    module.exports = stubArray;

                    /***/
                },

            /***/ "./node_modules/lodash/stubFalse.js":
                /*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * This method returns `false`.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.13.0
                     * @category Util
                     * @returns {boolean} Returns `false`.
                     * @example
                     *
                     * _.times(2, _.stubFalse);
                     * // => [false, false]
                     */
                    function stubFalse() {
                        return false;
                    }

                    module.exports = stubFalse;

                    /***/
                },

            /***/ "./node_modules/lodash/toString.js":
                /*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    var baseToString = __webpack_require__(
                        /*! ./_baseToString */ "./node_modules/lodash/_baseToString.js"
                    );
                    /**
                     * Converts `value` to a string. An empty string is returned for `null`
                     * and `undefined` values. The sign of `-0` is preserved.
                     *
                     * @static
                     * @memberOf _
                     * @since 4.0.0
                     * @category Lang
                     * @param {*} value The value to convert.
                     * @returns {string} Returns the converted string.
                     * @example
                     *
                     * _.toString(null);
                     * // => ''
                     *
                     * _.toString(-0);
                     * // => '-0'
                     *
                     * _.toString([1, 2, 3]);
                     * // => '1,2,3'
                     */

                    function toString(value) {
                        return value == null ? "" : baseToString(value);
                    }

                    module.exports = toString;

                    /***/
                },

            /***/ "./node_modules/ms/index.js":
                /*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    /**
                     * Helpers.
                     */
                    var s = 1000;
                    var m = s * 60;
                    var h = m * 60;
                    var d = h * 24;
                    var y = d * 365.25;
                    /**
                     * Parse or format the given `val`.
                     *
                     * Options:
                     *
                     *  - `long` verbose formatting [false]
                     *
                     * @param {String|Number} val
                     * @param {Object} [options]
                     * @throws {Error} throw an error if val is not a non-empty string or a number
                     * @return {String|Number}
                     * @api public
                     */

                    module.exports = function (val, options) {
                        options = options || {};
                        var type = typeof val;

                        if (type === "string" && val.length > 0) {
                            return parse(val);
                        } else if (type === "number" && isNaN(val) === false) {
                            return options.long ? fmtLong(val) : fmtShort(val);
                        }

                        throw new Error(
                            "val is not a non-empty string or a valid number. val=" +
                                JSON.stringify(val)
                        );
                    };
                    /**
                     * Parse the given `str` and return milliseconds.
                     *
                     * @param {String} str
                     * @return {Number}
                     * @api private
                     */

                    function parse(str) {
                        str = String(str);

                        if (str.length > 100) {
                            return;
                        }

                        var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
                            str
                        );

                        if (!match) {
                            return;
                        }

                        var n = parseFloat(match[1]);
                        var type = (match[2] || "ms").toLowerCase();

                        switch (type) {
                            case "years":
                            case "year":
                            case "yrs":
                            case "yr":
                            case "y":
                                return n * y;

                            case "days":
                            case "day":
                            case "d":
                                return n * d;

                            case "hours":
                            case "hour":
                            case "hrs":
                            case "hr":
                            case "h":
                                return n * h;

                            case "minutes":
                            case "minute":
                            case "mins":
                            case "min":
                            case "m":
                                return n * m;

                            case "seconds":
                            case "second":
                            case "secs":
                            case "sec":
                            case "s":
                                return n * s;

                            case "milliseconds":
                            case "millisecond":
                            case "msecs":
                            case "msec":
                            case "ms":
                                return n;

                            default:
                                return undefined;
                        }
                    }
                    /**
                     * Short format for `ms`.
                     *
                     * @param {Number} ms
                     * @return {String}
                     * @api private
                     */

                    function fmtShort(ms) {
                        if (ms >= d) {
                            return Math.round(ms / d) + "d";
                        }

                        if (ms >= h) {
                            return Math.round(ms / h) + "h";
                        }

                        if (ms >= m) {
                            return Math.round(ms / m) + "m";
                        }

                        if (ms >= s) {
                            return Math.round(ms / s) + "s";
                        }

                        return ms + "ms";
                    }
                    /**
                     * Long format for `ms`.
                     *
                     * @param {Number} ms
                     * @return {String}
                     * @api private
                     */

                    function fmtLong(ms) {
                        return (
                            plural(ms, d, "day") ||
                            plural(ms, h, "hour") ||
                            plural(ms, m, "minute") ||
                            plural(ms, s, "second") ||
                            ms + " ms"
                        );
                    }
                    /**
                     * Pluralization helper.
                     */

                    function plural(ms, n, name) {
                        if (ms < n) {
                            return;
                        }

                        if (ms < n * 1.5) {
                            return Math.floor(ms / n) + " " + name;
                        }

                        return Math.ceil(ms / n) + " " + name + "s";
                    }

                    /***/
                },

            /***/ "./node_modules/omit-deep-lodash/lib/index.js":
                /*!****************************************************!*\
  !*** ./node_modules/omit-deep-lodash/lib/index.js ***!
  \****************************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    var _slicedToArray = (function () {
                        function sliceIterator(arr, i) {
                            var _arr = [];
                            var _n = true;
                            var _d = false;
                            var _e = undefined;

                            try {
                                for (
                                    var _i = arr[Symbol.iterator](), _s;
                                    !(_n = (_s = _i.next()).done);
                                    _n = true
                                ) {
                                    _arr.push(_s.value);

                                    if (i && _arr.length === i) break;
                                }
                            } catch (err) {
                                _d = true;
                                _e = err;
                            } finally {
                                try {
                                    if (!_n && _i["return"]) _i["return"]();
                                } finally {
                                    if (_d) throw _e;
                                }
                            }

                            return _arr;
                        }

                        return function (arr, i) {
                            if (Array.isArray(arr)) {
                                return arr;
                            } else if (Symbol.iterator in Object(arr)) {
                                return sliceIterator(arr, i);
                            } else {
                                throw new TypeError(
                                    "Invalid attempt to destructure non-iterable instance"
                                );
                            }
                        };
                    })();

                    var omit = __webpack_require__(
                        /*! lodash/omit */ "./node_modules/lodash/omit.js"
                    );

                    module.exports = function omitDeepLodash(input, props) {
                        function omitDeepOnOwnProps(obj) {
                            if (typeof input === "undefined") {
                                return input;
                            }

                            if (!Array.isArray(obj) && !isObject(obj)) {
                                return obj;
                            }

                            if (Array.isArray(obj)) {
                                return omitDeepLodash(obj, props);
                            }

                            var o = {};
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;

                            try {
                                for (
                                    var _iterator = Object.entries(obj)[
                                            Symbol.iterator
                                        ](),
                                        _step;
                                    !(_iteratorNormalCompletion = (_step = _iterator.next())
                                        .done);
                                    _iteratorNormalCompletion = true
                                ) {
                                    var _step$value = _slicedToArray(
                                            _step.value,
                                            2
                                        ),
                                        key = _step$value[0],
                                        value = _step$value[1];

                                    o[key] = !isNil(value)
                                        ? omitDeepLodash(value, props)
                                        : value;
                                }
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally {
                                try {
                                    if (
                                        !_iteratorNormalCompletion &&
                                        _iterator.return
                                    ) {
                                        _iterator.return();
                                    }
                                } finally {
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }

                            return omit(o, props);
                        }

                        if (arguments.length > 2) {
                            props = Array.prototype.slice
                                .call(arguments)
                                .slice(1);
                        }

                        if (Array.isArray(input)) {
                            return input.map(omitDeepOnOwnProps);
                        }

                        return omitDeepOnOwnProps(input);
                    };

                    function isNil(value) {
                        return value === null || value === undefined;
                    }

                    function isObject(obj) {
                        return (
                            Object.prototype.toString.call(obj) ===
                            "[object Object]"
                        );
                    }

                    /***/
                },

            /***/ "./node_modules/process/browser.js":
                /*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    // shim for using process in browser
                    var process = (module.exports = {}); // cached from whatever global is present so that test runners that stub it
                    // don't break things.  But we need to wrap it in a try catch in case it is
                    // wrapped in strict mode code which doesn't define any globals.  It's inside a
                    // function because try/catches deoptimize in certain engines.

                    var cachedSetTimeout;
                    var cachedClearTimeout;

                    function defaultSetTimout() {
                        throw new Error("setTimeout has not been defined");
                    }

                    function defaultClearTimeout() {
                        throw new Error("clearTimeout has not been defined");
                    }

                    (function () {
                        try {
                            if (typeof setTimeout === "function") {
                                cachedSetTimeout = setTimeout;
                            } else {
                                cachedSetTimeout = defaultSetTimout;
                            }
                        } catch (e) {
                            cachedSetTimeout = defaultSetTimout;
                        }

                        try {
                            if (typeof clearTimeout === "function") {
                                cachedClearTimeout = clearTimeout;
                            } else {
                                cachedClearTimeout = defaultClearTimeout;
                            }
                        } catch (e) {
                            cachedClearTimeout = defaultClearTimeout;
                        }
                    })();

                    function runTimeout(fun) {
                        if (cachedSetTimeout === setTimeout) {
                            //normal enviroments in sane situations
                            return setTimeout(fun, 0);
                        } // if setTimeout wasn't available but was latter defined

                        if (
                            (cachedSetTimeout === defaultSetTimout ||
                                !cachedSetTimeout) &&
                            setTimeout
                        ) {
                            cachedSetTimeout = setTimeout;
                            return setTimeout(fun, 0);
                        }

                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedSetTimeout(fun, 0);
                        } catch (e) {
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                                return cachedSetTimeout.call(null, fun, 0);
                            } catch (e) {
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                                return cachedSetTimeout.call(this, fun, 0);
                            }
                        }
                    }

                    function runClearTimeout(marker) {
                        if (cachedClearTimeout === clearTimeout) {
                            //normal enviroments in sane situations
                            return clearTimeout(marker);
                        } // if clearTimeout wasn't available but was latter defined

                        if (
                            (cachedClearTimeout === defaultClearTimeout ||
                                !cachedClearTimeout) &&
                            clearTimeout
                        ) {
                            cachedClearTimeout = clearTimeout;
                            return clearTimeout(marker);
                        }

                        try {
                            // when when somebody has screwed with setTimeout but no I.E. maddness
                            return cachedClearTimeout(marker);
                        } catch (e) {
                            try {
                                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                                return cachedClearTimeout.call(null, marker);
                            } catch (e) {
                                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                                return cachedClearTimeout.call(this, marker);
                            }
                        }
                    }

                    var queue = [];
                    var draining = false;
                    var currentQueue;
                    var queueIndex = -1;

                    function cleanUpNextTick() {
                        if (!draining || !currentQueue) {
                            return;
                        }

                        draining = false;

                        if (currentQueue.length) {
                            queue = currentQueue.concat(queue);
                        } else {
                            queueIndex = -1;
                        }

                        if (queue.length) {
                            drainQueue();
                        }
                    }

                    function drainQueue() {
                        if (draining) {
                            return;
                        }

                        var timeout = runTimeout(cleanUpNextTick);
                        draining = true;
                        var len = queue.length;

                        while (len) {
                            currentQueue = queue;
                            queue = [];

                            while (++queueIndex < len) {
                                if (currentQueue) {
                                    currentQueue[queueIndex].run();
                                }
                            }

                            queueIndex = -1;
                            len = queue.length;
                        }

                        currentQueue = null;
                        draining = false;
                        runClearTimeout(timeout);
                    }

                    process.nextTick = function (fun) {
                        var args = new Array(arguments.length - 1);

                        if (arguments.length > 1) {
                            for (var i = 1; i < arguments.length; i++) {
                                args[i - 1] = arguments[i];
                            }
                        }

                        queue.push(new Item(fun, args));

                        if (queue.length === 1 && !draining) {
                            runTimeout(drainQueue);
                        }
                    }; // v8 likes predictible objects

                    function Item(fun, array) {
                        this.fun = fun;
                        this.array = array;
                    }

                    Item.prototype.run = function () {
                        this.fun.apply(null, this.array);
                    };

                    process.title = "browser";
                    process.browser = true;
                    process.env = {};
                    process.argv = [];
                    process.version = ""; // empty string to avoid regexp issues

                    process.versions = {};

                    function noop() {}

                    process.on = noop;
                    process.addListener = noop;
                    process.once = noop;
                    process.off = noop;
                    process.removeListener = noop;
                    process.removeAllListeners = noop;
                    process.emit = noop;
                    process.prependListener = noop;
                    process.prependOnceListener = noop;

                    process.listeners = function (name) {
                        return [];
                    };

                    process.binding = function (name) {
                        throw new Error("process.binding is not supported");
                    };

                    process.cwd = function () {
                        return "/";
                    };

                    process.chdir = function (dir) {
                        throw new Error("process.chdir is not supported");
                    };

                    process.umask = function () {
                        return 0;
                    };

                    /***/
                },

            /***/ "./node_modules/selectn/index.js":
                /*!***************************************!*\
  !*** ./node_modules/selectn/index.js ***!
  \***************************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    var curry2 = __webpack_require__(
                        /*! curry2 */ "./node_modules/curry2/index.js"
                    );

                    var debug = __webpack_require__(
                        /*! debug */ "./node_modules/debug/src/browser.js"
                    )("selectn");

                    var dotted = __webpack_require__(
                        /*! brackets2dots */ "./node_modules/brackets2dots/index.js"
                    );

                    var splits = __webpack_require__(
                        /*! dotsplit.js */ "./node_modules/dotsplit.js/index.js"
                    );

                    var string = Object.prototype.toString;
                    module.exports = curry2(selectn);
                    /**
                     * Curried property accessor function that resolves deeply-nested object properties via dot/bracket-notation
                     * string path while mitigating `TypeErrors` via friendly and composable API.
                     *
                     * @param {String|Array} path
                     * Dot/bracket-notation string path or array.
                     *
                     * @param {Object} object
                     * Object to access.
                     *
                     * @return {Function|*|undefined}
                     * (1) returns `selectn/1` when partially applied.
                     * (2) returns value at path if path exists.
                     * (3) returns undefined if path does not exist.
                     */

                    function selectn(path, object) {
                        debug("arguments:", {
                            path: path,
                            object: object,
                        });
                        var idx = -1;
                        var seg =
                            string.call(path) === "[object Array]"
                                ? path
                                : splits(dotted(path));
                        var end = seg.length;
                        var ref = end ? object : void 0;

                        while (++idx < end) {
                            if (Object(ref) !== ref) return void 0;
                            ref = ref[seg[idx]];
                        }

                        debug("ref:", ref);
                        return typeof ref === "function" ? ref() : ref;
                    }

                    /***/
                },

            /***/ "./node_modules/webpack/buildin/global.js":
                /*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    var g; // This works in non-strict mode

                    g = (function () {
                        return this;
                    })();

                    try {
                        // This works if eval is allowed (see CSP)
                        g = g || new Function("return this")();
                    } catch (e) {
                        // This works if the window reference is available
                        if (typeof window === "object") g = window;
                    } // g can still be undefined, but nothing to do about it...
                    // We return undefined, instead of nothing here, so it's
                    // easier to handle this case. if(!global) { ...}

                    module.exports = g;

                    /***/
                },

            /***/ "./node_modules/webpack/buildin/module.js":
                /*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
                /*! no static exports found */
                /***/ function (module, exports) {
                    module.exports = function (module) {
                        if (!module.webpackPolyfill) {
                            module.deprecate = function () {};

                            module.paths = []; // module.parent = undefined by default

                            if (!module.children) module.children = [];
                            Object.defineProperty(module, "loaded", {
                                enumerable: true,
                                get: function () {
                                    return module.l;
                                },
                            });
                            Object.defineProperty(module, "id", {
                                enumerable: true,
                                get: function () {
                                    return module.i;
                                },
                            });
                            module.webpackPolyfill = 1;
                        }

                        return module;
                    };

                    /***/
                },

            /***/ "./src/array-utils.js":
                /*!****************************!*\
  !*** ./src/array-utils.js ***!
  \****************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    var _lodash = _interopRequireDefault(
                        __webpack_require__(
                            /*! lodash.uniq */ "./node_modules/lodash.uniq/index.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _toConsumableArray(arr) {
                        return (
                            _arrayWithoutHoles(arr) ||
                            _iterableToArray(arr) ||
                            _nonIterableSpread()
                        );
                    }

                    function _nonIterableSpread() {
                        throw new TypeError(
                            "Invalid attempt to spread non-iterable instance"
                        );
                    }

                    function _iterableToArray(iter) {
                        if (
                            Symbol.iterator in Object(iter) ||
                            Object.prototype.toString.call(iter) ===
                                "[object Arguments]"
                        )
                            return Array.from(iter);
                    }

                    function _arrayWithoutHoles(arr) {
                        if (Array.isArray(arr)) {
                            for (
                                var i = 0, arr2 = new Array(arr.length);
                                i < arr.length;
                                i++
                            ) {
                                arr2[i] = arr[i];
                            }
                            return arr2;
                        }
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var ArrayUtils =
                        /*#__PURE__*/
                        (function () {
                            function ArrayUtils() {
                                _classCallCheck(this, ArrayUtils);
                            }

                            _createClass(ArrayUtils, null, [
                                {
                                    key: "merge",

                                    /**
                                     * Merge an array to the end of another array. The arrays can contain any types
                                     *
                                     * @param {Array} toArr     The array to merge into.
                                     * @param {Array} fromArr   The array to be merged.
                                     */
                                    value: function merge(toArr, fromArr) {
                                        if (_langUtils.default.isArray(toArr)) {
                                            this.removeAndInsert(
                                                toArr,
                                                toArr.length,
                                                0,
                                                fromArr
                                            );
                                        }
                                    },
                                    /**
                                     * Remove item from array.
                                     *
                                     * @param {Array} arr       The array to manipulate.
                                     * @param {Number} index    The index of the item to be removed, it should be an integer >= 0.
                                     */
                                },
                                {
                                    key: "removeAt",
                                    value: function removeAt(arr, index) {
                                        index = Number(index);

                                        if (
                                            _langUtils.default.isArray(arr) &&
                                            index < arr.length &&
                                            index >= 0
                                        ) {
                                            arr.splice(index, 1);
                                        }
                                    },
                                    /**
                                     * Replace (part of) an array with items from another array.
                                     *
                                     * @param {Array} arr               The array to manipulate.
                                     * @param {Number} startIndex       Start index of the part of the array to be replaced, it should
                                     *                                  be an integer >= 0.
                                     * @param {Number} [endIndex]       An optional end index of the part of the array to be replaced, To
                                     *                                  remove items, an end index should be >= startIndex value, alternatively
                                     *                                  a new array can be inserted by setting end index to null.
                                     * @param {Array} [insertArr=[]]    An optional array to add in the place of the removed part. This
                                     *                                  is optional and defaults to an empty array.
                                     */
                                },
                                {
                                    key: "removeAndInsert",
                                    value: function removeAndInsert(
                                        arr,
                                        startIndex,
                                        endIndex,
                                        insertArr
                                    ) {
                                        startIndex = Number(startIndex);
                                        endIndex = Number(endIndex);
                                        var numItems =
                                            endIndex >= startIndex
                                                ? endIndex - startIndex + 1
                                                : 0;

                                        if (
                                            !_langUtils.default.isArray(
                                                insertArr
                                            )
                                        ) {
                                            insertArr = [];
                                        }

                                        if (
                                            _langUtils.default.isArray(arr) &&
                                            startIndex >= 0
                                        ) {
                                            arr.splice.apply(
                                                arr,
                                                [startIndex, numItems].concat(
                                                    _toConsumableArray(
                                                        insertArr
                                                    )
                                                )
                                            );
                                        }
                                    },
                                    /**
                                     * Removes duplicate items from an array (uses Lodash uniq method).
                                     * **Note:** This method does not supports nested arrays.
                                     *
                                     * @param {Array} arr       The array to manipulate
                                     * @return {Array}          New array without duplicates.
                                     *
                                     * @example
                                     *
                                     * ArrayUtils.uniq([2, 1, 2]);
                                     * // => [2, 1]
                                     */
                                },
                                {
                                    key: "uniq",
                                    value: function uniq(arr) {
                                        return (0, _lodash.default)(arr);
                                    },
                                    /**
                                     * Search for an element in an Array.
                                     *
                                     * @param {Array} array                 The array to be searched.
                                     * @param {*} searchElement             The element to search for.
                                     * @param {Number} [fromIndex=0]        The index to start searching from. It should be an integer >= 0.
                                     * @param {Function} [isEqualFunc]      A custom equality function to use for the search.
                                     *
                                     * @return {int}                        Element search Index. If element is not found, it returns -1.
                                     *
                                     * @example
                                     *
                                     * ArrayUtils.indexOf(['a', 'ab', 'abc'], 'ab');
                                     * // => 1
                                     *
                                     * ArrayUtils.indexOf([[1, 2], null, [1, 3], undefined, 'a'], [1, 3], 0,
                                     *  (a, b) => ((a === b) || (a && b && a.toString() === b.toString())));
                                     * // => 2
                                     *
                                     */
                                },
                                {
                                    key: "indexOf",
                                    value: function indexOf(
                                        array,
                                        searchElement,
                                        fromIndex,
                                        isEqualFunc
                                    ) {
                                        if (
                                            !_langUtils.default.isArray(array)
                                        ) {
                                            return -1;
                                        }

                                        if (
                                            !_langUtils.default.isNumber(
                                                fromIndex
                                            ) ||
                                            fromIndex < 0
                                        ) {
                                            fromIndex = 0;
                                        }

                                        if (
                                            _langUtils.default.isFunction(
                                                isEqualFunc
                                            )
                                        ) {
                                            for (
                                                var i = fromIndex;
                                                i < array.length;
                                                i++
                                            ) {
                                                if (
                                                    isEqualFunc(
                                                        array[i],
                                                        searchElement
                                                    )
                                                ) {
                                                    return i;
                                                }
                                            }

                                            return -1;
                                        }

                                        return array.indexOf(
                                            searchElement,
                                            fromIndex
                                        );
                                    },
                                },
                            ]);

                            return ArrayUtils;
                        })();

                    exports.default = ArrayUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/index.js":
                /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    Object.defineProperty(exports, "ArrayUtils", {
                        enumerable: true,
                        get: function get() {
                            return _arrayUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "LangUtils", {
                        enumerable: true,
                        get: function get() {
                            return _langUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "Logger", {
                        enumerable: true,
                        get: function get() {
                            return _logger.default;
                        },
                    });
                    Object.defineProperty(exports, "NodeUtils", {
                        enumerable: true,
                        get: function get() {
                            return _nodeUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "NumberUtils", {
                        enumerable: true,
                        get: function get() {
                            return _numberUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "ObjectUtils", {
                        enumerable: true,
                        get: function get() {
                            return _objectUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "PromiseUtils", {
                        enumerable: true,
                        get: function get() {
                            return _promiseUtils.default;
                        },
                    });
                    Object.defineProperty(exports, "StringUtils", {
                        enumerable: true,
                        get: function get() {
                            return _stringUtils.default;
                        },
                    });

                    var _arrayUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! array-utils */ "./src/array-utils.js"
                        )
                    );

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    var _logger = _interopRequireDefault(
                        __webpack_require__(/*! logger */ "./src/logger.js")
                    );

                    var _nodeUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! node-utils */ "./src/node-utils.js"
                        )
                    );

                    var _numberUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! number-utils */ "./src/number-utils.js"
                        )
                    );

                    var _objectUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! object-utils */ "./src/object-utils.js"
                        )
                    );

                    var _promiseUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! promise-utils */ "./src/promise-utils.js"
                        )
                    );

                    var _stringUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! string-utils */ "./src/string-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    /***/
                },

            /***/ "./src/lang-utils.js":
                /*!***************************!*\
  !*** ./src/lang-utils.js ***!
  \***************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _lodash = _interopRequireDefault(
                        __webpack_require__(
                            /*! lodash.clonedeep */ "./node_modules/lodash.clonedeep/index.js"
                        )
                    );

                    var _lodash2 = _interopRequireDefault(
                        __webpack_require__(
                            /*! lodash.clone */ "./node_modules/lodash.clone/index.js"
                        )
                    );

                    var _lodash3 = _interopRequireDefault(
                        __webpack_require__(
                            /*! lodash.isempty */ "./node_modules/lodash.isempty/index.js"
                        )
                    );

                    var _lodash4 = _interopRequireDefault(
                        __webpack_require__(
                            /*! lodash.isequal */ "./node_modules/lodash.isequal/index.js"
                        )
                    );

                    var _selectn = _interopRequireDefault(
                        __webpack_require__(
                            /*! selectn */ "./node_modules/selectn/index.js"
                        )
                    );

                    var _omitDeepLodash = _interopRequireDefault(
                        __webpack_require__(
                            /*! omit-deep-lodash */ "./node_modules/omit-deep-lodash/lib/index.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    function _typeof(obj) {
                        if (
                            typeof Symbol === "function" &&
                            typeof Symbol.iterator === "symbol"
                        ) {
                            _typeof = function _typeof(obj) {
                                return typeof obj;
                            };
                        } else {
                            _typeof = function _typeof(obj) {
                                return obj &&
                                    typeof Symbol === "function" &&
                                    obj.constructor === Symbol &&
                                    obj !== Symbol.prototype
                                    ? "symbol"
                                    : typeof obj;
                            };
                        }
                        return _typeof(obj);
                    }

                    function checkType(x, type) {
                        return _typeof(x) === type;
                    }

                    var LangUtils =
                        /*#__PURE__*/
                        (function () {
                            function LangUtils() {
                                _classCallCheck(this, LangUtils);
                            }

                            _createClass(LangUtils, null, [
                                {
                                    key: "scriptExecute",

                                    /**
                                     * Execute javascript function with given arguments. If the execution fails, return a default value.
                                     *
                                     * @param  {Function} func          JavaScript function.
                                     * @param  {*} defaultValue         This can be any value.
                                     * @param  {...*} args              The arguments to pass to the function.
                                     *
                                     * @return {*}                      function output or default value.
                                     *
                                     * @example
                                     * let value = 2
                                     * LangUtils.scriptExecute(x => x * x, 0, value) //=> 4
                                     *
                                     */
                                    value: function scriptExecute(
                                        func,
                                        defaultValue
                                    ) {
                                        try {
                                            for (
                                                var _len = arguments.length,
                                                    args = new Array(
                                                        _len > 2 ? _len - 2 : 0
                                                    ),
                                                    _key = 2;
                                                _key < _len;
                                                _key++
                                            ) {
                                                args[_key - 2] =
                                                    arguments[_key];
                                            }

                                            return func.apply(void 0, args);
                                        } catch (err) {
                                            // console.log('scriptExecute exception: ', err);
                                        }

                                        return defaultValue;
                                    },
                                    /**
                                     * Verify if a given value is an array.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is an array, otherwise false
                                     */
                                },
                                {
                                    key: "isArray",
                                    value: function isArray(x) {
                                        return (
                                            this.isObjectLike(x) &&
                                            x instanceof Array
                                        );
                                    },
                                    /**
                                     * Verify if a given value is a boolean.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a boolean, otherwise false
                                     */
                                },
                                {
                                    key: "isBoolean",
                                    value: function isBoolean(x) {
                                        return checkType(x, "boolean");
                                    },
                                    /**
                                     * Verify if a given value is a date.
                                     * @param  {*} x             Accepts any value.
                                     * @return {Date}            true if x is a date, otherwise false
                                     */
                                },
                                {
                                    key: "isDate",
                                    value: function isDate(x) {
                                        return (
                                            this.isObjectLike(x) &&
                                            x instanceof Date
                                        );
                                    },
                                    /**
                                     * Verify if a given value is a HTML element.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a HTML element, otherwise false
                                     */
                                },
                                {
                                    key: "isElement",
                                    value: function isElement(x) {
                                        return (
                                            this.isObjectLike(x) &&
                                            this.scriptExecute(
                                                function (x) {
                                                    return (
                                                        x instanceof HTMLElement
                                                    );
                                                },
                                                false,
                                                x
                                            )
                                        );
                                    },
                                    /**
                                     * Verify if a given value is an empty value  (uses Lodash isEmpty method).
                                     * Checks if value is an empty object, collection, map, or set.
                                     *
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is an empty value, otherwise false
                                     */
                                },
                                {
                                    key: "isEmpty",
                                    value: function isEmpty(x) {
                                        return (0, _lodash3.default)(x);
                                    },
                                    /**
                                     * Verify if a given value is a function.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is an function, otherwise false
                                     */
                                },
                                {
                                    key: "isFunction",
                                    value: function isFunction(x) {
                                        return checkType(x, "function");
                                    },
                                    /**
                                     * Verify if a given value is a number.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is an number, otherwise false
                                     */
                                },
                                {
                                    key: "isNumber",
                                    value: function isNumber(x) {
                                        return checkType(x, "number");
                                    },
                                    /**
                                     * Verify if a given value is a number like.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is number like, otherwise false
                                     */
                                },
                                {
                                    key: "isNumberLike",
                                    value: function isNumberLike(x) {
                                        return x !== null && !isNaN(x);
                                    },
                                    /**
                                     * Verify if a given value is an object like or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is object like, otherwise false
                                     */
                                },
                                {
                                    key: "isObjectLike",
                                    value: function isObjectLike(x) {
                                        return (
                                            x !== null && checkType(x, "object")
                                        );
                                    },
                                    /**
                                     * Verify if a given value is a plain object or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a plain object, otherwise false
                                     */
                                },
                                {
                                    key: "isPlainObject",
                                    value: function isPlainObject(x) {
                                        return (
                                            this.isObjectLike(x) &&
                                            Object.getPrototypeOf(x) ===
                                                Object.prototype
                                        );
                                    },
                                    /**
                                     * Verify if a given value is a regular expression or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a regular expression, otherwise false
                                     */
                                },
                                {
                                    key: "isRegExp",
                                    value: function isRegExp(x) {
                                        return (
                                            this.isObjectLike(x) &&
                                            x instanceof RegExp
                                        );
                                    },
                                    /**
                                     * Verify if a given value is a true value or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a true value
                                     */
                                },
                                {
                                    key: "isTrue",
                                    value: function isTrue(x) {
                                        return this.isArray(x) ||
                                            this.isPlainObject(x) ||
                                            this.isString(x)
                                            ? !this.isEmpty(x)
                                            : Boolean(x);
                                    },
                                    /**
                                     * Verify if a given value is a string or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is a string, otherwise false
                                     */
                                },
                                {
                                    key: "isString",
                                    value: function isString(x) {
                                        return checkType(x, "string");
                                    },
                                    /**
                                     * Verify if a given value is undefined or not.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is undefined, otherwise false
                                     */
                                },
                                {
                                    key: "isUndefined",
                                    value: function isUndefined(x) {
                                        return checkType(x, "undefined");
                                    },
                                    /**
                                     * Create a shallow clone object (uses Lodash clone method).
                                     * @param  {*} x                Accepts any value.
                                     * @return {*}                  cloned object.
                                     */
                                },
                                {
                                    key: "clone",
                                    value: function clone(x) {
                                        return (0, _lodash2.default)(x);
                                    },
                                    /**
                                     * Create a deep clone object (uses Lodash cloneDeep method).
                                     * @param  {*} x                Accepts any value.
                                     * @return {*}                  deep cloned object.
                                     */
                                },
                                {
                                    key: "cloneDeep",
                                    value: function cloneDeep(x) {
                                        return (0, _lodash.default)(x);
                                    },
                                    /**
                                     * Performs a deep comparison between two values to determine if they are
                                     * equivalent (uses Lodash isEqual method).
                                     *
                                     * **Note:** This method supports comparing arrays, array buffers, booleans,
                                     * date objects, error objects, maps, numbers, `Object` objects, regexes,
                                     * sets, strings, symbols, and typed arrays. `Object` objects are compared
                                     * by their own, not inherited, enumerable properties. Functions and DOM
                                     * nodes are **not** supported.
                                     *
                                     * @category Lang
                                     * @param {*} value The value to compare.
                                     * @param {*} other The other value to compare.
                                     * @return {Boolean} `true` if the values are equivalent, else `false`.
                                     * @example
                                     *
                                     * var object = { 'user': 'fred' };
                                     * var other = { 'user': 'fred' };
                                     *
                                     * LangUtils.isEqual(object, other);
                                     * // => true
                                     *
                                     * object === other;
                                     * // => false
                                     */
                                },
                                {
                                    key: "isEqual",
                                    value: function isEqual(value, other) {
                                        return (0, _lodash4.default)(
                                            value,
                                            other
                                        );
                                    },
                                    /**
                                     * Get a value from a JSON object at a given path.
                                     *
                                     * @param {Object} json                 JSON object
                                     * @param {(string\|string[])} path     Dot/bracket-notation string path or array.
                                     * @return {*}                          value at given path
                                     * @example
                                     *
                                     * LangUtils.query({'a': ['b', 'c']}, 'a[1]');
                                     * //=> 'c'
                                     *
                                     * LangUtils.query({'a': ['b', 'c']}, ['a', 1])
                                     * //=> 'c'
                                     */
                                },
                                {
                                    key: "query",
                                    value: function query(json, path) {
                                        if (
                                            (this.isArray(json) ||
                                                this.isPlainObject(json)) &&
                                            (this.isArray(path) ||
                                                this.isString(path))
                                        ) {
                                            return (0, _selectn.default)(
                                                path,
                                                json
                                            );
                                        }

                                        return null;
                                    },
                                    /**
                                     * Filter out keys from an object.
                                     * @param {Object} object      The input object.
                                     * @param  {...any} props      Keys to be omitted from the given object
                                     * @return {Object}            object with keys omitted.
                                     * @example
                                     *
                                     * LangUtils.omitDeep({a: "a", b: "b", c: {b: "b", d: {b: "b", f: "f"}}}, "b");
                                     * //=> {a: "a", c: {d: {f: "f"}}}
                                     */
                                },
                                {
                                    key: "omitDeep",
                                    value: function omitDeep(object) {
                                        for (
                                            var _len2 = arguments.length,
                                                props = new Array(
                                                    _len2 > 1 ? _len2 - 1 : 0
                                                ),
                                                _key2 = 1;
                                            _key2 < _len2;
                                            _key2++
                                        ) {
                                            props[_key2 - 1] = arguments[_key2];
                                        }

                                        return _omitDeepLodash.default.apply(
                                            null,
                                            arguments
                                        );
                                    },
                                },
                            ]);

                            return LangUtils;
                        })();

                    exports.default = LangUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/logger.js":
                /*!***********************!*\
  !*** ./src/logger.js ***!
  \***********************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var Logger =
                        /*#__PURE__*/
                        (function () {
                            function Logger() {
                                _classCallCheck(this, Logger);
                            }

                            _createClass(Logger, null, [
                                {
                                    key: "log",
                                    value: function log() {
                                        if (
                                            _langUtils.default.isObjectLike(
                                                console
                                            ) &&
                                            _langUtils.default.isFunction(
                                                console.log
                                            )
                                        ) {
                                            var _console;

                                            (_console = console).log.apply(
                                                _console,
                                                arguments
                                            );
                                        } else if (
                                            _langUtils.default.isFunction(print)
                                        ) {
                                            // to support nashorn engine
                                            print.apply(void 0, arguments);
                                        }
                                    },
                                },
                            ]);

                            return Logger;
                        })();

                    exports.default = Logger;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/node-utils.js":
                /*!***************************!*\
  !*** ./src/node-utils.js ***!
  \***************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var NodeUtils =
                        /*#__PURE__*/
                        (function () {
                            function NodeUtils() {
                                _classCallCheck(this, NodeUtils);
                            }

                            _createClass(NodeUtils, null, [
                                {
                                    key: "isWindowAvailable",

                                    /**
                                     * Verify if a window object is available.
                                     *
                                     * @return {Boolean}   true if a window object is available, otherwise false
                                     */
                                    value: function isWindowAvailable() {
                                        return _langUtils.default.scriptExecute(
                                            function () {
                                                return Boolean(window);
                                            },
                                            false
                                        );
                                    },
                                },
                            ]);

                            return NodeUtils;
                        })();

                    exports.default = NodeUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/number-utils.js":
                /*!*****************************!*\
  !*** ./src/number-utils.js ***!
  \*****************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var NumberUtils =
                        /*#__PURE__*/
                        (function () {
                            function NumberUtils() {
                                _classCallCheck(this, NumberUtils);
                            }

                            _createClass(NumberUtils, null, [
                                {
                                    key: "isInteger",

                                    /**
                                     * Verify if a given value is an integer.
                                     * @param  {*} x                Accepts any value.
                                     * @return {Boolean}            true if x is an integer, otherwise false
                                     */
                                    value: function isInteger(x) {
                                        return (
                                            _langUtils.default.isNumber(x) &&
                                            (_langUtils.default.isFunction(
                                                Number.isInteger
                                            )
                                                ? Number.isInteger(x)
                                                : Math.floor(x) === x)
                                        );
                                    },
                                },
                            ]);

                            return NumberUtils;
                        })();

                    exports.default = NumberUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/object-utils.js":
                /*!*****************************!*\
  !*** ./src/object-utils.js ***!
  \*****************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    var _arrayUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! array-utils */ "./src/array-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    function getKeysFromProperties(obj) {
                        var internalKeys = [];

                        if (_langUtils.default.isPlainObject(obj)) {
                            for (var i in obj) {
                                if (obj.hasOwnProperty(i)) {
                                    internalKeys.push(i);
                                }
                            }
                        }

                        return internalKeys;
                    }

                    var ObjectUtils =
                        /*#__PURE__*/
                        (function () {
                            function ObjectUtils() {
                                _classCallCheck(this, ObjectUtils);
                            }

                            _createClass(ObjectUtils, null, [
                                {
                                    key: "keys",

                                    /**
                                     * Create an array of keys from a plain object.
                                     *
                                     * @param {Object} obj      Plain object
                                     * @return {Array}          Array with all keys of the given object.
                                     */
                                    value: function keys(obj) {
                                        return _langUtils.default.isPlainObject(
                                            obj
                                        ) &&
                                            _langUtils.default.isFunction(
                                                Object.keys
                                            )
                                            ? Object.keys(obj)
                                            : getKeysFromProperties(obj);
                                    },
                                    /**
                                     * Create an array of values from a plain object.
                                     *
                                     * @param {Object} obj      Plain object
                                     * @return {Array}          Array with all values of the given object.
                                     */
                                },
                                {
                                    key: "values",
                                    value: function values(obj) {
                                        return this.keys(obj).map(function (
                                            key
                                        ) {
                                            return obj[key];
                                        });
                                    },
                                    /**
                                     * Verify if a given key is present in an object.
                                     *
                                     * @param {Object} obj      Plain object.
                                     * @param {String} key      Key value.
                                     * @return {Boolean}        true if key is present, otherwise false.
                                     */
                                },
                                {
                                    key: "containsKey",
                                    value: function containsKey(obj, key) {
                                        return _langUtils.default.isPlainObject(
                                            obj
                                        )
                                            ? obj.hasOwnProperty(key)
                                            : false;
                                    },
                                    /**
                                     * Get a value from an object for a given key, if the key is not present return default value.
                                     *
                                     * @param {Object} obj                  Plain object.
                                     * @param {String} key                  Key value.
                                     * @param {*} [defaultValue = null]     Value to be returned if the key is not present in the object.
                                     * @return {*}                          Value for the given key from the object, or default value.
                                     */
                                },
                                {
                                    key: "getValue",
                                    value: function getValue(
                                        obj,
                                        key,
                                        defaultValue
                                    ) {
                                        return this.containsKey(obj, key)
                                            ? obj[key]
                                            : defaultValue === undefined
                                            ? null
                                            : defaultValue;
                                    },
                                    /**
                                     * Verify if all elements of a given array are plain objects.
                                     *
                                     * @param {Array} objArray                      Array to inspect.
                                     * @param {Boolean} [isRecursive=false]         Verify nested arrays as well.
                                     * @return {Boolean}                            true if array is an array of objects, otherwise false.
                                     *
                                     * @example
                                     *
                                     * ObjectUtils.isPlainObjectArray([{h: 'h'}, [{k: 'k'}]]);
                                     * // => false
                                     *
                                     * ObjectUtils.isPlainObjectArray([{h: 'h'}, [{k: 'k'}]], true);
                                     * // => true
                                     *
                                     */
                                },
                                {
                                    key: "isPlainObjectArray",
                                    value: function isPlainObjectArray(
                                        objArray,
                                        isRecursive
                                    ) {
                                        if (
                                            !_langUtils.default.isArray(
                                                objArray
                                            )
                                        ) {
                                            return false;
                                        }

                                        for (
                                            var i = 0;
                                            i < objArray.length;
                                            i++
                                        ) {
                                            if (
                                                !_langUtils.default.isPlainObject(
                                                    objArray[i]
                                                ) && // support for nested levels of arrays
                                                (!isRecursive ||
                                                    !this.isPlainObjectArray(
                                                        objArray[i],
                                                        isRecursive
                                                    ))
                                            ) {
                                                return false;
                                            }
                                        }

                                        return true;
                                    },
                                    /**
                                     * Merge one object into another.
                                     *
                                     * @param {Object} toDict                       Original object on which merge operation is going to be performed.
                                     * @param {Object} fromDict                     Object to be merged.
                                     * @param {Boolean} [recursive=false]           Perform a recursive merge.
                                     * @param {Boolean} [notOverride=false]         Overide parameters in original object with parameters from
                                     *                                              to-be-merged object. By default override is true.
                                     * @param {Boolean} [ignoreNull=false]          Consider keys with null values. By default null values will be
                                     *                                              merged.
                                     * @param {Boolean} [extendObjectArray=false]   Extend arrays. If true arrays will be extended, if false (default)
                                     *                                              arrays will be overridden based on the index.
                                     *
                                     * @example
                                     *
                                     * let toDict = {a: '1', b: {c: '1', e: null}, f: [{g: '1'}] };
                                     * let fromDict = {b: {c: '2', d: '2', e: '2'}, f: [{g: '2'}] };
                                     * ObjectUtils.merge(toDict, fromDict);
                                     * // => toDict is updated as {a: '1', b: {c: '2', d: '2', e: '2'}, f: [{g: '2'}]}
                                     *
                                     * let toDict = {a: '1', b: {c: '1', e: null}, f: [{g: '1'}] };
                                     * let fromDict = {b: {c: '2', d: '2', e: '2'}, f: [{g: '2'}] };
                                     * ObjectUtils.merge(toDict, fromDict, true, true, true, true);
                                     * // => toDict is updated as {a: '1', b: {c: '1', d: '2', e: '2'}, f: [{g: '1'}, {g: '2'}]}
                                     *
                                     * let toDict = {a: '1', b: {c: '1', e: null}, f: [{g: '1'}] };
                                     * let fromDict = {b: {c: '2', d: '2', e: '2'}, f: [{g: '2'}] };
                                     * ObjectUtils.merge(toDict, fromDict, true, true, false, true);
                                     * // => toDict is updated as {a: '1', b: {c: '1', d: '2', e: null}, f: [{g: '1'}, {g: '2'}]}
                                     */
                                    // TODO: support Symbols and Buffer
                                },
                                {
                                    key: "merge",
                                    value: function merge(
                                        toDict,
                                        fromDict,
                                        recursive,
                                        notOverride,
                                        ignoreNull,
                                        extendObjectArray
                                    ) {
                                        function deepCopyFromDictAttrs(
                                            attrName,
                                            toDict,
                                            fromDict
                                        ) {
                                            for (
                                                var i = 0;
                                                i < toDict[attrName].length;
                                                i++
                                            ) {
                                                if (
                                                    _langUtils.default.isPlainObject(
                                                        toDict[attrName][i]
                                                    ) &&
                                                    _langUtils.default.isPlainObject(
                                                        fromDict[attrName][i]
                                                    )
                                                ) {
                                                    executeMerge(
                                                        toDict[attrName][i],
                                                        fromDict[attrName][i]
                                                    ); // eslint-disable-line no-use-before-define, max-len
                                                }
                                            }
                                        }

                                        function mergeArrays(
                                            toArray,
                                            fromArray,
                                            mergeStartIndex
                                        ) {
                                            fromArray = _langUtils.default.cloneDeep(
                                                fromArray.slice(mergeStartIndex)
                                            ); // null undefined handled by slice

                                            _arrayUtils.default.merge(
                                                toArray,
                                                fromArray
                                            );
                                        }

                                        function addAdditionalNestedObjs(
                                            attrName,
                                            toDict,
                                            fromDict
                                        ) {
                                            var mergeStartIndex =
                                                toDict[attrName].length;
                                            mergeArrays(
                                                toDict[attrName],
                                                fromDict[attrName],
                                                mergeStartIndex
                                            );
                                        }

                                        function executeMerge(
                                            toDict,
                                            fromDict
                                        ) {
                                            if (
                                                toDict &&
                                                fromDict &&
                                                _langUtils.default.isPlainObject(
                                                    toDict
                                                ) &&
                                                _langUtils.default.isPlainObject(
                                                    fromDict
                                                )
                                            ) {
                                                var fromDictKeys = ObjectUtils.keys(
                                                    fromDict
                                                );

                                                for (
                                                    var i = 0;
                                                    i < fromDictKeys.length;
                                                    i++
                                                ) {
                                                    var attrName =
                                                        fromDictKeys[i]; // handle recursive nested objects

                                                    if (
                                                        recursive &&
                                                        _langUtils.default.isPlainObject(
                                                            toDict[attrName]
                                                        ) &&
                                                        _langUtils.default.isPlainObject(
                                                            fromDict[attrName]
                                                        )
                                                    ) {
                                                        // eslint-disable-line max-len
                                                        executeMerge(
                                                            toDict[attrName],
                                                            fromDict[attrName]
                                                        );
                                                    } else if (
                                                        recursive &&
                                                        ObjectUtils.isPlainObjectArray(
                                                            toDict[attrName]
                                                        ) &&
                                                        ObjectUtils.isPlainObjectArray(
                                                            fromDict[attrName]
                                                        )
                                                    ) {
                                                        // handle recusive nested objectArrays
                                                        if (extendObjectArray) {
                                                            // don't override array items
                                                            mergeArrays(
                                                                toDict[
                                                                    attrName
                                                                ],
                                                                fromDict[
                                                                    attrName
                                                                ]
                                                            );
                                                        } else {
                                                            deepCopyFromDictAttrs(
                                                                attrName,
                                                                toDict,
                                                                fromDict
                                                            );
                                                            addAdditionalNestedObjs(
                                                                attrName,
                                                                toDict,
                                                                fromDict
                                                            );
                                                        }
                                                    } else if (
                                                        !notOverride || // checking not override property
                                                        !ObjectUtils.containsKey(
                                                            toDict,
                                                            attrName
                                                        ) || // checking property exists or not
                                                        (ignoreNull &&
                                                            !toDict[attrName])
                                                    ) {
                                                        // checking ignoreNull property
                                                        // if it container object, clone it to detach completely from fromDict
                                                        if (
                                                            _langUtils.default.isObjectLike(
                                                                fromDict[
                                                                    attrName
                                                                ]
                                                            )
                                                        ) {
                                                            toDict[
                                                                attrName
                                                            ] = _langUtils.default.cloneDeep(
                                                                fromDict[
                                                                    attrName
                                                                ]
                                                            );
                                                        } else {
                                                            // other primitives and functions
                                                            toDict[attrName] =
                                                                fromDict[
                                                                    attrName
                                                                ];
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        executeMerge(toDict, fromDict);
                                    },
                                },
                            ]);

                            return ObjectUtils;
                        })();

                    exports.default = ObjectUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/promise-utils.js":
                /*!******************************!*\
  !*** ./src/promise-utils.js ***!
  \******************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var _Promise =
                        typeof Promise === "undefined"
                            ? __webpack_require__(
                                  /*! es6-promise */ "./node_modules/es6-promise/dist/es6-promise.js"
                              ).Promise
                            : Promise;

                    /**
                     * Promise related dev utilities
                     * @module PromiseUtils
                     */
                    var PromiseUtils =
                        /*#__PURE__*/
                        (function () {
                            function PromiseUtils() {
                                _classCallCheck(this, PromiseUtils);
                            }

                            _createClass(PromiseUtils, null, [
                                {
                                    key: "getPromise",

                                    /**
                                     * Create a new promise with given data
                                     *
                                     * @param {*} data          Promise result data.
                                     * @return {Promise}        Dumy promise with given data.
                                     */
                                    value: function getPromise(data) {
                                        return new _Promise(function (
                                            resolve,
                                            reject
                                        ) {
                                            resolve(data);
                                        });
                                    },
                                },
                            ]);

                            return PromiseUtils;
                        })();

                    exports.default = PromiseUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /***/ "./src/string-utils.js":
                /*!*****************************!*\
  !*** ./src/string-utils.js ***!
  \*****************************/
                /*! no static exports found */
                /***/ function (module, exports, __webpack_require__) {
                    "use strict";

                    Object.defineProperty(exports, "__esModule", {
                        value: true,
                    });
                    exports.default = void 0;

                    var _langUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! lang-utils */ "./src/lang-utils.js"
                        )
                    );

                    var _objectUtils = _interopRequireDefault(
                        __webpack_require__(
                            /*! object-utils */ "./src/object-utils.js"
                        )
                    );

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : { default: obj };
                    }

                    function _toConsumableArray(arr) {
                        return (
                            _arrayWithoutHoles(arr) ||
                            _iterableToArray(arr) ||
                            _nonIterableSpread()
                        );
                    }

                    function _nonIterableSpread() {
                        throw new TypeError(
                            "Invalid attempt to spread non-iterable instance"
                        );
                    }

                    function _iterableToArray(iter) {
                        if (
                            Symbol.iterator in Object(iter) ||
                            Object.prototype.toString.call(iter) ===
                                "[object Arguments]"
                        )
                            return Array.from(iter);
                    }

                    function _arrayWithoutHoles(arr) {
                        if (Array.isArray(arr)) {
                            for (
                                var i = 0, arr2 = new Array(arr.length);
                                i < arr.length;
                                i++
                            ) {
                                arr2[i] = arr[i];
                            }
                            return arr2;
                        }
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) {
                            throw new TypeError(
                                "Cannot call a class as a function"
                            );
                        }
                    }

                    function _defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable =
                                descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor)
                                descriptor.writable = true;
                            Object.defineProperty(
                                target,
                                descriptor.key,
                                descriptor
                            );
                        }
                    }

                    function _createClass(
                        Constructor,
                        protoProps,
                        staticProps
                    ) {
                        if (protoProps)
                            _defineProperties(
                                Constructor.prototype,
                                protoProps
                            );
                        if (staticProps)
                            _defineProperties(Constructor, staticProps);
                        return Constructor;
                    }

                    var StringUtils =
                        /*#__PURE__*/
                        (function () {
                            function StringUtils() {
                                _classCallCheck(this, StringUtils);
                            }

                            _createClass(StringUtils, null, [
                                {
                                    key: "interpolate",

                                    /**
                                     * Creates a new interpolated string with a string template and a data object.
                                     * @param {String} str           String template to be interpolated.
                                     * @param {Object} paramsObj     Data object to use in interpolation.
                                     * @return {String}              Interpolated String.
                                     *
                                     * @example
                                     *
                                     * StringUtils.interpolate('${a} ${b}', {a: 5, b: 3});
                                     * // => '5 3'
                                     */
                                    value: function interpolate(
                                        str,
                                        paramsObj
                                    ) {
                                        if (!_langUtils.default.isString(str)) {
                                            return null;
                                        } // copy from https://stackoverflow.com/questions/29182244/convert-a-string-to-a-template-string

                                        if (
                                            _langUtils.default.isPlainObject(
                                                paramsObj
                                            )
                                        ) {
                                            var params = _langUtils.default.cloneDeep(
                                                paramsObj
                                            ); // cleanup number like keys & values

                                            var keys = Object.keys(params);
                                            keys.forEach(function (key) {
                                                if (
                                                    _langUtils.default.isNumberLike(
                                                        key
                                                    )
                                                ) {
                                                    // number like keys
                                                    delete params[key];
                                                } else if (
                                                    _langUtils.default.isObjectLike(
                                                        params[key]
                                                    ) && // filter param value class object
                                                    !_langUtils.default.isArray(
                                                        params[key]
                                                    ) &&
                                                    !_langUtils.default.isPlainObject(
                                                        params[key]
                                                    )
                                                ) {
                                                    delete params[key];
                                                } else if (
                                                    _langUtils.default.isFunction(
                                                        params[key]
                                                    )
                                                ) {
                                                    // filter param value function
                                                    delete params[key];
                                                } else if (
                                                    params[key] === undefined
                                                ) {
                                                    delete params[key];
                                                }
                                            });

                                            var paramKeys = _objectUtils.default.keys(
                                                params
                                            );

                                            var paramValues = _objectUtils.default.values(
                                                params
                                            );

                                            return new (Function.prototype.bind.apply(
                                                Function,
                                                [
                                                    null,
                                                ].concat(
                                                    _toConsumableArray(
                                                        paramKeys
                                                    ),
                                                    [
                                                        "return `".concat(
                                                            str,
                                                            "`;"
                                                        ),
                                                    ]
                                                )
                                            ))().apply(
                                                void 0,
                                                _toConsumableArray(paramValues)
                                            ); // eslint-disable-line no-new-func
                                        }

                                        return str;
                                    },
                                },
                            ]);

                            return StringUtils;
                        })();

                    exports.default = StringUtils;
                    module.exports = exports["default"];

                    /***/
                },

            /******/
        }
    );
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy93ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvYnJhY2tldHMyZG90cy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9jdXJyeTIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9kb3RzcGxpdC5qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9lczYtcHJvbWlzZS9kaXN0L2VzNi1wcm9taXNlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2Zhc3QtYmluZC9iaW5kLWxvb3AuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoLmNsb25lL2luZGV4LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZW1wdHkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzZXF1YWwvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoLnVuaXEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19EYXRhVmlldy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX0hhc2guanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXAuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19NYXBDYWNoZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TZXQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19TdGFjay5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1VpbnQ4QXJyYXkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19XZWFrTWFwLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUVhY2guanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUZpbHRlci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5TGlrZUtleXMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5UHVzaC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXNzb2NJbmRleE9mLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUFzc2lnbi5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25WYWx1ZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDbG9uZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHZXRUYWcuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXAuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYXRpdmUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNTZXQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUtleXMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNldFRvU3RyaW5nLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVNsaWNlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRpbWVzLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRvU3RyaW5nLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuc2V0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUFycmF5QnVmZmVyLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVCdWZmZXIuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVSZWdFeHAuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZVN5bWJvbC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlBcnJheS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlPYmplY3QuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcHlTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3JlSnNEYXRhLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3VzdG9tT21pdENsb25lLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZGVmaW5lUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2ZyZWVHbG9iYWwuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRBbGxLZXlzLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWFwRGF0YS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFByb3RvdHlwZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFJhd1RhZy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRTeW1ib2xzSW4uanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRUYWcuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hDbGVhci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoR2V0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEhhcy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pbml0Q2xvbmVBcnJheS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2luaXRDbG9uZUJ5VGFnLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzSW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzS2V5YWJsZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzTWFza2VkLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVDbGVhci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUdldC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlQ2xlYXIuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWFwQ2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21lbW9pemVDYXBwZWQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5c0luLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vYmplY3RUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJBcmcuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3BhcmVudC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Jvb3QuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3Nob3J0T3V0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tDbGVhci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RhY2tHZXQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0hhcy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nVG9QYXRoLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL190b1NvdXJjZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mbGF0dGVuLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pZGVudGl0eS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNMZW5ndGguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3RMaWtlLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1NldC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTeW1ib2wuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5cy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9sYXN0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZW1vaXplLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9vbWl0LmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9zdHViQXJyYXkuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvb21pdC1kZWVwLWxvZGFzaC9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vbm9kZV9tb2R1bGVzL3NlbGVjdG4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9hcnJheS11dGlscy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9sYW5nLXV0aWxzLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vc3JjL2xvZ2dlci5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9ub2RlLXV0aWxzLmpzIiwid2VicGFjazovL0Btb2RpbC9qc3V0aWxzLy4vc3JjL251bWJlci11dGlscy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9vYmplY3QtdXRpbHMuanMiLCJ3ZWJwYWNrOi8vQG1vZGlsL2pzdXRpbHMvLi9zcmMvcHJvbWlzZS11dGlscy5qcyIsIndlYnBhY2s6Ly9AbW9kaWwvanN1dGlscy8uL3NyYy9zdHJpbmctdXRpbHMuanMiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImJyYWNrZXRzMmRvdHMiLCJSRVBMQUNFX0JSQUNLRVRTIiwiTEZUX1JUX1RSSU1fRE9UUyIsInN0cmluZyIsInRvU3RyaW5nIiwiY2FsbCIsInJlcGxhY2UiLCJiaW5kIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJyZXF1aXJlIiwiY3VycnkyIiwiZm4iLCJzZWxmIiwib3V0IiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiYXBwbHkiLCJ1bmN1cnJ5IiwibG9nIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImNvbG9ycyIsIndpbmRvdyIsInByb2Nlc3MiLCJ0eXBlIiwiX19ud2pzIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidG9Mb3dlckNhc2UiLCJtYXRjaCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiY29uc29sZSIsImZpcmVidWciLCJleGNlcHRpb24iLCJ0YWJsZSIsInBhcnNlSW50IiwiUmVnRXhwIiwiJDEiLCJhcmdzIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiYyIsImNvbG9yIiwic3BsaWNlIiwiaW5kZXgiLCJsYXN0QyIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsImVycm9yIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsImZvcm1hdHRlcnMiLCJqIiwidiIsIkpTT04iLCJzdHJpbmdpZnkiLCJtZXNzYWdlIiwic2V0dXAiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiZGVmYXVsdCIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwiT2JqZWN0Iiwia2V5cyIsImZvckVhY2giLCJrZXkiLCJpbnN0YW5jZXMiLCJuYW1lcyIsInNraXBzIiwic2VsZWN0Q29sb3IiLCJoYXNoIiwiaSIsImNoYXJDb2RlQXQiLCJNYXRoIiwiYWJzIiwicHJldlRpbWUiLCJjdXJyIiwiTnVtYmVyIiwiRGF0ZSIsIm1zIiwicHJldiIsInVuc2hpZnQiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJ2YWwiLCJsb2dGbiIsImRlc3Ryb3kiLCJleHRlbmQiLCJpbml0IiwicHVzaCIsImluZGV4T2YiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInNwbGl0IiwibGVuIiwic3Vic3RyIiwiaW5zdGFuY2UiLCJtYXAiLCJ0b05hbWVzcGFjZSIsImpvaW4iLCJuYW1lIiwidGVzdCIsInJlZ2V4cCIsInN1YnN0cmluZyIsIkVycm9yIiwic3RhY2siLCJkb3RzcGxpdCIsImlkeCIsInN0ciIsImNvbXBhY3QiLCJub3JtYWxpemUiLCJlbmQiLCJ0b2RvdHMiLCJhcnIiLCJnbG9iYWwiLCJmYWN0b3J5Iiwib2JqZWN0T3JGdW5jdGlvbiIsIngiLCJpc0Z1bmN0aW9uIiwiX2lzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJ2ZXJ0eE5leHQiLCJjdXN0b21TY2hlZHVsZXJGbiIsImFzYXAiLCJjYWxsYmFjayIsImFyZyIsInF1ZXVlIiwiZmx1c2giLCJzY2hlZHVsZUZsdXNoIiwic2V0U2NoZWR1bGVyIiwic2NoZWR1bGVGbiIsInNldEFzYXAiLCJhc2FwRm4iLCJicm93c2VyV2luZG93IiwidW5kZWZpbmVkIiwiYnJvd3Nlckdsb2JhbCIsIkJyb3dzZXJNdXRhdGlvbk9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIldlYktpdE11dGF0aW9uT2JzZXJ2ZXIiLCJpc05vZGUiLCJpc1dvcmtlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiaW1wb3J0U2NyaXB0cyIsIk1lc3NhZ2VDaGFubmVsIiwidXNlTmV4dFRpY2siLCJuZXh0VGljayIsInVzZVZlcnR4VGltZXIiLCJ1c2VTZXRUaW1lb3V0IiwidXNlTXV0YXRpb25PYnNlcnZlciIsIml0ZXJhdGlvbnMiLCJvYnNlcnZlciIsIm5vZGUiLCJjcmVhdGVUZXh0Tm9kZSIsIm9ic2VydmUiLCJjaGFyYWN0ZXJEYXRhIiwiZGF0YSIsInVzZU1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQxIiwib25tZXNzYWdlIiwicG9ydDIiLCJwb3N0TWVzc2FnZSIsImdsb2JhbFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiYXR0ZW1wdFZlcnR4IiwidmVydHgiLCJydW5Pbkxvb3AiLCJydW5PbkNvbnRleHQiLCJlIiwidGhlbiIsIm9uRnVsZmlsbG1lbnQiLCJvblJlamVjdGlvbiIsInBhcmVudCIsImNoaWxkIiwiY29uc3RydWN0b3IiLCJub29wIiwiUFJPTUlTRV9JRCIsIm1ha2VQcm9taXNlIiwiX3N0YXRlIiwiaW52b2tlQ2FsbGJhY2siLCJfcmVzdWx0Iiwic3Vic2NyaWJlIiwicmVzb2x2ZSQxIiwib2JqZWN0IiwiQ29uc3RydWN0b3IiLCJwcm9taXNlIiwicmVzb2x2ZSIsInJhbmRvbSIsIlBFTkRJTkciLCJGVUxGSUxMRUQiLCJSRUpFQ1RFRCIsInNlbGZGdWxmaWxsbWVudCIsIlR5cGVFcnJvciIsImNhbm5vdFJldHVybk93biIsInRyeVRoZW4iLCJ0aGVuJCQxIiwidmFsdWUiLCJmdWxmaWxsbWVudEhhbmRsZXIiLCJyZWplY3Rpb25IYW5kbGVyIiwiaGFuZGxlRm9yZWlnblRoZW5hYmxlIiwidGhlbmFibGUiLCJzZWFsZWQiLCJmdWxmaWxsIiwicmVhc29uIiwicmVqZWN0IiwiX2xhYmVsIiwiaGFuZGxlT3duVGhlbmFibGUiLCJoYW5kbGVNYXliZVRoZW5hYmxlIiwibWF5YmVUaGVuYWJsZSIsInB1Ymxpc2hSZWplY3Rpb24iLCJfb25lcnJvciIsInB1Ymxpc2giLCJfc3Vic2NyaWJlcnMiLCJzdWJzY3JpYmVycyIsInNldHRsZWQiLCJkZXRhaWwiLCJoYXNDYWxsYmFjayIsInN1Y2NlZWRlZCIsImluaXRpYWxpemVQcm9taXNlIiwicmVzb2x2ZXIiLCJyZXNvbHZlUHJvbWlzZSIsInJlamVjdFByb21pc2UiLCJpZCIsIm5leHRJZCIsInZhbGlkYXRpb25FcnJvciIsIkVudW1lcmF0b3IiLCJpbnB1dCIsIl9pbnN0YW5jZUNvbnN0cnVjdG9yIiwiX3JlbWFpbmluZyIsIl9lbnVtZXJhdGUiLCJfZWFjaEVudHJ5IiwiZW50cnkiLCJyZXNvbHZlJCQxIiwiX3RoZW4iLCJkaWRFcnJvciIsIl9zZXR0bGVkQXQiLCJQcm9taXNlJDEiLCJfd2lsbFNldHRsZUF0Iiwic3RhdGUiLCJlbnVtZXJhdG9yIiwiYWxsIiwiZW50cmllcyIsInJhY2UiLCJfIiwicmVqZWN0JDEiLCJuZWVkc1Jlc29sdmVyIiwibmVlZHNOZXciLCJQcm9taXNlIiwiY2F0Y2giLCJfY2F0Y2giLCJmaW5hbGx5IiwiX2ZpbmFsbHkiLCJfc2V0U2NoZWR1bGVyIiwiX3NldEFzYXAiLCJfYXNhcCIsInBvbHlmaWxsIiwibG9jYWwiLCJQIiwicHJvbWlzZVRvU3RyaW5nIiwiY2FzdCIsImJvdW5kVGhpcyIsImYiLCJyZXQiLCJyZXRfIiwiYm91bmRBcmdzIiwiYm91bmRMZW4iLCJMQVJHRV9BUlJBWV9TSVpFIiwiSEFTSF9VTkRFRklORUQiLCJNQVhfU0FGRV9JTlRFR0VSIiwiYXJnc1RhZyIsImFycmF5VGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJvYmplY3RUYWciLCJwcm9taXNlVGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwid2Vha01hcFRhZyIsImFycmF5QnVmZmVyVGFnIiwiZGF0YVZpZXdUYWciLCJmbG9hdDMyVGFnIiwiZmxvYXQ2NFRhZyIsImludDhUYWciLCJpbnQxNlRhZyIsImludDMyVGFnIiwidWludDhUYWciLCJ1aW50OENsYW1wZWRUYWciLCJ1aW50MTZUYWciLCJ1aW50MzJUYWciLCJyZVJlZ0V4cENoYXIiLCJyZUZsYWdzIiwicmVJc0hvc3RDdG9yIiwicmVJc1VpbnQiLCJjbG9uZWFibGVUYWdzIiwiZnJlZUdsb2JhbCIsImZyZWVTZWxmIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsImFkZE1hcEVudHJ5IiwicGFpciIsInNldCIsImFkZFNldEVudHJ5IiwiYWRkIiwiYXJyYXlFYWNoIiwiYXJyYXkiLCJpdGVyYXRlZSIsImFycmF5UHVzaCIsInZhbHVlcyIsIm9mZnNldCIsImFycmF5UmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpbml0QWNjdW0iLCJiYXNlVGltZXMiLCJuIiwicmVzdWx0IiwiZ2V0VmFsdWUiLCJpc0hvc3RPYmplY3QiLCJtYXBUb0FycmF5Iiwic2l6ZSIsIm92ZXJBcmciLCJmdW5jIiwidHJhbnNmb3JtIiwic2V0VG9BcnJheSIsImFycmF5UHJvdG8iLCJmdW5jUHJvdG8iLCJvYmplY3RQcm90byIsImNvcmVKc0RhdGEiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsIklFX1BST1RPIiwiZnVuY1RvU3RyaW5nIiwiaGFzT3duUHJvcGVydHkiLCJvYmplY3RUb1N0cmluZyIsInJlSXNOYXRpdmUiLCJCdWZmZXIiLCJTeW1ib2wiLCJVaW50OEFycmF5IiwiZ2V0UHJvdG90eXBlIiwiZ2V0UHJvdG90eXBlT2YiLCJvYmplY3RDcmVhdGUiLCJjcmVhdGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsIm5hdGl2ZUdldFN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJuYXRpdmVJc0J1ZmZlciIsImlzQnVmZmVyIiwibmF0aXZlS2V5cyIsIkRhdGFWaWV3IiwiZ2V0TmF0aXZlIiwiTWFwIiwiU2V0IiwiV2Vha01hcCIsIm5hdGl2ZUNyZWF0ZSIsImRhdGFWaWV3Q3RvclN0cmluZyIsInRvU291cmNlIiwibWFwQ3RvclN0cmluZyIsInByb21pc2VDdG9yU3RyaW5nIiwic2V0Q3RvclN0cmluZyIsIndlYWtNYXBDdG9yU3RyaW5nIiwic3ltYm9sUHJvdG8iLCJzeW1ib2xWYWx1ZU9mIiwidmFsdWVPZiIsIkhhc2giLCJjbGVhciIsImhhc2hDbGVhciIsIl9fZGF0YV9fIiwiaGFzaERlbGV0ZSIsImhhcyIsImhhc2hHZXQiLCJoYXNoSGFzIiwiaGFzaFNldCIsImdldCIsIkxpc3RDYWNoZSIsImxpc3RDYWNoZUNsZWFyIiwibGlzdENhY2hlRGVsZXRlIiwiYXNzb2NJbmRleE9mIiwibGFzdEluZGV4IiwicG9wIiwibGlzdENhY2hlR2V0IiwibGlzdENhY2hlSGFzIiwibGlzdENhY2hlU2V0IiwiTWFwQ2FjaGUiLCJtYXBDYWNoZUNsZWFyIiwibWFwQ2FjaGVEZWxldGUiLCJnZXRNYXBEYXRhIiwibWFwQ2FjaGVHZXQiLCJtYXBDYWNoZUhhcyIsIm1hcENhY2hlU2V0IiwiU3RhY2siLCJzdGFja0NsZWFyIiwic3RhY2tEZWxldGUiLCJzdGFja0dldCIsInN0YWNrSGFzIiwic3RhY2tTZXQiLCJjYWNoZSIsInBhaXJzIiwiYXJyYXlMaWtlS2V5cyIsImluaGVyaXRlZCIsImlzQXJndW1lbnRzIiwiU3RyaW5nIiwic2tpcEluZGV4ZXMiLCJpc0luZGV4IiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImVxIiwiYmFzZUFzc2lnbiIsInNvdXJjZSIsImNvcHlPYmplY3QiLCJiYXNlQ2xvbmUiLCJpc0RlZXAiLCJpc0Z1bGwiLCJjdXN0b21pemVyIiwiaXNPYmplY3QiLCJpc0FyciIsImluaXRDbG9uZUFycmF5IiwiY29weUFycmF5IiwidGFnIiwiZ2V0VGFnIiwiaXNGdW5jIiwiY2xvbmVCdWZmZXIiLCJpbml0Q2xvbmVPYmplY3QiLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInByb3BzIiwiZ2V0QWxsS2V5cyIsInN1YlZhbHVlIiwiYmFzZUNyZWF0ZSIsInByb3RvIiwiYmFzZUdldEFsbEtleXMiLCJrZXlzRnVuYyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImJhc2VLZXlzIiwiaXNQcm90b3R5cGUiLCJidWZmZXIiLCJzbGljZSIsImNvcHkiLCJjbG9uZUFycmF5QnVmZmVyIiwiYXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwiY2xvbmVEYXRhVmlldyIsImRhdGFWaWV3IiwiYnl0ZU9mZnNldCIsImNsb25lTWFwIiwiY2xvbmVGdW5jIiwiY2xvbmVSZWdFeHAiLCJjbG9uZVNldCIsImNsb25lU3ltYm9sIiwic3ltYm9sIiwiY2xvbmVUeXBlZEFycmF5IiwidHlwZWRBcnJheSIsIm5ld1ZhbHVlIiwiZ2V0U3ltYm9scyIsImlzS2V5YWJsZSIsInN0dWJBcnJheSIsIkFycmF5QnVmZmVyIiwiQ3RvciIsImN0b3JTdHJpbmciLCJjbG9uZSIsIm90aGVyIiwiaXNBcnJheUxpa2VPYmplY3QiLCJpc0FycmF5TGlrZSIsImlzTGVuZ3RoIiwiaXNPYmplY3RMaWtlIiwic3R1YkZhbHNlIiwiY2xvbmVEZWVwIiwibm9uRW51bVNoYWRvd3MiLCJpc0VtcHR5IiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiYXN5bmNUYWciLCJudWxsVGFnIiwicHJveHlUYWciLCJ1bmRlZmluZWRUYWciLCJ0eXBlZEFycmF5VGFncyIsImZyZWVQcm9jZXNzIiwibm9kZVV0aWwiLCJiaW5kaW5nIiwibm9kZUlzVHlwZWRBcnJheSIsImlzVHlwZWRBcnJheSIsImFycmF5RmlsdGVyIiwicHJlZGljYXRlIiwicmVzSW5kZXgiLCJhcnJheVNvbWUiLCJiYXNlVW5hcnkiLCJjYWNoZUhhcyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsIlNldENhY2hlIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsImlzQXJnIiwiaXNCdWZmIiwiaXNUeXBlIiwiZ2V0UmF3VGFnIiwiYmFzZUlzQXJndW1lbnRzIiwiYmFzZUlzRXF1YWwiLCJiaXRtYXNrIiwiYmFzZUlzRXF1YWxEZWVwIiwiZXF1YWxGdW5jIiwib2JqSXNBcnIiLCJvdGhJc0FyciIsIm9ialRhZyIsIm90aFRhZyIsIm9iaklzT2JqIiwib3RoSXNPYmoiLCJpc1NhbWVUYWciLCJlcXVhbEFycmF5cyIsImVxdWFsQnlUYWciLCJvYmpJc1dyYXBwZWQiLCJvdGhJc1dyYXBwZWQiLCJvYmpVbndyYXBwZWQiLCJvdGhVbndyYXBwZWQiLCJlcXVhbE9iamVjdHMiLCJiYXNlSXNUeXBlZEFycmF5IiwiaXNQYXJ0aWFsIiwiYXJyTGVuZ3RoIiwib3RoTGVuZ3RoIiwic2VlbiIsImFyclZhbHVlIiwib3RoVmFsdWUiLCJjb21wYXJlZCIsIm90aEluZGV4IiwiY29udmVydCIsIm9ialByb3BzIiwib2JqTGVuZ3RoIiwib3RoUHJvcHMiLCJza2lwQ3RvciIsIm9iakN0b3IiLCJvdGhDdG9yIiwiaXNPd24iLCJ1bm1hc2tlZCIsImlzRXF1YWwiLCJJTkZJTklUWSIsImFycmF5SW5jbHVkZXMiLCJiYXNlSW5kZXhPZiIsImFycmF5SW5jbHVkZXNXaXRoIiwiY29tcGFyYXRvciIsImJhc2VGaW5kSW5kZXgiLCJmcm9tSW5kZXgiLCJmcm9tUmlnaHQiLCJiYXNlSXNOYU4iLCJiYXNlVW5pcSIsImluY2x1ZGVzIiwiaXNDb21tb24iLCJjcmVhdGVTZXQiLCJvdXRlciIsImNvbXB1dGVkIiwic2VlbkluZGV4IiwidW5pcSIsInRoaXNBcmciLCJhcnJheU1hcCIsImJhc2VBc3NpZ25WYWx1ZSIsImtleXNJbiIsImJhc2VBc3NpZ25JbiIsImRlZmluZVByb3BlcnR5IiwiY29weVN5bWJvbHNJbiIsImdldEFsbEtleXNJbiIsImlzTWFwIiwiaXNTZXQiLCJDTE9ORV9ERUVQX0ZMQUciLCJDTE9ORV9GTEFUX0ZMQUciLCJDTE9ORV9TWU1CT0xTX0ZMQUciLCJpc0ZsYXQiLCJpc0ZsYXR0ZW5hYmxlIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiY2FzdFBhdGgiLCJ0b0tleSIsImJhc2VHZXQiLCJwYXRoIiwiYmFzZUlzTWFwIiwiYmFzZUlzU2V0IiwibmF0aXZlS2V5c0luIiwiYmFzZUtleXNJbiIsImlzUHJvdG8iLCJjb25zdGFudCIsImlkZW50aXR5IiwiYmFzZVNldFRvU3RyaW5nIiwiYmFzZVNsaWNlIiwic3RhcnQiLCJpc1N5bWJvbCIsInN5bWJvbFRvU3RyaW5nIiwiYmFzZVRvU3RyaW5nIiwibGFzdCIsImJhc2VVbnNldCIsImlzS2V5Iiwic3RyaW5nVG9QYXRoIiwiYWxsb2NVbnNhZmUiLCJpc05ldyIsImdldFN5bWJvbHNJbiIsImlzUGxhaW5PYmplY3QiLCJjdXN0b21PbWl0Q2xvbmUiLCJmbGF0dGVuIiwib3ZlclJlc3QiLCJzZXRUb1N0cmluZyIsImZsYXRSZXN0Iiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInJlSXNEZWVwUHJvcCIsInJlSXNQbGFpblByb3AiLCJtZW1vaXplIiwiTUFYX01FTU9JWkVfU0laRSIsIm1lbW9pemVDYXBwZWQiLCJ0eXBlcyIsIm5hdGl2ZU1heCIsIm1heCIsIm90aGVyQXJncyIsInNob3J0T3V0IiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJuYXRpdmVOb3ciLCJub3ciLCJjb3VudCIsImxhc3RDYWxsZWQiLCJzdGFtcCIsInJlbWFpbmluZyIsInJlUHJvcE5hbWUiLCJyZUVzY2FwZUNoYXIiLCJudW1iZXIiLCJxdW90ZSIsInN1YlN0cmluZyIsIm5vZGVJc01hcCIsIm9iamVjdEN0b3JTdHJpbmciLCJub2RlSXNTZXQiLCJGVU5DX0VSUk9SX1RFWFQiLCJtZW1vaXplZCIsIkNhY2hlIiwib21pdCIsInBhdGhzIiwicyIsIm0iLCJoIiwiZCIsInkiLCJvcHRpb25zIiwicGFyc2UiLCJpc05hTiIsImxvbmciLCJmbXRMb25nIiwiZm10U2hvcnQiLCJwYXJzZUZsb2F0Iiwicm91bmQiLCJwbHVyYWwiLCJmbG9vciIsImNlaWwiLCJfc2xpY2VkVG9BcnJheSIsInNsaWNlSXRlcmF0b3IiLCJfYXJyIiwiX24iLCJfZCIsIl9lIiwiX2kiLCJpdGVyYXRvciIsIl9zIiwibmV4dCIsImRvbmUiLCJlcnIiLCJvbWl0RGVlcExvZGFzaCIsIm9taXREZWVwT25Pd25Qcm9wcyIsIm9iaiIsIm8iLCJfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uIiwiX2RpZEl0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3JFcnJvciIsIl9pdGVyYXRvciIsIl9zdGVwIiwiX3N0ZXAkdmFsdWUiLCJpc05pbCIsInJldHVybiIsImNhY2hlZFNldFRpbWVvdXQiLCJjYWNoZWRDbGVhclRpbWVvdXQiLCJkZWZhdWx0U2V0VGltb3V0IiwiZGVmYXVsdENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJydW5DbGVhclRpbWVvdXQiLCJtYXJrZXIiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsInJ1biIsIkl0ZW0iLCJ0aXRsZSIsImJyb3dzZXIiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImRvdHRlZCIsInNwbGl0cyIsInNlbGVjdG4iLCJzZWciLCJyZWYiLCJnIiwid2VicGFja1BvbHlmaWxsIiwiZGVwcmVjYXRlIiwiY2hpbGRyZW4iLCJlbnVtZXJhYmxlIiwibCIsIkFycmF5VXRpbHMiLCJ0b0FyciIsImZyb21BcnIiLCJyZW1vdmVBbmRJbnNlcnQiLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJpbnNlcnRBcnIiLCJudW1JdGVtcyIsInNlYXJjaEVsZW1lbnQiLCJpc0VxdWFsRnVuYyIsImlzTnVtYmVyIiwiY2hlY2tUeXBlIiwiTGFuZ1V0aWxzIiwiZGVmYXVsdFZhbHVlIiwic2NyaXB0RXhlY3V0ZSIsIkhUTUxFbGVtZW50IiwiaXNTdHJpbmciLCJCb29sZWFuIiwianNvbiIsIkxvZ2dlciIsInByaW50IiwiTm9kZVV0aWxzIiwiTnVtYmVyVXRpbHMiLCJpc0ludGVnZXIiLCJnZXRLZXlzRnJvbVByb3BlcnRpZXMiLCJpbnRlcm5hbEtleXMiLCJPYmplY3RVdGlscyIsImNvbnRhaW5zS2V5Iiwib2JqQXJyYXkiLCJpc1JlY3Vyc2l2ZSIsImlzUGxhaW5PYmplY3RBcnJheSIsInRvRGljdCIsImZyb21EaWN0IiwicmVjdXJzaXZlIiwibm90T3ZlcnJpZGUiLCJpZ25vcmVOdWxsIiwiZXh0ZW5kT2JqZWN0QXJyYXkiLCJkZWVwQ29weUZyb21EaWN0QXR0cnMiLCJhdHRyTmFtZSIsImV4ZWN1dGVNZXJnZSIsIm1lcmdlQXJyYXlzIiwidG9BcnJheSIsImZyb21BcnJheSIsIm1lcmdlU3RhcnRJbmRleCIsIm1lcmdlIiwiYWRkQWRkaXRpb25hbE5lc3RlZE9ianMiLCJmcm9tRGljdEtleXMiLCJQcm9taXNlVXRpbHMiLCJTdHJpbmdVdGlscyIsInBhcmFtc09iaiIsInBhcmFtcyIsImlzTnVtYmVyTGlrZSIsInBhcmFtS2V5cyIsInBhcmFtVmFsdWVzIl0sIm1hcHBpbmdzIjoiQUFB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LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJAbW9kaWwvanN1dGlsc1wiLCBbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJAbW9kaWwvanN1dGlsc1wiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJAbW9kaWwvanN1dGlsc1wiXSA9IGZhY3RvcnkoKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAiLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL3NyYy9pbmRleC5qc1wiKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyohXG4gKiBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gYnJhY2tldHMyZG90cztcblxuLyohXG4gKiByZWdleHAgcGF0dGVybnMuXG4gKi9cblxudmFyIFJFUExBQ0VfQlJBQ0tFVFMgPSAvXFxbKFteXFxbXFxdXSspXFxdL2c7XG52YXIgTEZUX1JUX1RSSU1fRE9UUyA9IC9eWy5dKnxbLl0qJC9nO1xuXG4vKipcbiAqIENvbnZlcnQgc3RyaW5nIHdpdGggYnJhY2tldCBub3RhdGlvbiB0byBkb3QgcHJvcGVydHkgbm90YXRpb24uXG4gKlxuICogIyMjIEV4YW1wbGVzOlxuICpcbiAqICAgICAgYnJhY2tldHMyZG90cygnZ3JvdXBbMF0uc2VjdGlvbi5hLnNlYXRbM10nKVxuICogICAgICAvLz0+ICdncm91cC4wLnNlY3Rpb24uYS5zZWF0LjMnXG4gKlxuICogICAgICBicmFja2V0czJkb3RzKCdbMF0uc2VjdGlvbi5hLnNlYXRbM10nKVxuICogICAgICAvLz0+ICcwLnNlY3Rpb24uYS5zZWF0LjMnXG4gKlxuICogICAgICBicmFja2V0czJkb3RzKCdwZW9wbGVbKl0uYWdlJylcbiAqICAgICAgLy89PiAncGVvcGxlLiouYWdlJ1xuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc3RyaW5nXG4gKiBvcmlnaW5hbCBzdHJpbmdcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBkb3QvYnJhY2tldC1ub3RhdGlvbiBzdHJpbmdcbiAqL1xuXG5mdW5jdGlvbiBicmFja2V0czJkb3RzKHN0cmluZykge1xuICByZXR1cm4gKHt9KS50b1N0cmluZy5jYWxsKHN0cmluZykgPT0gJ1tvYmplY3QgU3RyaW5nXSdcbiAgICAgICA/IHN0cmluZy5yZXBsYWNlKFJFUExBQ0VfQlJBQ0tFVFMsICcuJDEnKS5yZXBsYWNlKExGVF9SVF9UUklNX0RPVFMsICcnKVxuICAgICAgIDogJydcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG4vKiFcbiAqIGltcG9ydHMuXG4gKi9cblxudmFyIGJpbmQgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCByZXF1aXJlKCdmYXN0LWJpbmQnKVxuXG4vKiFcbiAqIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBjdXJyeTJcblxuLyoqXG4gKiBDdXJyeSBhIGJpbmFyeSBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQmluYXJ5IGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbc2VsZl1cbiAqIEZ1bmN0aW9uIGB0aGlzYCBjb250ZXh0LlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufCp9XG4gKiBJZiBwYXJ0aWFsbHkgYXBwbGllZCwgcmV0dXJuIHVuYXJ5IGZ1bmN0aW9uLCBvdGhlcndpc2UsIHJldHVybiByZXN1bHQgb2YgZnVsbCBhcHBsaWNhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBjdXJyeTIgKGZuLCBzZWxmKSB7XG4gIHZhciBvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBvdXRcblxuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMVxuICAgICAgPyBmbi5hcHBseShzZWxmLCBhcmd1bWVudHMpXG4gICAgICA6IGJpbmQuY2FsbChmbiwgc2VsZiwgYXJndW1lbnRzWzBdKVxuICB9XG5cbiAgb3V0LnVuY3VycnkgPSBmdW5jdGlvbiB1bmN1cnJ5ICgpIHtcbiAgICByZXR1cm4gZm5cbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvZyguLi5hcmdzKSB7XG5cdC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LzksIHdoZXJlXG5cdC8vIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG5cdHJldHVybiB0eXBlb2YgY29uc29sZSA9PT0gJ29iamVjdCcgJiZcblx0XHRjb25zb2xlLmxvZyAmJlxuXHRcdGNvbnNvbGUubG9nKC4uLmFyZ3MpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIEFjdGl2ZSBgZGVidWdgIGluc3RhbmNlcy5cblx0Ki9cblx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzID0gW107XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdC8vIERlYnVnLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuXHRcdC8vIGRlYnVnLnJhd0xvZyA9IHJhd0xvZztcblxuXHRcdC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRjcmVhdGVEZWJ1Zy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnN0IGluZGV4ID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzLmluZGV4T2YodGhpcyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaW5zdGFuY2UgPSBjcmVhdGVEZWJ1Zy5pbnN0YW5jZXNbaV07XG5cdFx0XHRpbnN0YW5jZS5lbmFibGVkID0gY3JlYXRlRGVidWcuZW5hYmxlZChpbnN0YW5jZS5uYW1lc3BhY2UpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuLyoqXG4gKiBUcmFuc2Zvcm0gZG90LWRlbGltaXRlZCBzdHJpbmdzIHRvIGFycmF5IG9mIHN0cmluZ3MuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIERvdC1kZWxpbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQXJyYXkgb2Ygc3RyaW5ncy5cbiAqL1xuXG5mdW5jdGlvbiBkb3RzcGxpdCAoc3RyaW5nKSB7XG4gIHZhciBpZHggPSAtMVxuICB2YXIgc3RyID0gY29tcGFjdChub3JtYWxpemUoc3RyaW5nKS5zcGxpdCgnLicpKVxuICB2YXIgZW5kID0gc3RyLmxlbmd0aFxuICB2YXIgb3V0ID0gW11cblxuICB3aGlsZSAoKytpZHggPCBlbmQpIHtcbiAgICBvdXQucHVzaCh0b2RvdHMoc3RyW2lkeF0pKVxuICB9XG5cbiAgcmV0dXJuIG91dFxufVxuXG4vKipcbiAqIFJlcGxhY2UgZXNjYXBlcyB3aXRoIGEgcGxhY2Vob2xkZXIuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzdHJpbmdcbiAqIERvdC1kZWxpbWl0ZWQgc3RyaW5nLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIERvdC1kZWxpbWl0ZWQgc3RyaW5nIHdpdGggcGxhY2Vob2xkZXJzIGluIHBsYWNlIG9mIGVzY2FwZXMuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplIChzdHJpbmcpIHtcbiAgcmV0dXJuICh0b1N0cmluZy5jYWxsKHN0cmluZykgPT09ICdbb2JqZWN0IFN0cmluZ10nID8gc3RyaW5nIDogJycpLnJlcGxhY2UoL1xcXFxcXC4vZywgJ1xcdWZmZmYnKVxufVxuXG4vKipcbiAqIERyb3AgZW1wdHkgdmFsdWVzIGZyb20gYXJyYXkuXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGFycmF5XG4gKiBBcnJheSBvZiBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQXJyYXkgb2Ygc3RyaW5ncyAoZW1wdHkgdmFsdWVzIGRyb3BwZWQpLlxuICovXG5cbmZ1bmN0aW9uIGNvbXBhY3QgKGFycikge1xuICB2YXIgaWR4ID0gLTFcbiAgdmFyIGVuZCA9IGFyci5sZW5ndGhcbiAgdmFyIG91dCA9IFtdXG5cbiAgd2hpbGUgKCsraWR4IDwgZW5kKSB7XG4gICAgaWYgKGFycltpZHhdKSBvdXQucHVzaChhcnJbaWR4XSlcbiAgfVxuXG4gIHJldHVybiBvdXRcbn1cblxuLyoqXG4gKiBDaGFuZ2UgcGxhY2Vob2xkZXIgdG8gZG90cy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0cmluZ1xuICogRG90LWRlbGltaXRlZCBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogRG90LWRlbGltaXRlZCBzdHJpbmcgd2l0aG91dCBwbGFjZWhvbGRlcnMuXG4gKi9cblxuZnVuY3Rpb24gdG9kb3RzIChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXHVmZmZmL2csICcuJylcbn1cblxuLyohXG4gKiBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZG90c3BsaXRcbiIsIi8qIVxuICogQG92ZXJ2aWV3IGVzNi1wcm9taXNlIC0gYSB0aW55IGltcGxlbWVudGF0aW9uIG9mIFByb21pc2VzL0ErLlxuICogQGNvcHlyaWdodCBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnMgKENvbnZlcnNpb24gdG8gRVM2IEFQSSBieSBKYWtlIEFyY2hpYmFsZClcbiAqIEBsaWNlbnNlICAgTGljZW5zZWQgdW5kZXIgTUlUIGxpY2Vuc2VcbiAqICAgICAgICAgICAgU2VlIGh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9zdGVmYW5wZW5uZXIvZXM2LXByb21pc2UvbWFzdGVyL0xJQ0VOU0VcbiAqIEB2ZXJzaW9uICAgdjQuMi44KzFlNjhkY2U2XG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLkVTNlByb21pc2UgPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG9iamVjdE9yRnVuY3Rpb24oeCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB4O1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdmdW5jdGlvbic7XG59XG5cblxuXG52YXIgX2lzQXJyYXkgPSB2b2lkIDA7XG5pZiAoQXJyYXkuaXNBcnJheSkge1xuICBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG59IGVsc2Uge1xuICBfaXNBcnJheSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkgPSBfaXNBcnJheTtcblxudmFyIGxlbiA9IDA7XG52YXIgdmVydHhOZXh0ID0gdm9pZCAwO1xudmFyIGN1c3RvbVNjaGVkdWxlckZuID0gdm9pZCAwO1xuXG52YXIgYXNhcCA9IGZ1bmN0aW9uIGFzYXAoY2FsbGJhY2ssIGFyZykge1xuICBxdWV1ZVtsZW5dID0gY2FsbGJhY2s7XG4gIHF1ZXVlW2xlbiArIDFdID0gYXJnO1xuICBsZW4gKz0gMjtcbiAgaWYgKGxlbiA9PT0gMikge1xuICAgIC8vIElmIGxlbiBpcyAyLCB0aGF0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byBzY2hlZHVsZSBhbiBhc3luYyBmbHVzaC5cbiAgICAvLyBJZiBhZGRpdGlvbmFsIGNhbGxiYWNrcyBhcmUgcXVldWVkIGJlZm9yZSB0aGUgcXVldWUgaXMgZmx1c2hlZCwgdGhleVxuICAgIC8vIHdpbGwgYmUgcHJvY2Vzc2VkIGJ5IHRoaXMgZmx1c2ggdGhhdCB3ZSBhcmUgc2NoZWR1bGluZy5cbiAgICBpZiAoY3VzdG9tU2NoZWR1bGVyRm4pIHtcbiAgICAgIGN1c3RvbVNjaGVkdWxlckZuKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NoZWR1bGVGbHVzaCgpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2NoZWR1bGVyKHNjaGVkdWxlRm4pIHtcbiAgY3VzdG9tU2NoZWR1bGVyRm4gPSBzY2hlZHVsZUZuO1xufVxuXG5mdW5jdGlvbiBzZXRBc2FwKGFzYXBGbikge1xuICBhc2FwID0gYXNhcEZuO1xufVxuXG52YXIgYnJvd3NlcldpbmRvdyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xudmFyIGJyb3dzZXJHbG9iYWwgPSBicm93c2VyV2luZG93IHx8IHt9O1xudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gYnJvd3Nlckdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGJyb3dzZXJHbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcbnZhciBpc05vZGUgPSB0eXBlb2Ygc2VsZiA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJztcblxuLy8gdGVzdCBmb3Igd2ViIHdvcmtlciBidXQgbm90IGluIElFMTBcbnZhciBpc1dvcmtlciA9IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGltcG9ydFNjcmlwdHMgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIG5vZGVcbmZ1bmN0aW9uIHVzZU5leHRUaWNrKCkge1xuICAvLyBub2RlIHZlcnNpb24gMC4xMC54IGRpc3BsYXlzIGEgZGVwcmVjYXRpb24gd2FybmluZyB3aGVuIG5leHRUaWNrIGlzIHVzZWQgcmVjdXJzaXZlbHlcbiAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jdWpvanMvd2hlbi9pc3N1ZXMvNDEwIGZvciBkZXRhaWxzXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICB9O1xufVxuXG4vLyB2ZXJ0eFxuZnVuY3Rpb24gdXNlVmVydHhUaW1lcigpIHtcbiAgaWYgKHR5cGVvZiB2ZXJ0eE5leHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZlcnR4TmV4dChmbHVzaCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG59XG5cbmZ1bmN0aW9uIHVzZU11dGF0aW9uT2JzZXJ2ZXIoKSB7XG4gIHZhciBpdGVyYXRpb25zID0gMDtcbiAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcbiAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gIG9ic2VydmVyLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbm9kZS5kYXRhID0gaXRlcmF0aW9ucyA9ICsraXRlcmF0aW9ucyAlIDI7XG4gIH07XG59XG5cbi8vIHdlYiB3b3JrZXJcbmZ1bmN0aW9uIHVzZU1lc3NhZ2VDaGFubmVsKCkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VTZXRUaW1lb3V0KCkge1xuICAvLyBTdG9yZSBzZXRUaW1lb3V0IHJlZmVyZW5jZSBzbyBlczYtcHJvbWlzZSB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbiAgLy8gb3RoZXIgY29kZSBtb2RpZnlpbmcgc2V0VGltZW91dCAobGlrZSBzaW5vbi51c2VGYWtlVGltZXJzKCkpXG4gIHZhciBnbG9iYWxTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsU2V0VGltZW91dChmbHVzaCwgMSk7XG4gIH07XG59XG5cbnZhciBxdWV1ZSA9IG5ldyBBcnJheSgxMDAwKTtcbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gcXVldWVbaV07XG4gICAgdmFyIGFyZyA9IHF1ZXVlW2kgKyAxXTtcblxuICAgIGNhbGxiYWNrKGFyZyk7XG5cbiAgICBxdWV1ZVtpXSA9IHVuZGVmaW5lZDtcbiAgICBxdWV1ZVtpICsgMV0gPSB1bmRlZmluZWQ7XG4gIH1cblxuICBsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBhdHRlbXB0VmVydHgoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHZlcnR4ID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKS5yZXF1aXJlKCd2ZXJ0eCcpO1xuICAgIHZlcnR4TmV4dCA9IHZlcnR4LnJ1bk9uTG9vcCB8fCB2ZXJ0eC5ydW5PbkNvbnRleHQ7XG4gICAgcmV0dXJuIHVzZVZlcnR4VGltZXIoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB1c2VTZXRUaW1lb3V0KCk7XG4gIH1cbn1cblxudmFyIHNjaGVkdWxlRmx1c2ggPSB2b2lkIDA7XG4vLyBEZWNpZGUgd2hhdCBhc3luYyBtZXRob2QgdG8gdXNlIHRvIHRyaWdnZXJpbmcgcHJvY2Vzc2luZyBvZiBxdWV1ZWQgY2FsbGJhY2tzOlxuaWYgKGlzTm9kZSkge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlTmV4dFRpY2soKTtcbn0gZWxzZSBpZiAoQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU11dGF0aW9uT2JzZXJ2ZXIoKTtcbn0gZWxzZSBpZiAoaXNXb3JrZXIpIHtcbiAgc2NoZWR1bGVGbHVzaCA9IHVzZU1lc3NhZ2VDaGFubmVsKCk7XG59IGVsc2UgaWYgKGJyb3dzZXJXaW5kb3cgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICBzY2hlZHVsZUZsdXNoID0gYXR0ZW1wdFZlcnR4KCk7XG59IGVsc2Uge1xuICBzY2hlZHVsZUZsdXNoID0gdXNlU2V0VGltZW91dCgpO1xufVxuXG5mdW5jdGlvbiB0aGVuKG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKG5vb3ApO1xuXG4gIGlmIChjaGlsZFtQUk9NSVNFX0lEXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbWFrZVByb21pc2UoY2hpbGQpO1xuICB9XG5cbiAgdmFyIF9zdGF0ZSA9IHBhcmVudC5fc3RhdGU7XG5cblxuICBpZiAoX3N0YXRlKSB7XG4gICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW19zdGF0ZSAtIDFdO1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGludm9rZUNhbGxiYWNrKF9zdGF0ZSwgY2hpbGQsIGNhbGxiYWNrLCBwYXJlbnQuX3Jlc3VsdCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHBhcmVudCwgY2hpbGQsIG9uRnVsZmlsbG1lbnQsIG9uUmVqZWN0aW9uKTtcbiAgfVxuXG4gIHJldHVybiBjaGlsZDtcbn1cblxuLyoqXG4gIGBQcm9taXNlLnJlc29sdmVgIHJldHVybnMgYSBwcm9taXNlIHRoYXQgd2lsbCBiZWNvbWUgcmVzb2x2ZWQgd2l0aCB0aGVcbiAgcGFzc2VkIGB2YWx1ZWAuIEl0IGlzIHNob3J0aGFuZCBmb3IgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICByZXNvbHZlKDEpO1xuICB9KTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBJbnN0ZWFkIG9mIHdyaXRpbmcgdGhlIGFib3ZlLCB5b3VyIGNvZGUgbm93IHNpbXBseSBiZWNvbWVzIHRoZSBmb2xsb3dpbmc6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgxKTtcblxuICBwcm9taXNlLnRoZW4oZnVuY3Rpb24odmFsdWUpe1xuICAgIC8vIHZhbHVlID09PSAxXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIHJlc29sdmVcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FueX0gdmFsdWUgdmFsdWUgdGhhdCB0aGUgcmV0dXJuZWQgcHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkIHdpdGhcbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgdGhhdCB3aWxsIGJlY29tZSBmdWxmaWxsZWQgd2l0aCB0aGUgZ2l2ZW5cbiAgYHZhbHVlYFxuKi9cbmZ1bmN0aW9uIHJlc29sdmUkMShvYmplY3QpIHtcbiAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICBpZiAob2JqZWN0ICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdC5jb25zdHJ1Y3RvciA9PT0gQ29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG5cbiAgdmFyIHByb21pc2UgPSBuZXcgQ29uc3RydWN0b3Iobm9vcCk7XG4gIHJlc29sdmUocHJvbWlzZSwgb2JqZWN0KTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbnZhciBQUk9NSVNFX0lEID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDIpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIFBFTkRJTkcgPSB2b2lkIDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG5cbmZ1bmN0aW9uIHNlbGZGdWxmaWxsbWVudCgpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpO1xufVxuXG5mdW5jdGlvbiBjYW5ub3RSZXR1cm5Pd24oKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuJyk7XG59XG5cbmZ1bmN0aW9uIHRyeVRoZW4odGhlbiQkMSwgdmFsdWUsIGZ1bGZpbGxtZW50SGFuZGxlciwgcmVqZWN0aW9uSGFuZGxlcikge1xuICB0cnkge1xuICAgIHRoZW4kJDEuY2FsbCh2YWx1ZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUZvcmVpZ25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSwgdGhlbiQkMSkge1xuICBhc2FwKGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIHNlYWxlZCA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IHRyeVRoZW4odGhlbiQkMSwgdGhlbmFibGUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHNlYWxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgaWYgKHRoZW5hYmxlICE9PSB2YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bGZpbGwocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChzZWFsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2VhbGVkID0gdHJ1ZTtcblxuICAgICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gICAgfSwgJ1NldHRsZTogJyArIChwcm9taXNlLl9sYWJlbCB8fCAnIHVua25vd24gcHJvbWlzZScpKTtcblxuICAgIGlmICghc2VhbGVkICYmIGVycm9yKSB7XG4gICAgICBzZWFsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICB9XG4gIH0sIHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVPd25UaGVuYWJsZShwcm9taXNlLCB0aGVuYWJsZSkge1xuICBpZiAodGhlbmFibGUuX3N0YXRlID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHRoZW5hYmxlLl9yZXN1bHQpO1xuICB9IGVsc2UgaWYgKHRoZW5hYmxlLl9zdGF0ZSA9PT0gUkVKRUNURUQpIHtcbiAgICByZWplY3QocHJvbWlzZSwgdGhlbmFibGUuX3Jlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgc3Vic2NyaWJlKHRoZW5hYmxlLCB1bmRlZmluZWQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVNYXliZVRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUsIHRoZW4kJDEpIHtcbiAgaWYgKG1heWJlVGhlbmFibGUuY29uc3RydWN0b3IgPT09IHByb21pc2UuY29uc3RydWN0b3IgJiYgdGhlbiQkMSA9PT0gdGhlbiAmJiBtYXliZVRoZW5hYmxlLmNvbnN0cnVjdG9yLnJlc29sdmUgPT09IHJlc29sdmUkMSkge1xuICAgIGhhbmRsZU93blRoZW5hYmxlKHByb21pc2UsIG1heWJlVGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmICh0aGVuJCQxID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoZW4kJDEpKSB7XG4gICAgICBoYW5kbGVGb3JlaWduVGhlbmFibGUocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSwgdGhlbiQkMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZ1bGZpbGwocHJvbWlzZSwgbWF5YmVUaGVuYWJsZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpIHtcbiAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIHNlbGZGdWxmaWxsbWVudCgpKTtcbiAgfSBlbHNlIGlmIChvYmplY3RPckZ1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciB0aGVuJCQxID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgICB0aGVuJCQxID0gdmFsdWUudGhlbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCB2YWx1ZSwgdGhlbiQkMSk7XG4gIH0gZWxzZSB7XG4gICAgZnVsZmlsbChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHVibGlzaFJlamVjdGlvbihwcm9taXNlKSB7XG4gIGlmIChwcm9taXNlLl9vbmVycm9yKSB7XG4gICAgcHJvbWlzZS5fb25lcnJvcihwcm9taXNlLl9yZXN1bHQpO1xuICB9XG5cbiAgcHVibGlzaChwcm9taXNlKTtcbn1cblxuZnVuY3Rpb24gZnVsZmlsbChwcm9taXNlLCB2YWx1ZSkge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBwcm9taXNlLl9yZXN1bHQgPSB2YWx1ZTtcbiAgcHJvbWlzZS5fc3RhdGUgPSBGVUxGSUxMRUQ7XG5cbiAgaWYgKHByb21pc2UuX3N1YnNjcmliZXJzLmxlbmd0aCAhPT0gMCkge1xuICAgIGFzYXAocHVibGlzaCwgcHJvbWlzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVqZWN0KHByb21pc2UsIHJlYXNvbikge1xuICBpZiAocHJvbWlzZS5fc3RhdGUgIT09IFBFTkRJTkcpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcHJvbWlzZS5fc3RhdGUgPSBSRUpFQ1RFRDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gcmVhc29uO1xuXG4gIGFzYXAocHVibGlzaFJlamVjdGlvbiwgcHJvbWlzZSk7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShwYXJlbnQsIGNoaWxkLCBvbkZ1bGZpbGxtZW50LCBvblJlamVjdGlvbikge1xuICB2YXIgX3N1YnNjcmliZXJzID0gcGFyZW50Ll9zdWJzY3JpYmVycztcbiAgdmFyIGxlbmd0aCA9IF9zdWJzY3JpYmVycy5sZW5ndGg7XG5cblxuICBwYXJlbnQuX29uZXJyb3IgPSBudWxsO1xuXG4gIF9zdWJzY3JpYmVyc1tsZW5ndGhdID0gY2hpbGQ7XG4gIF9zdWJzY3JpYmVyc1tsZW5ndGggKyBGVUxGSUxMRURdID0gb25GdWxmaWxsbWVudDtcbiAgX3N1YnNjcmliZXJzW2xlbmd0aCArIFJFSkVDVEVEXSA9IG9uUmVqZWN0aW9uO1xuXG4gIGlmIChsZW5ndGggPT09IDAgJiYgcGFyZW50Ll9zdGF0ZSkge1xuICAgIGFzYXAocHVibGlzaCwgcGFyZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwdWJsaXNoKHByb21pc2UpIHtcbiAgdmFyIHN1YnNjcmliZXJzID0gcHJvbWlzZS5fc3Vic2NyaWJlcnM7XG4gIHZhciBzZXR0bGVkID0gcHJvbWlzZS5fc3RhdGU7XG5cbiAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHZvaWQgMCxcbiAgICAgIGNhbGxiYWNrID0gdm9pZCAwLFxuICAgICAgZGV0YWlsID0gcHJvbWlzZS5fcmVzdWx0O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICBjaGlsZCA9IHN1YnNjcmliZXJzW2ldO1xuICAgIGNhbGxiYWNrID0gc3Vic2NyaWJlcnNbaSArIHNldHRsZWRdO1xuXG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBpbnZva2VDYWxsYmFjayhzZXR0bGVkLCBjaGlsZCwgY2FsbGJhY2ssIGRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfVxuICB9XG5cbiAgcHJvbWlzZS5fc3Vic2NyaWJlcnMubGVuZ3RoID0gMDtcbn1cblxuZnVuY3Rpb24gaW52b2tlQ2FsbGJhY2soc2V0dGxlZCwgcHJvbWlzZSwgY2FsbGJhY2ssIGRldGFpbCkge1xuICB2YXIgaGFzQ2FsbGJhY2sgPSBpc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIHZhbHVlID0gdm9pZCAwLFxuICAgICAgZXJyb3IgPSB2b2lkIDAsXG4gICAgICBzdWNjZWVkZWQgPSB0cnVlO1xuXG4gIGlmIChoYXNDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICB2YWx1ZSA9IGNhbGxiYWNrKGRldGFpbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3VjY2VlZGVkID0gZmFsc2U7XG4gICAgICBlcnJvciA9IGU7XG4gICAgfVxuXG4gICAgaWYgKHByb21pc2UgPT09IHZhbHVlKSB7XG4gICAgICByZWplY3QocHJvbWlzZSwgY2Fubm90UmV0dXJuT3duKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IGRldGFpbDtcbiAgfVxuXG4gIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gUEVORElORykge1xuICAgIC8vIG5vb3BcbiAgfSBlbHNlIGlmIChoYXNDYWxsYmFjayAmJiBzdWNjZWVkZWQpIHtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzdWNjZWVkZWQgPT09IGZhbHNlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGVycm9yKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBGVUxGSUxMRUQpIHtcbiAgICBmdWxmaWxsKHByb21pc2UsIHZhbHVlKTtcbiAgfSBlbHNlIGlmIChzZXR0bGVkID09PSBSRUpFQ1RFRCkge1xuICAgIHJlamVjdChwcm9taXNlLCB2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVByb21pc2UocHJvbWlzZSwgcmVzb2x2ZXIpIHtcbiAgdHJ5IHtcbiAgICByZXNvbHZlcihmdW5jdGlvbiByZXNvbHZlUHJvbWlzZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24gcmVqZWN0UHJvbWlzZShyZWFzb24pIHtcbiAgICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVqZWN0KHByb21pc2UsIGUpO1xuICB9XG59XG5cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBuZXh0SWQoKSB7XG4gIHJldHVybiBpZCsrO1xufVxuXG5mdW5jdGlvbiBtYWtlUHJvbWlzZShwcm9taXNlKSB7XG4gIHByb21pc2VbUFJPTUlTRV9JRF0gPSBpZCsrO1xuICBwcm9taXNlLl9zdGF0ZSA9IHVuZGVmaW5lZDtcbiAgcHJvbWlzZS5fcmVzdWx0ID0gdW5kZWZpbmVkO1xuICBwcm9taXNlLl9zdWJzY3JpYmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0aW9uRXJyb3IoKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoJ0FycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheScpO1xufVxuXG52YXIgRW51bWVyYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRW51bWVyYXRvcihDb25zdHJ1Y3RvciwgaW5wdXQpIHtcbiAgICB0aGlzLl9pbnN0YW5jZUNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuXG4gICAgaWYgKCF0aGlzLnByb21pc2VbUFJPTUlTRV9JRF0pIHtcbiAgICAgIG1ha2VQcm9taXNlKHRoaXMucHJvbWlzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgIHRoaXMuX3JlbWFpbmluZyA9IGlucHV0Lmxlbmd0aDtcblxuICAgICAgdGhpcy5fcmVzdWx0ID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGZ1bGZpbGwodGhpcy5wcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aCB8fCAwO1xuICAgICAgICB0aGlzLl9lbnVtZXJhdGUoaW5wdXQpO1xuICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgZnVsZmlsbCh0aGlzLnByb21pc2UsIHRoaXMuX3Jlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVqZWN0KHRoaXMucHJvbWlzZSwgdmFsaWRhdGlvbkVycm9yKCkpO1xuICAgIH1cbiAgfVxuXG4gIEVudW1lcmF0b3IucHJvdG90eXBlLl9lbnVtZXJhdGUgPSBmdW5jdGlvbiBfZW51bWVyYXRlKGlucHV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IHRoaXMuX3N0YXRlID09PSBQRU5ESU5HICYmIGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZWFjaEVudHJ5KGlucHV0W2ldLCBpKTtcbiAgICB9XG4gIH07XG5cbiAgRW51bWVyYXRvci5wcm90b3R5cGUuX2VhY2hFbnRyeSA9IGZ1bmN0aW9uIF9lYWNoRW50cnkoZW50cnksIGkpIHtcbiAgICB2YXIgYyA9IHRoaXMuX2luc3RhbmNlQ29uc3RydWN0b3I7XG4gICAgdmFyIHJlc29sdmUkJDEgPSBjLnJlc29sdmU7XG5cblxuICAgIGlmIChyZXNvbHZlJCQxID09PSByZXNvbHZlJDEpIHtcbiAgICAgIHZhciBfdGhlbiA9IHZvaWQgMDtcbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgX3RoZW4gPSBlbnRyeS50aGVuO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGVuID09PSB0aGVuICYmIGVudHJ5Ll9zdGF0ZSAhPT0gUEVORElORykge1xuICAgICAgICB0aGlzLl9zZXR0bGVkQXQoZW50cnkuX3N0YXRlLCBpLCBlbnRyeS5fcmVzdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIF90aGVuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX3JlbWFpbmluZy0tO1xuICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSBlbnRyeTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gUHJvbWlzZSQxKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gbmV3IGMobm9vcCk7XG4gICAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwcm9taXNlLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFuZGxlTWF5YmVUaGVuYWJsZShwcm9taXNlLCBlbnRyeSwgX3RoZW4pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3dpbGxTZXR0bGVBdChuZXcgYyhmdW5jdGlvbiAocmVzb2x2ZSQkMSkge1xuICAgICAgICAgIHJldHVybiByZXNvbHZlJCQxKGVudHJ5KTtcbiAgICAgICAgfSksIGkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl93aWxsU2V0dGxlQXQocmVzb2x2ZSQkMShlbnRyeSksIGkpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fc2V0dGxlZEF0ID0gZnVuY3Rpb24gX3NldHRsZWRBdChzdGF0ZSwgaSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXMucHJvbWlzZTtcblxuXG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBQRU5ESU5HKSB7XG4gICAgICB0aGlzLl9yZW1haW5pbmctLTtcblxuICAgICAgaWYgKHN0YXRlID09PSBSRUpFQ1RFRCkge1xuICAgICAgICByZWplY3QocHJvbWlzZSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcmVzdWx0W2ldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3JlbWFpbmluZyA9PT0gMCkge1xuICAgICAgZnVsZmlsbChwcm9taXNlLCB0aGlzLl9yZXN1bHQpO1xuICAgIH1cbiAgfTtcblxuICBFbnVtZXJhdG9yLnByb3RvdHlwZS5fd2lsbFNldHRsZUF0ID0gZnVuY3Rpb24gX3dpbGxTZXR0bGVBdChwcm9taXNlLCBpKSB7XG4gICAgdmFyIGVudW1lcmF0b3IgPSB0aGlzO1xuXG4gICAgc3Vic2NyaWJlKHByb21pc2UsIHVuZGVmaW5lZCwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZW51bWVyYXRvci5fc2V0dGxlZEF0KEZVTEZJTExFRCwgaSwgdmFsdWUpO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIHJldHVybiBlbnVtZXJhdG9yLl9zZXR0bGVkQXQoUkVKRUNURUQsIGksIHJlYXNvbik7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEVudW1lcmF0b3I7XG59KCk7XG5cbi8qKlxuICBgUHJvbWlzZS5hbGxgIGFjY2VwdHMgYW4gYXJyYXkgb2YgcHJvbWlzZXMsIGFuZCByZXR1cm5zIGEgbmV3IHByb21pc2Ugd2hpY2hcbiAgaXMgZnVsZmlsbGVkIHdpdGggYW4gYXJyYXkgb2YgZnVsZmlsbG1lbnQgdmFsdWVzIGZvciB0aGUgcGFzc2VkIHByb21pc2VzLCBvclxuICByZWplY3RlZCB3aXRoIHRoZSByZWFzb24gb2YgdGhlIGZpcnN0IHBhc3NlZCBwcm9taXNlIHRvIGJlIHJlamVjdGVkLiBJdCBjYXN0cyBhbGxcbiAgZWxlbWVudHMgb2YgdGhlIHBhc3NlZCBpdGVyYWJsZSB0byBwcm9taXNlcyBhcyBpdCBydW5zIHRoaXMgYWxnb3JpdGhtLlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZXNvbHZlKDIpO1xuICBsZXQgcHJvbWlzZTMgPSByZXNvbHZlKDMpO1xuICBsZXQgcHJvbWlzZXMgPSBbIHByb21pc2UxLCBwcm9taXNlMiwgcHJvbWlzZTMgXTtcblxuICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbihmdW5jdGlvbihhcnJheSl7XG4gICAgLy8gVGhlIGFycmF5IGhlcmUgd291bGQgYmUgWyAxLCAyLCAzIF07XG4gIH0pO1xuICBgYGBcblxuICBJZiBhbnkgb2YgdGhlIGBwcm9taXNlc2AgZ2l2ZW4gdG8gYGFsbGAgYXJlIHJlamVjdGVkLCB0aGUgZmlyc3QgcHJvbWlzZVxuICB0aGF0IGlzIHJlamVjdGVkIHdpbGwgYmUgZ2l2ZW4gYXMgYW4gYXJndW1lbnQgdG8gdGhlIHJldHVybmVkIHByb21pc2VzJ3NcbiAgcmVqZWN0aW9uIGhhbmRsZXIuIEZvciBleGFtcGxlOlxuXG4gIEV4YW1wbGU6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBsZXQgcHJvbWlzZTEgPSByZXNvbHZlKDEpO1xuICBsZXQgcHJvbWlzZTIgPSByZWplY3QobmV3IEVycm9yKFwiMlwiKSk7XG4gIGxldCBwcm9taXNlMyA9IHJlamVjdChuZXcgRXJyb3IoXCIzXCIpKTtcbiAgbGV0IHByb21pc2VzID0gWyBwcm9taXNlMSwgcHJvbWlzZTIsIHByb21pc2UzIF07XG5cbiAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24oYXJyYXkpe1xuICAgIC8vIENvZGUgaGVyZSBuZXZlciBydW5zIGJlY2F1c2UgdGhlcmUgYXJlIHJlamVjdGVkIHByb21pc2VzIVxuICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgIC8vIGVycm9yLm1lc3NhZ2UgPT09IFwiMlwiXG4gIH0pO1xuICBgYGBcblxuICBAbWV0aG9kIGFsbFxuICBAc3RhdGljXG4gIEBwYXJhbSB7QXJyYXl9IGVudHJpZXMgYXJyYXkgb2YgcHJvbWlzZXNcbiAgQHBhcmFtIHtTdHJpbmd9IGxhYmVsIG9wdGlvbmFsIHN0cmluZyBmb3IgbGFiZWxpbmcgdGhlIHByb21pc2UuXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIGFsbCBgcHJvbWlzZXNgIGhhdmUgYmVlblxuICBmdWxmaWxsZWQsIG9yIHJlamVjdGVkIGlmIGFueSBvZiB0aGVtIGJlY29tZSByZWplY3RlZC5cbiAgQHN0YXRpY1xuKi9cbmZ1bmN0aW9uIGFsbChlbnRyaWVzKSB7XG4gIHJldHVybiBuZXcgRW51bWVyYXRvcih0aGlzLCBlbnRyaWVzKS5wcm9taXNlO1xufVxuXG4vKipcbiAgYFByb21pc2UucmFjZWAgcmV0dXJucyBhIG5ldyBwcm9taXNlIHdoaWNoIGlzIHNldHRsZWQgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZVxuICBmaXJzdCBwYXNzZWQgcHJvbWlzZSB0byBzZXR0bGUuXG5cbiAgRXhhbXBsZTpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlMSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCl7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgcmVzb2x2ZSgncHJvbWlzZSAxJyk7XG4gICAgfSwgMjAwKTtcbiAgfSk7XG5cbiAgbGV0IHByb21pc2UyID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDInKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyByZXN1bHQgPT09ICdwcm9taXNlIDInIGJlY2F1c2UgaXQgd2FzIHJlc29sdmVkIGJlZm9yZSBwcm9taXNlMVxuICAgIC8vIHdhcyByZXNvbHZlZC5cbiAgfSk7XG4gIGBgYFxuXG4gIGBQcm9taXNlLnJhY2VgIGlzIGRldGVybWluaXN0aWMgaW4gdGhhdCBvbmx5IHRoZSBzdGF0ZSBvZiB0aGUgZmlyc3RcbiAgc2V0dGxlZCBwcm9taXNlIG1hdHRlcnMuIEZvciBleGFtcGxlLCBldmVuIGlmIG90aGVyIHByb21pc2VzIGdpdmVuIHRvIHRoZVxuICBgcHJvbWlzZXNgIGFycmF5IGFyZ3VtZW50IGFyZSByZXNvbHZlZCwgYnV0IHRoZSBmaXJzdCBzZXR0bGVkIHByb21pc2UgaGFzXG4gIGJlY29tZSByZWplY3RlZCBiZWZvcmUgdGhlIG90aGVyIHByb21pc2VzIGJlY2FtZSBmdWxmaWxsZWQsIHRoZSByZXR1cm5lZFxuICBwcm9taXNlIHdpbGwgYmVjb21lIHJlamVjdGVkOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UxID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KXtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXNvbHZlKCdwcm9taXNlIDEnKTtcbiAgICB9LCAyMDApO1xuICB9KTtcblxuICBsZXQgcHJvbWlzZTIgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoJ3Byb21pc2UgMicpKTtcbiAgICB9LCAxMDApO1xuICB9KTtcblxuICBQcm9taXNlLnJhY2UoW3Byb21pc2UxLCBwcm9taXNlMl0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBDb2RlIGhlcmUgbmV2ZXIgcnVuc1xuICB9LCBmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHJlYXNvbi5tZXNzYWdlID09PSAncHJvbWlzZSAyJyBiZWNhdXNlIHByb21pc2UgMiBiZWNhbWUgcmVqZWN0ZWQgYmVmb3JlXG4gICAgLy8gcHJvbWlzZSAxIGJlY2FtZSBmdWxmaWxsZWRcbiAgfSk7XG4gIGBgYFxuXG4gIEFuIGV4YW1wbGUgcmVhbC13b3JsZCB1c2UgY2FzZSBpcyBpbXBsZW1lbnRpbmcgdGltZW91dHM6XG5cbiAgYGBgamF2YXNjcmlwdFxuICBQcm9taXNlLnJhY2UoW2FqYXgoJ2Zvby5qc29uJyksIHRpbWVvdXQoNTAwMCldKVxuICBgYGBcblxuICBAbWV0aG9kIHJhY2VcbiAgQHN0YXRpY1xuICBAcGFyYW0ge0FycmF5fSBwcm9taXNlcyBhcnJheSBvZiBwcm9taXNlcyB0byBvYnNlcnZlXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX0gYSBwcm9taXNlIHdoaWNoIHNldHRsZXMgaW4gdGhlIHNhbWUgd2F5IGFzIHRoZSBmaXJzdCBwYXNzZWRcbiAgcHJvbWlzZSB0byBzZXR0bGUuXG4qL1xuZnVuY3Rpb24gcmFjZShlbnRyaWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgaWYgKCFpc0FycmF5KGVudHJpZXMpKSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAoXywgcmVqZWN0KSB7XG4gICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS4nKSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gZW50cmllcy5sZW5ndGg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoZW50cmllc1tpXSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICBgUHJvbWlzZS5yZWplY3RgIHJldHVybnMgYSBwcm9taXNlIHJlamVjdGVkIHdpdGggdGhlIHBhc3NlZCBgcmVhc29uYC5cbiAgSXQgaXMgc2hvcnRoYW5kIGZvciB0aGUgZm9sbG93aW5nOlxuXG4gIGBgYGphdmFzY3JpcHRcbiAgbGV0IHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgIHJlamVjdChuZXcgRXJyb3IoJ1dIT09QUycpKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEluc3RlYWQgb2Ygd3JpdGluZyB0aGUgYWJvdmUsIHlvdXIgY29kZSBub3cgc2ltcGx5IGJlY29tZXMgdGhlIGZvbGxvd2luZzpcblxuICBgYGBqYXZhc2NyaXB0XG4gIGxldCBwcm9taXNlID0gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdXSE9PUFMnKSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAvLyBDb2RlIGhlcmUgZG9lc24ndCBydW4gYmVjYXVzZSB0aGUgcHJvbWlzZSBpcyByZWplY3RlZCFcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyByZWFzb24ubWVzc2FnZSA9PT0gJ1dIT09QUydcbiAgfSk7XG4gIGBgYFxuXG4gIEBtZXRob2QgcmVqZWN0XG4gIEBzdGF0aWNcbiAgQHBhcmFtIHtBbnl9IHJlYXNvbiB2YWx1ZSB0aGF0IHRoZSByZXR1cm5lZCBwcm9taXNlIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aC5cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfSBhIHByb21pc2UgcmVqZWN0ZWQgd2l0aCB0aGUgZ2l2ZW4gYHJlYXNvbmAuXG4qL1xuZnVuY3Rpb24gcmVqZWN0JDEocmVhc29uKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIHZhciBwcm9taXNlID0gbmV3IENvbnN0cnVjdG9yKG5vb3ApO1xuICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgcmV0dXJuIHByb21pc2U7XG59XG5cbmZ1bmN0aW9uIG5lZWRzUmVzb2x2ZXIoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3InKTtcbn1cblxuZnVuY3Rpb24gbmVlZHNOZXcoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7XG59XG5cbi8qKlxuICBQcm9taXNlIG9iamVjdHMgcmVwcmVzZW50IHRoZSBldmVudHVhbCByZXN1bHQgb2YgYW4gYXN5bmNocm9ub3VzIG9wZXJhdGlvbi4gVGhlXG4gIHByaW1hcnkgd2F5IG9mIGludGVyYWN0aW5nIHdpdGggYSBwcm9taXNlIGlzIHRocm91Z2ggaXRzIGB0aGVuYCBtZXRob2QsIHdoaWNoXG4gIHJlZ2lzdGVycyBjYWxsYmFja3MgdG8gcmVjZWl2ZSBlaXRoZXIgYSBwcm9taXNlJ3MgZXZlbnR1YWwgdmFsdWUgb3IgdGhlIHJlYXNvblxuICB3aHkgdGhlIHByb21pc2UgY2Fubm90IGJlIGZ1bGZpbGxlZC5cblxuICBUZXJtaW5vbG9neVxuICAtLS0tLS0tLS0tLVxuXG4gIC0gYHByb21pc2VgIGlzIGFuIG9iamVjdCBvciBmdW5jdGlvbiB3aXRoIGEgYHRoZW5gIG1ldGhvZCB3aG9zZSBiZWhhdmlvciBjb25mb3JtcyB0byB0aGlzIHNwZWNpZmljYXRpb24uXG4gIC0gYHRoZW5hYmxlYCBpcyBhbiBvYmplY3Qgb3IgZnVuY3Rpb24gdGhhdCBkZWZpbmVzIGEgYHRoZW5gIG1ldGhvZC5cbiAgLSBgdmFsdWVgIGlzIGFueSBsZWdhbCBKYXZhU2NyaXB0IHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkLCBhIHRoZW5hYmxlLCBvciBhIHByb21pc2UpLlxuICAtIGBleGNlcHRpb25gIGlzIGEgdmFsdWUgdGhhdCBpcyB0aHJvd24gdXNpbmcgdGhlIHRocm93IHN0YXRlbWVudC5cbiAgLSBgcmVhc29uYCBpcyBhIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHdoeSBhIHByb21pc2Ugd2FzIHJlamVjdGVkLlxuICAtIGBzZXR0bGVkYCB0aGUgZmluYWwgcmVzdGluZyBzdGF0ZSBvZiBhIHByb21pc2UsIGZ1bGZpbGxlZCBvciByZWplY3RlZC5cblxuICBBIHByb21pc2UgY2FuIGJlIGluIG9uZSBvZiB0aHJlZSBzdGF0ZXM6IHBlbmRpbmcsIGZ1bGZpbGxlZCwgb3IgcmVqZWN0ZWQuXG5cbiAgUHJvbWlzZXMgdGhhdCBhcmUgZnVsZmlsbGVkIGhhdmUgYSBmdWxmaWxsbWVudCB2YWx1ZSBhbmQgYXJlIGluIHRoZSBmdWxmaWxsZWRcbiAgc3RhdGUuICBQcm9taXNlcyB0aGF0IGFyZSByZWplY3RlZCBoYXZlIGEgcmVqZWN0aW9uIHJlYXNvbiBhbmQgYXJlIGluIHRoZVxuICByZWplY3RlZCBzdGF0ZS4gIEEgZnVsZmlsbG1lbnQgdmFsdWUgaXMgbmV2ZXIgYSB0aGVuYWJsZS5cblxuICBQcm9taXNlcyBjYW4gYWxzbyBiZSBzYWlkIHRvICpyZXNvbHZlKiBhIHZhbHVlLiAgSWYgdGhpcyB2YWx1ZSBpcyBhbHNvIGFcbiAgcHJvbWlzZSwgdGhlbiB0aGUgb3JpZ2luYWwgcHJvbWlzZSdzIHNldHRsZWQgc3RhdGUgd2lsbCBtYXRjaCB0aGUgdmFsdWUnc1xuICBzZXR0bGVkIHN0YXRlLiAgU28gYSBwcm9taXNlIHRoYXQgKnJlc29sdmVzKiBhIHByb21pc2UgdGhhdCByZWplY3RzIHdpbGxcbiAgaXRzZWxmIHJlamVjdCwgYW5kIGEgcHJvbWlzZSB0aGF0ICpyZXNvbHZlcyogYSBwcm9taXNlIHRoYXQgZnVsZmlsbHMgd2lsbFxuICBpdHNlbGYgZnVsZmlsbC5cblxuXG4gIEJhc2ljIFVzYWdlOlxuICAtLS0tLS0tLS0tLS1cblxuICBgYGBqc1xuICBsZXQgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIC8vIG9uIHN1Y2Nlc3NcbiAgICByZXNvbHZlKHZhbHVlKTtcblxuICAgIC8vIG9uIGZhaWx1cmVcbiAgICByZWplY3QocmVhc29uKTtcbiAgfSk7XG5cbiAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gb24gZnVsZmlsbG1lbnRcbiAgfSwgZnVuY3Rpb24ocmVhc29uKSB7XG4gICAgLy8gb24gcmVqZWN0aW9uXG4gIH0pO1xuICBgYGBcblxuICBBZHZhbmNlZCBVc2FnZTpcbiAgLS0tLS0tLS0tLS0tLS0tXG5cbiAgUHJvbWlzZXMgc2hpbmUgd2hlbiBhYnN0cmFjdGluZyBhd2F5IGFzeW5jaHJvbm91cyBpbnRlcmFjdGlvbnMgc3VjaCBhc1xuICBgWE1MSHR0cFJlcXVlc3Rgcy5cblxuICBgYGBqc1xuICBmdW5jdGlvbiBnZXRKU09OKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3Qpe1xuICAgICAgbGV0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICB4aHIub3BlbignR0VUJywgdXJsKTtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBoYW5kbGVyO1xuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgeGhyLnNlbmQoKTtcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlcigpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gdGhpcy5ET05FKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ2dldEpTT046IGAnICsgdXJsICsgJ2AgZmFpbGVkIHdpdGggc3RhdHVzOiBbJyArIHRoaXMuc3RhdHVzICsgJ10nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0SlNPTignL3Bvc3RzLmpzb24nKS50aGVuKGZ1bmN0aW9uKGpzb24pIHtcbiAgICAvLyBvbiBmdWxmaWxsbWVudFxuICB9LCBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAvLyBvbiByZWplY3Rpb25cbiAgfSk7XG4gIGBgYFxuXG4gIFVubGlrZSBjYWxsYmFja3MsIHByb21pc2VzIGFyZSBncmVhdCBjb21wb3NhYmxlIHByaW1pdGl2ZXMuXG5cbiAgYGBganNcbiAgUHJvbWlzZS5hbGwoW1xuICAgIGdldEpTT04oJy9wb3N0cycpLFxuICAgIGdldEpTT04oJy9jb21tZW50cycpXG4gIF0pLnRoZW4oZnVuY3Rpb24odmFsdWVzKXtcbiAgICB2YWx1ZXNbMF0gLy8gPT4gcG9zdHNKU09OXG4gICAgdmFsdWVzWzFdIC8vID0+IGNvbW1lbnRzSlNPTlxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfSk7XG4gIGBgYFxuXG4gIEBjbGFzcyBQcm9taXNlXG4gIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVyXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQGNvbnN0cnVjdG9yXG4qL1xuXG52YXIgUHJvbWlzZSQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9taXNlKHJlc29sdmVyKSB7XG4gICAgdGhpc1tQUk9NSVNFX0lEXSA9IG5leHRJZCgpO1xuICAgIHRoaXMuX3Jlc3VsdCA9IHRoaXMuX3N0YXRlID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX3N1YnNjcmliZXJzID0gW107XG5cbiAgICBpZiAobm9vcCAhPT0gcmVzb2x2ZXIpIHtcbiAgICAgIHR5cGVvZiByZXNvbHZlciAhPT0gJ2Z1bmN0aW9uJyAmJiBuZWVkc1Jlc29sdmVyKCk7XG4gICAgICB0aGlzIGluc3RhbmNlb2YgUHJvbWlzZSA/IGluaXRpYWxpemVQcm9taXNlKHRoaXMsIHJlc29sdmVyKSA6IG5lZWRzTmV3KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIFRoZSBwcmltYXJ5IHdheSBvZiBpbnRlcmFjdGluZyB3aXRoIGEgcHJvbWlzZSBpcyB0aHJvdWdoIGl0cyBgdGhlbmAgbWV0aG9kLFxuICB3aGljaCByZWdpc3RlcnMgY2FsbGJhY2tzIHRvIHJlY2VpdmUgZWl0aGVyIGEgcHJvbWlzZSdzIGV2ZW50dWFsIHZhbHVlIG9yIHRoZVxuICByZWFzb24gd2h5IHRoZSBwcm9taXNlIGNhbm5vdCBiZSBmdWxmaWxsZWQuXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24odXNlcil7XG4gICAgLy8gdXNlciBpcyBhdmFpbGFibGVcbiAgfSwgZnVuY3Rpb24ocmVhc29uKXtcbiAgICAvLyB1c2VyIGlzIHVuYXZhaWxhYmxlLCBhbmQgeW91IGFyZSBnaXZlbiB0aGUgcmVhc29uIHdoeVxuICB9KTtcbiAgYGBgXG4gICBDaGFpbmluZ1xuICAtLS0tLS0tLVxuICAgVGhlIHJldHVybiB2YWx1ZSBvZiBgdGhlbmAgaXMgaXRzZWxmIGEgcHJvbWlzZS4gIFRoaXMgc2Vjb25kLCAnZG93bnN0cmVhbSdcbiAgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZpcnN0IHByb21pc2UncyBmdWxmaWxsbWVudFxuICBvciByZWplY3Rpb24gaGFuZGxlciwgb3IgcmVqZWN0ZWQgaWYgdGhlIGhhbmRsZXIgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiB1c2VyLm5hbWU7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICByZXR1cm4gJ2RlZmF1bHQgbmFtZSc7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHVzZXJOYW1lKSB7XG4gICAgLy8gSWYgYGZpbmRVc2VyYCBmdWxmaWxsZWQsIGB1c2VyTmFtZWAgd2lsbCBiZSB0aGUgdXNlcidzIG5hbWUsIG90aGVyd2lzZSBpdFxuICAgIC8vIHdpbGwgYmUgYCdkZWZhdWx0IG5hbWUnYFxuICB9KTtcbiAgIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignRm91bmQgdXNlciwgYnV0IHN0aWxsIHVuaGFwcHknKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScpO1xuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIGlmIGBmaW5kVXNlcmAgZnVsZmlsbGVkLCBgcmVhc29uYCB3aWxsIGJlICdGb3VuZCB1c2VyLCBidXQgc3RpbGwgdW5oYXBweScuXG4gICAgLy8gSWYgYGZpbmRVc2VyYCByZWplY3RlZCwgYHJlYXNvbmAgd2lsbCBiZSAnYGZpbmRVc2VyYCByZWplY3RlZCBhbmQgd2UncmUgdW5oYXBweScuXG4gIH0pO1xuICBgYGBcbiAgSWYgdGhlIGRvd25zdHJlYW0gcHJvbWlzZSBkb2VzIG5vdCBzcGVjaWZ5IGEgcmVqZWN0aW9uIGhhbmRsZXIsIHJlamVjdGlvbiByZWFzb25zIHdpbGwgYmUgcHJvcGFnYXRlZCBmdXJ0aGVyIGRvd25zdHJlYW0uXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICB0aHJvdyBuZXcgUGVkYWdvZ2ljYWxFeGNlcHRpb24oJ1Vwc3RyZWFtIGVycm9yJyk7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gbmV2ZXIgcmVhY2hlZFxuICB9KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIG5ldmVyIHJlYWNoZWRcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIC8vIFRoZSBgUGVkZ2Fnb2NpYWxFeGNlcHRpb25gIGlzIHByb3BhZ2F0ZWQgYWxsIHRoZSB3YXkgZG93biB0byBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIEFzc2ltaWxhdGlvblxuICAtLS0tLS0tLS0tLS1cbiAgIFNvbWV0aW1lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gcHJvcGFnYXRlIHRvIGEgZG93bnN0cmVhbSBwcm9taXNlIGNhbiBvbmx5IGJlXG4gIHJldHJpZXZlZCBhc3luY2hyb25vdXNseS4gVGhpcyBjYW4gYmUgYWNoaWV2ZWQgYnkgcmV0dXJuaW5nIGEgcHJvbWlzZSBpbiB0aGVcbiAgZnVsZmlsbG1lbnQgb3IgcmVqZWN0aW9uIGhhbmRsZXIuIFRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCB0aGVuIGJlIHBlbmRpbmdcbiAgdW50aWwgdGhlIHJldHVybmVkIHByb21pc2UgaXMgc2V0dGxlZC4gVGhpcyBpcyBjYWxsZWQgKmFzc2ltaWxhdGlvbiouXG4gICBgYGBqc1xuICBmaW5kVXNlcigpLnRoZW4oZnVuY3Rpb24gKHVzZXIpIHtcbiAgICByZXR1cm4gZmluZENvbW1lbnRzQnlBdXRob3IodXNlcik7XG4gIH0pLnRoZW4oZnVuY3Rpb24gKGNvbW1lbnRzKSB7XG4gICAgLy8gVGhlIHVzZXIncyBjb21tZW50cyBhcmUgbm93IGF2YWlsYWJsZVxuICB9KTtcbiAgYGBgXG4gICBJZiB0aGUgYXNzaW1saWF0ZWQgcHJvbWlzZSByZWplY3RzLCB0aGVuIHRoZSBkb3duc3RyZWFtIHByb21pc2Ugd2lsbCBhbHNvIHJlamVjdC5cbiAgIGBgYGpzXG4gIGZpbmRVc2VyKCkudGhlbihmdW5jdGlvbiAodXNlcikge1xuICAgIHJldHVybiBmaW5kQ29tbWVudHNCeUF1dGhvcih1c2VyKTtcbiAgfSkudGhlbihmdW5jdGlvbiAoY29tbWVudHMpIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIGZ1bGZpbGxzLCB3ZSdsbCBoYXZlIHRoZSB2YWx1ZSBoZXJlXG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAvLyBJZiBgZmluZENvbW1lbnRzQnlBdXRob3JgIHJlamVjdHMsIHdlJ2xsIGhhdmUgdGhlIHJlYXNvbiBoZXJlXG4gIH0pO1xuICBgYGBcbiAgIFNpbXBsZSBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCByZXN1bHQ7XG4gICB0cnkge1xuICAgIHJlc3VsdCA9IGZpbmRSZXN1bHQoKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICBmaW5kUmVzdWx0KGZ1bmN0aW9uKHJlc3VsdCwgZXJyKXtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvLyBmYWlsdXJlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1Y2Nlc3NcbiAgICB9XG4gIH0pO1xuICBgYGBcbiAgIFByb21pc2UgRXhhbXBsZTtcbiAgIGBgYGphdmFzY3JpcHRcbiAgZmluZFJlc3VsdCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAvLyBzdWNjZXNzXG4gIH0sIGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgLy8gZmFpbHVyZVxuICB9KTtcbiAgYGBgXG4gICBBZHZhbmNlZCBFeGFtcGxlXG4gIC0tLS0tLS0tLS0tLS0tXG4gICBTeW5jaHJvbm91cyBFeGFtcGxlXG4gICBgYGBqYXZhc2NyaXB0XG4gIGxldCBhdXRob3IsIGJvb2tzO1xuICAgdHJ5IHtcbiAgICBhdXRob3IgPSBmaW5kQXV0aG9yKCk7XG4gICAgYm9va3MgID0gZmluZEJvb2tzQnlBdXRob3IoYXV0aG9yKTtcbiAgICAvLyBzdWNjZXNzXG4gIH0gY2F0Y2gocmVhc29uKSB7XG4gICAgLy8gZmFpbHVyZVxuICB9XG4gIGBgYFxuICAgRXJyYmFjayBFeGFtcGxlXG4gICBgYGBqc1xuICAgZnVuY3Rpb24gZm91bmRCb29rcyhib29rcykge1xuICAgfVxuICAgZnVuY3Rpb24gZmFpbHVyZShyZWFzb24pIHtcbiAgIH1cbiAgIGZpbmRBdXRob3IoZnVuY3Rpb24oYXV0aG9yLCBlcnIpe1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgIC8vIGZhaWx1cmVcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmluZEJvb29rc0J5QXV0aG9yKGF1dGhvciwgZnVuY3Rpb24oYm9va3MsIGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGZhaWx1cmUoZXJyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZm91bmRCb29rcyhib29rcyk7XG4gICAgICAgICAgICB9IGNhdGNoKHJlYXNvbikge1xuICAgICAgICAgICAgICBmYWlsdXJlKHJlYXNvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2goZXJyb3IpIHtcbiAgICAgICAgZmFpbHVyZShlcnIpO1xuICAgICAgfVxuICAgICAgLy8gc3VjY2Vzc1xuICAgIH1cbiAgfSk7XG4gIGBgYFxuICAgUHJvbWlzZSBFeGFtcGxlO1xuICAgYGBgamF2YXNjcmlwdFxuICBmaW5kQXV0aG9yKCkuXG4gICAgdGhlbihmaW5kQm9va3NCeUF1dGhvcikuXG4gICAgdGhlbihmdW5jdGlvbihib29rcyl7XG4gICAgICAvLyBmb3VuZCBib29rc1xuICB9KS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAgIC8vIHNvbWV0aGluZyB3ZW50IHdyb25nXG4gIH0pO1xuICBgYGBcbiAgIEBtZXRob2QgdGhlblxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvbkZ1bGZpbGxlZFxuICBAcGFyYW0ge0Z1bmN0aW9ufSBvblJlamVjdGVkXG4gIFVzZWZ1bCBmb3IgdG9vbGluZy5cbiAgQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cblxuICAvKipcbiAgYGNhdGNoYCBpcyBzaW1wbHkgc3VnYXIgZm9yIGB0aGVuKHVuZGVmaW5lZCwgb25SZWplY3Rpb24pYCB3aGljaCBtYWtlcyBpdCB0aGUgc2FtZVxuICBhcyB0aGUgY2F0Y2ggYmxvY2sgb2YgYSB0cnkvY2F0Y2ggc3RhdGVtZW50LlxuICBgYGBqc1xuICBmdW5jdGlvbiBmaW5kQXV0aG9yKCl7XG4gIHRocm93IG5ldyBFcnJvcignY291bGRuJ3QgZmluZCB0aGF0IGF1dGhvcicpO1xuICB9XG4gIC8vIHN5bmNocm9ub3VzXG4gIHRyeSB7XG4gIGZpbmRBdXRob3IoKTtcbiAgfSBjYXRjaChyZWFzb24pIHtcbiAgLy8gc29tZXRoaW5nIHdlbnQgd3JvbmdcbiAgfVxuICAvLyBhc3luYyB3aXRoIHByb21pc2VzXG4gIGZpbmRBdXRob3IoKS5jYXRjaChmdW5jdGlvbihyZWFzb24pe1xuICAvLyBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICB9KTtcbiAgYGBgXG4gIEBtZXRob2QgY2F0Y2hcbiAgQHBhcmFtIHtGdW5jdGlvbn0gb25SZWplY3Rpb25cbiAgVXNlZnVsIGZvciB0b29saW5nLlxuICBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuXG5cbiAgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2ggPSBmdW5jdGlvbiBfY2F0Y2gob25SZWplY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICBgZmluYWxseWAgd2lsbCBiZSBpbnZva2VkIHJlZ2FyZGxlc3Mgb2YgdGhlIHByb21pc2UncyBmYXRlIGp1c3QgYXMgbmF0aXZlXG4gICAgdHJ5L2NhdGNoL2ZpbmFsbHkgYmVoYXZlc1xuICBcbiAgICBTeW5jaHJvbm91cyBleGFtcGxlOlxuICBcbiAgICBgYGBqc1xuICAgIGZpbmRBdXRob3IoKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA+IDAuNSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQXV0aG9yKCk7XG4gICAgfVxuICBcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZpbmRBdXRob3IoKTsgLy8gc3VjY2VlZCBvciBmYWlsXG4gICAgfSBjYXRjaChlcnJvcikge1xuICAgICAgcmV0dXJuIGZpbmRPdGhlckF1dGhlcigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBhbHdheXMgcnVuc1xuICAgICAgLy8gZG9lc24ndCBhZmZlY3QgdGhlIHJldHVybiB2YWx1ZVxuICAgIH1cbiAgICBgYGBcbiAgXG4gICAgQXN5bmNocm9ub3VzIGV4YW1wbGU6XG4gIFxuICAgIGBgYGpzXG4gICAgZmluZEF1dGhvcigpLmNhdGNoKGZ1bmN0aW9uKHJlYXNvbil7XG4gICAgICByZXR1cm4gZmluZE90aGVyQXV0aGVyKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbigpe1xuICAgICAgLy8gYXV0aG9yIHdhcyBlaXRoZXIgZm91bmQsIG9yIG5vdFxuICAgIH0pO1xuICAgIGBgYFxuICBcbiAgICBAbWV0aG9kIGZpbmFsbHlcbiAgICBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgIEByZXR1cm4ge1Byb21pc2V9XG4gICovXG5cblxuICBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5ID0gZnVuY3Rpb24gX2ZpbmFsbHkoY2FsbGJhY2spIHtcbiAgICB2YXIgcHJvbWlzZSA9IHRoaXM7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHJvbWlzZS5jb25zdHJ1Y3RvcjtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgcmVhc29uO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfTtcblxuICByZXR1cm4gUHJvbWlzZTtcbn0oKTtcblxuUHJvbWlzZSQxLnByb3RvdHlwZS50aGVuID0gdGhlbjtcblByb21pc2UkMS5hbGwgPSBhbGw7XG5Qcm9taXNlJDEucmFjZSA9IHJhY2U7XG5Qcm9taXNlJDEucmVzb2x2ZSA9IHJlc29sdmUkMTtcblByb21pc2UkMS5yZWplY3QgPSByZWplY3QkMTtcblByb21pc2UkMS5fc2V0U2NoZWR1bGVyID0gc2V0U2NoZWR1bGVyO1xuUHJvbWlzZSQxLl9zZXRBc2FwID0gc2V0QXNhcDtcblByb21pc2UkMS5fYXNhcCA9IGFzYXA7XG5cbi8qZ2xvYmFsIHNlbGYqL1xuZnVuY3Rpb24gcG9seWZpbGwoKSB7XG4gIHZhciBsb2NhbCA9IHZvaWQgMDtcblxuICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsb2NhbCA9IHNlbGY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsID0gRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvbHlmaWxsIGZhaWxlZCBiZWNhdXNlIGdsb2JhbCBvYmplY3QgaXMgdW5hdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudCcpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQID0gbG9jYWwuUHJvbWlzZTtcblxuICBpZiAoUCkge1xuICAgIHZhciBwcm9taXNlVG9TdHJpbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBwcm9taXNlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUC5yZXNvbHZlKCkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGlnbm9yZWRcbiAgICB9XG5cbiAgICBpZiAocHJvbWlzZVRvU3RyaW5nID09PSAnW29iamVjdCBQcm9taXNlXScgJiYgIVAuY2FzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGxvY2FsLlByb21pc2UgPSBQcm9taXNlJDE7XG59XG5cbi8vIFN0cmFuZ2UgY29tcGF0Li5cblByb21pc2UkMS5wb2x5ZmlsbCA9IHBvbHlmaWxsO1xuUHJvbWlzZSQxLlByb21pc2UgPSBQcm9taXNlJDE7XG5cbnJldHVybiBQcm9taXNlJDE7XG5cbn0pKSk7XG5cblxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lczYtcHJvbWlzZS5tYXBcbiIsIid1c2Ugc3RyaWN0Jztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYm91bmRUaGlzKSB7XG4gIHZhciBmID0gdGhpc1xuICAgICwgcmV0XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgIHJldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiByZXQpIHtcbiAgICAgICAgdmFyIHJldF8gPSBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgcmV0dXJuIE9iamVjdChyZXRfKSA9PT0gcmV0X1xuICAgICAgICAgID8gcmV0X1xuICAgICAgICAgIDogdGhpc1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gZi5hcHBseShib3VuZFRoaXMsIGFyZ3VtZW50cylcbiAgICB9XG4gIGVsc2Uge1xuICAgIHZhciBib3VuZEFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBib3VuZEFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldXG5cbiAgICByZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBib3VuZExlbiA9IGJvdW5kQXJncy5sZW5ndGhcbiAgICAgICAgLCBhcmdzID0gbmV3IEFycmF5KGJvdW5kTGVuICsgYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgLCBpXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYm91bmRMZW47IGkrKylcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXVxuICAgICAgZm9yIChpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJnc1tib3VuZExlbiArIGldID0gYXJndW1lbnRzW2ldXG5cbiAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgcmV0KSB7XG4gICAgICAgIHZhciByZXRfID0gZi5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgICByZXR1cm4gT2JqZWN0KHJldF8pID09PSByZXRfXG4gICAgICAgICAgPyByZXRfXG4gICAgICAgICAgOiB0aGlzXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIHJldHVybiBmLmFwcGx5KGJvdW5kVGhpcywgYXJncylcbiAgICB9XG4gIH1cblxuICByZXQucHJvdG90eXBlID0gZi5wcm90b3R5cGVcbiAgcmV0dXJuIHJldFxufVxuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIHN1cHBvcnRlZCBieSBgXy5jbG9uZWAuICovXG52YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbmNsb25lYWJsZVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRhVmlld1RhZ10gPVxuY2xvbmVhYmxlVGFnc1tib29sVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0ZVRhZ10gPVxuY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbaW50MTZUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50MzJUYWddID0gY2xvbmVhYmxlVGFnc1ttYXBUYWddID1cbmNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3JlZ2V4cFRhZ10gPSBjbG9uZWFibGVUYWdzW3NldFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tzdHJpbmdUYWddID0gY2xvbmVhYmxlVGFnc1tzeW1ib2xUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbmNsb25lYWJsZVRhZ3NbdWludDE2VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG5jbG9uZWFibGVUYWdzW2Vycm9yVGFnXSA9IGNsb25lYWJsZVRhZ3NbZnVuY1RhZ10gPVxuY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqXG4gKiBBZGRzIHRoZSBrZXktdmFsdWUgYHBhaXJgIHRvIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gcGFpciBUaGUga2V5LXZhbHVlIHBhaXIgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgbWFwYC5cbiAqL1xuZnVuY3Rpb24gYWRkTWFwRW50cnkobWFwLCBwYWlyKSB7XG4gIC8vIERvbid0IHJldHVybiBgbWFwLnNldGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIG1hcC5zZXQocGFpclswXSwgcGFpclsxXSk7XG4gIHJldHVybiBtYXA7XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYWRkLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgc2V0YC5cbiAqL1xuZnVuY3Rpb24gYWRkU2V0RW50cnkoc2V0LCB2YWx1ZSkge1xuICAvLyBEb24ndCByZXR1cm4gYHNldC5hZGRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBzZXQuYWRkKHZhbHVlKTtcbiAgcmV0dXJuIHNldDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRBY2N1bV0gU3BlY2lmeSB1c2luZyB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gKiAgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UmVkdWNlKGFycmF5LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xuICAvLyBNYW55IGhvc3Qgb2JqZWN0cyBhcmUgYE9iamVjdGAgb2JqZWN0cyB0aGF0IGNhbiBjb2VyY2UgdG8gc3RyaW5nc1xuICAvLyBkZXNwaXRlIGhhdmluZyBpbXByb3Blcmx5IGRlZmluZWQgYHRvU3RyaW5nYCBtZXRob2RzLlxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICBnZXRNYXBEYXRhKHRoaXMsIGtleSkuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNGdWxsXSBTcGVjaWZ5IGEgY2xvbmUgaW5jbHVkaW5nIHN5bWJvbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGlzRGVlcCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgaWYgKGlzSG9zdE9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVPYmplY3QoaXNGdW5jID8ge30gOiB2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGJhc2VDbG9uZSwgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoIWlzQXJyKSB7XG4gICAgdmFyIHByb3BzID0gaXNGdWxsID8gZ2V0QWxsS2V5cyh2YWx1ZSkgOiBrZXlzKHZhbHVlKTtcbiAgfVxuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGlzRGVlcCwgaXNGdWxsLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDcmVhdGUocHJvdG8pIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHByb3RvKSA/IG9iamVjdENyZWF0ZShwcm90bykgOiB7fTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihidWZmZXIubGVuZ3RoKTtcbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIG1hcC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVNYXAobWFwLCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMobWFwVG9BcnJheShtYXApLCB0cnVlKSA6IG1hcFRvQXJyYXkobWFwKTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRNYXBFbnRyeSwgbmV3IG1hcC5jb25zdHJ1Y3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGByZWdleHBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcmVnZXhwIFRoZSByZWdleHAgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgcmVnZXhwLlxuICovXG5mdW5jdGlvbiBjbG9uZVJlZ0V4cChyZWdleHApIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyByZWdleHAuY29uc3RydWN0b3IocmVnZXhwLnNvdXJjZSwgcmVGbGFncy5leGVjKHJlZ2V4cCkpO1xuICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzZXQuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU2V0KHNldCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKHNldFRvQXJyYXkoc2V0KSwgdHJ1ZSkgOiBzZXRUb0FycmF5KHNldCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkU2V0RW50cnksIG5ldyBzZXQuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgb3duIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbCBwcm9wZXJ0aWVzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gbmF0aXZlR2V0U3ltYm9scyA/IG92ZXJBcmcobmF0aXZlR2V0U3ltYm9scywgT2JqZWN0KSA6IHN0dWJBcnJheTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIGFycmF5IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVBcnJheShhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGNsb25lRnVuYywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVNYXAob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIGNsb25lU2V0KG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHwgcmVJc1VpbnQudGVzdCh2YWx1ZSkpICYmXG4gICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uIHRoZVxuICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAqIGFuZCBzdXBwb3J0cyBjbG9uaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsIGRhdGUgb2JqZWN0cywgbWFwcyxcbiAqIG51bWJlcnMsIGBPYmplY3RgIG9iamVjdHMsIHJlZ2V4ZXMsIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZFxuICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAqIGFzIHBsYWluIG9iamVjdHMuIEFuIGVtcHR5IG9iamVjdCBpcyByZXR1cm5lZCBmb3IgdW5jbG9uZWFibGUgdmFsdWVzIHN1Y2hcbiAqIGFzIGVycm9yIG9iamVjdHMsIGZ1bmN0aW9ucywgRE9NIG5vZGVzLCBhbmQgV2Vha01hcHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZURlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coc2hhbGxvd1swXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIGZhbHNlLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsIi8qKlxuICogbG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcXVlcnkub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKlxuICogQWRkcyB0aGUga2V5LXZhbHVlIGBwYWlyYCB0byBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXIgVGhlIGtleS12YWx1ZSBwYWlyIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG1hcGAuXG4gKi9cbmZ1bmN0aW9uIGFkZE1hcEVudHJ5KG1hcCwgcGFpcikge1xuICAvLyBEb24ndCByZXR1cm4gYG1hcC5zZXRgIGJlY2F1c2UgaXQncyBub3QgY2hhaW5hYmxlIGluIElFIDExLlxuICBtYXAuc2V0KHBhaXJbMF0sIHBhaXJbMV0pO1xuICByZXR1cm4gbWFwO1xufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFkZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYHNldGAuXG4gKi9cbmZ1bmN0aW9uIGFkZFNldEVudHJ5KHNldCwgdmFsdWUpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBzZXQuYWRkYCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgc2V0LmFkZCh2YWx1ZSk7XG4gIHJldHVybiBzZXQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX19bJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgY2FjaGUgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoY2FjaGUgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBjYWNoZS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2FjaGUgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRnVsbF0gU3BlY2lmeSBhIGNsb25lIGluY2x1ZGluZyBzeW1ib2xzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIGlmIChpc0hvc3RPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lT2JqZWN0KGlzRnVuYyA/IHt9IDogdmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBiYXNlQ2xvbmUsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKCFpc0Fycikge1xuICAgIHZhciBwcm9wcyA9IGlzRnVsbCA/IGdldEFsbEtleXModmFsdWUpIDoga2V5cyh2YWx1ZSk7XG4gIH1cbiAgYXJyYXlFYWNoKHByb3BzIHx8IHZhbHVlLCBmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgIHN1YlZhbHVlID0gdmFsdWVba2V5XTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBhc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBpc0RlZXAsIGlzRnVsbCwgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlQ3JlYXRlKHByb3RvKSB7XG4gIHJldHVybiBpc09iamVjdChwcm90bykgPyBvYmplY3RDcmVhdGUocHJvdG8pIDoge307XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBidWZmZXIuY29uc3RydWN0b3IoYnVmZmVyLmxlbmd0aCk7XG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBtYXAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lTWFwKG1hcCwgaXNEZWVwLCBjbG9uZUZ1bmMpIHtcbiAgdmFyIGFycmF5ID0gaXNEZWVwID8gY2xvbmVGdW5jKG1hcFRvQXJyYXkobWFwKSwgdHJ1ZSkgOiBtYXBUb0FycmF5KG1hcCk7XG4gIHJldHVybiBhcnJheVJlZHVjZShhcnJheSwgYWRkTWFwRW50cnksIG5ldyBtYXAuY29uc3RydWN0b3IpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBzZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc2V0LlxuICovXG5mdW5jdGlvbiBjbG9uZVNldChzZXQsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhzZXRUb0FycmF5KHNldCksIHRydWUpIDogc2V0VG9BcnJheShzZXQpO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZFNldEVudHJ5LCBuZXcgc2V0LmNvbnN0cnVjdG9yKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGB0eXBlZEFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHR5cGVkQXJyYXkgVGhlIHR5cGVkIGFycmF5IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCB0eXBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcih0eXBlZEFycmF5LmJ1ZmZlcikgOiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMgdG8gY29weS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICBvYmplY3QgfHwgKG9iamVjdCA9IHt9KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICA/IGN1c3RvbWl6ZXIob2JqZWN0W2tleV0sIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUgPT09IHVuZGVmaW5lZCA/IHNvdXJjZVtrZXldIDogbmV3VmFsdWUpO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2wgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2wgcHJvcGVydGllcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9IG5hdGl2ZUdldFN5bWJvbHMgPyBvdmVyQXJnKG5hdGl2ZUdldFN5bWJvbHMsIE9iamVjdCkgOiBzdHViQXJyYXk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgLy8gQWRkIHByb3BlcnRpZXMgYXNzaWduZWQgYnkgYFJlZ0V4cCNleGVjYC5cbiAgaWYgKGxlbmd0aCAmJiB0eXBlb2YgYXJyYXlbMF0gPT0gJ3N0cmluZycgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgJ2luZGV4JykpIHtcbiAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSBhcnJheS5pbnB1dDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBjbG9uZUZ1bmMsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lTWFwKG9iamVjdCwgaXNEZWVwLCBjbG9uZUZ1bmMpO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVNldChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCB0cnVlLCB0cnVlKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZURlZXA7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG4vKiogRGV0ZWN0IGlmIHByb3BlcnRpZXMgc2hhZG93aW5nIHRob3NlIG9uIGBPYmplY3QucHJvdG90eXBlYCBhcmUgbm9uLWVudW1lcmFibGUuICovXG52YXIgbm9uRW51bVNoYWRvd3MgPSAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7ICd2YWx1ZU9mJzogMSB9LCAndmFsdWVPZicpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExLFxuLy8gZm9yIGRhdGEgdmlld3MgaW4gRWRnZSA8IDE0LCBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcy5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fCBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgIHJldHVybiAhdmFsdWUubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICBpZiAodGFnID09IG1hcFRhZyB8fCB0YWcgPT0gc2V0VGFnKSB7XG4gICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICB9XG4gIGlmIChub25FbnVtU2hhZG93cyB8fCBpc1Byb3RvdHlwZSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gIW5hdGl2ZUtleXModmFsdWUpLmxlbmd0aDtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA4LTkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGlzT2JqZWN0KHZhbHVlKSA/IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNFbXB0eTtcbiIsIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIHNwZWNpZnlpbmcgYW4gaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCAtIDEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYU5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbnVtYmVyIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA/IGVudHJpZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA/IHZhbHVlcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gKGlzRnVuY3Rpb24odmFsdWUpIHx8IGlzSG9zdE9iamVjdCh2YWx1ZSkpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXQgb2JqZWN0IG9mIGB2YWx1ZXNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhZGQgdG8gdGhlIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gKi9cbnZhciBjcmVhdGVTZXQgPSAhKFNldCAmJiAoMSAvIHNldFRvQXJyYXkobmV3IFNldChbLC0wXSkpWzFdKSA9PSBJTkZJTklUWSkgPyBub29wIDogZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZHVwbGljYXRlLWZyZWUgdmVyc2lvbiBvZiBhbiBhcnJheSwgdXNpbmdcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGluIHdoaWNoIG9ubHkgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgZWFjaFxuICogZWxlbWVudCBpcyBrZXB0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VVbmlxKGFycmF5KVxuICAgIDogW107XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLm5vb3ApO1xuICogLy8gPT4gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICovXG5mdW5jdGlvbiBub29wKCkge1xuICAvLyBObyBvcGVyYXRpb24gcGVyZm9ybWVkLlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaXE7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBzdGFja0NsZWFyID0gcmVxdWlyZSgnLi9fc3RhY2tDbGVhcicpLFxuICAgIHN0YWNrRGVsZXRlID0gcmVxdWlyZSgnLi9fc3RhY2tEZWxldGUnKSxcbiAgICBzdGFja0dldCA9IHJlcXVpcmUoJy4vX3N0YWNrR2V0JyksXG4gICAgc3RhY2tIYXMgPSByZXF1aXJlKCcuL19zdGFja0hhcycpLFxuICAgIHN0YWNrU2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0YWNrO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bWJvbDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVpbnQ4QXJyYXk7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWFrTWFwO1xuIiwiLyoqXG4gKiBBIGZhc3RlciBhbHRlcm5hdGl2ZSB0byBgRnVuY3Rpb24jYXBwbHlgLCB0aGlzIGZ1bmN0aW9uIGludm9rZXMgYGZ1bmNgXG4gKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAqL1xuZnVuY3Rpb24gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncykge1xuICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgY2FzZSAwOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcpO1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICB9XG4gIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcGx5O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RWFjaDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUZpbHRlcjtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEFzc2lnbnMgYHZhbHVlYCB0byBga2V5YCBvZiBgb2JqZWN0YCBpZiB0aGUgZXhpc3RpbmcgdmFsdWUgaXMgbm90IGVxdWl2YWxlbnRcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBlcShvYmpWYWx1ZSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnblZhbHVlO1xuIiwidmFyIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc29jSW5kZXhPZjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ247XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbkluO1xuIiwidmFyIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICogdmFsdWUgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICd2YWx1ZSc6IHZhbHVlLFxuICAgICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduVmFsdWU7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbicpLFxuICAgIGJhc2VBc3NpZ25JbiA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25JbicpLFxuICAgIGNsb25lQnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVCdWZmZXInKSxcbiAgICBjb3B5QXJyYXkgPSByZXF1aXJlKCcuL19jb3B5QXJyYXknKSxcbiAgICBjb3B5U3ltYm9scyA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzJyksXG4gICAgY29weVN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2NvcHlTeW1ib2xzSW4nKSxcbiAgICBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpLFxuICAgIGdldEFsbEtleXNJbiA9IHJlcXVpcmUoJy4vX2dldEFsbEtleXNJbicpLFxuICAgIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGluaXRDbG9uZUFycmF5ID0gcmVxdWlyZSgnLi9faW5pdENsb25lQXJyYXknKSxcbiAgICBpbml0Q2xvbmVCeVRhZyA9IHJlcXVpcmUoJy4vX2luaXRDbG9uZUJ5VGFnJyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzTWFwID0gcmVxdWlyZSgnLi9pc01hcCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzU2V0ID0gcmVxdWlyZSgnLi9pc1NldCcpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gKiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIERlZXAgY2xvbmVcbiAqICAyIC0gRmxhdHRlbiBpbmhlcml0ZWQgcHJvcGVydGllc1xuICogIDQgLSBDbG9uZSBzeW1ib2xzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICogQHBhcmFtIHtzdHJpbmd9IFtrZXldIFRoZSBrZXkgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgcGFyZW50IG9iamVjdCBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0LFxuICAgICAgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRyxcbiAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICBpc0Z1bGwgPSBiaXRtYXNrICYgQ0xPTkVfU1lNQk9MU19GTEFHO1xuXG4gIGlmIChjdXN0b21pemVyKSB7XG4gICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICB9XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIGlmIChpc0Fycikge1xuICAgIHJlc3VsdCA9IGluaXRDbG9uZUFycmF5KHZhbHVlKTtcbiAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG5cbiAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgfVxuICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IChpc0Z1bmMgJiYgIW9iamVjdCkpIHtcbiAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBpc0ZsYXRcbiAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdCwgdmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFjbG9uZWFibGVUYWdzW3RhZ10pIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBpbml0Q2xvbmVCeVRhZyh2YWx1ZSwgdGFnLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICByZXN1bHQuYWRkKGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3ViVmFsdWUsIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNsb25lO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG8gVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG52YXIgYmFzZUNyZWF0ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgcmV0dXJuIGZ1bmN0aW9uKHByb3RvKSB7XG4gICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgfVxuICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICBvYmplY3QucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDcmVhdGU7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXRBbGxLZXlzO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGdldFJhd1RhZyA9IHJlcXVpcmUoJy4vX2dldFJhd1RhZycpLFxuICAgIG9iamVjdFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fb2JqZWN0VG9TdHJpbmcnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldFRhZztcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzQXJndW1lbnRzO1xuIiwidmFyIGdldFRhZyA9IHJlcXVpcmUoJy4vX2dldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc01hcDtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpLFxuICAgIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5cztcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5c0luID0gcmVxdWlyZSgnLi9fbmF0aXZlS2V5c0luJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUtleXNJbjtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2xpY2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUaW1lcztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzU3ltYm9sID0gcmVxdWlyZSgnLi9pc1N5bWJvbCcpO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VUb1N0cmluZztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGxhc3QgPSByZXF1aXJlKCcuL2xhc3QnKSxcbiAgICBwYXJlbnQgPSByZXF1aXJlKCcuL19wYXJlbnQnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5zZXRgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgb2JqZWN0ID0gcGFyZW50KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5zZXQ7XG4iLCJ2YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzS2V5ID0gcmVxdWlyZSgnLi9faXNLZXknKSxcbiAgICBzdHJpbmdUb1BhdGggPSByZXF1aXJlKCcuL19zdHJpbmdUb1BhdGgnKSxcbiAgICB0b1N0cmluZyA9IHJlcXVpcmUoJy4vdG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYXN0UGF0aDtcbiIsInZhciBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVBcnJheUJ1ZmZlcjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgIGBidWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge0J1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgaWYgKGlzRGVlcCkge1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gYnVmZmVyLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGFsbG9jVW5zYWZlID8gYWxsb2NVbnNhZmUobGVuZ3RoKSA6IG5ldyBidWZmZXIuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQnVmZmVyO1xuIiwidmFyIGNsb25lQXJyYXlCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUFycmF5QnVmZmVyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEYXRhVmlldztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVSZWdFeHA7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVN5bWJvbDtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lVHlwZWRBcnJheTtcbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlBcnJheTtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyk7XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlPYmplY3Q7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpO1xuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHM7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBnZXRTeW1ib2xzSW4gPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzSW4nKTtcblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcHlTeW1ib2xzSW47XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb3JlSnNEYXRhO1xuIiwidmFyIGlzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2lzUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICogb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gKi9cbmZ1bmN0aW9uIGN1c3RvbU9taXRDbG9uZSh2YWx1ZSkge1xuICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjdXN0b21PbWl0Q2xvbmU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIGZsYXR0ZW4gPSByZXF1aXJlKCcuL2ZsYXR0ZW4nKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZCwgZmxhdHRlbiksIGZ1bmMgKyAnJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdFJlc3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZyZWVHbG9iYWw7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFsbEtleXM7XG4iLCJ2YXIgYmFzZUdldEFsbEtleXMgPSByZXF1aXJlKCcuL19iYXNlR2V0QWxsS2V5cycpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzSW4sIGdldFN5bWJvbHNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5c0luO1xuIiwidmFyIGlzS2V5YWJsZSA9IHJlcXVpcmUoJy4vX2lzS2V5YWJsZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFwRGF0YTtcbiIsInZhciBiYXNlSXNOYXRpdmUgPSByZXF1aXJlKCcuL19iYXNlSXNOYXRpdmUnKSxcbiAgICBnZXRWYWx1ZSA9IHJlcXVpcmUoJy4vX2dldFZhbHVlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TmF0aXZlO1xuIiwidmFyIG92ZXJBcmcgPSByZXF1aXJlKCcuL19vdmVyQXJnJyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFByb3RvdHlwZTtcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFJhd1RhZztcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgc3R1YkFycmF5ID0gcmVxdWlyZSgnLi9zdHViQXJyYXknKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHM7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFN5bWJvbHNJbjtcbiIsInZhciBEYXRhVmlldyA9IHJlcXVpcmUoJy4vX0RhdGFWaWV3JyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgUHJvbWlzZSA9IHJlcXVpcmUoJy4vX1Byb21pc2UnKSxcbiAgICBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBXZWFrTWFwID0gcmVxdWlyZSgnLi9fV2Vha01hcCcpLFxuICAgIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgdG9Tb3VyY2UgPSByZXF1aXJlKCcuL190b1NvdXJjZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFRhZztcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFZhbHVlO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoQ2xlYXI7XG4iLCIvKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hEZWxldGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoR2V0O1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaEhhcztcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaFNldDtcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQXJyYXk7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKSxcbiAgICBjbG9uZURhdGFWaWV3ID0gcmVxdWlyZSgnLi9fY2xvbmVEYXRhVmlldycpLFxuICAgIGNsb25lUmVnRXhwID0gcmVxdWlyZSgnLi9fY2xvbmVSZWdFeHAnKSxcbiAgICBjbG9uZVN5bWJvbCA9IHJlcXVpcmUoJy4vX2Nsb25lU3ltYm9sJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRDbG9uZUJ5VGFnO1xuIiwidmFyIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNQcm90b3R5cGUgPSByZXF1aXJlKCcuL19pc1Byb3RvdHlwZScpO1xuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuICh0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgIWlzUHJvdG90eXBlKG9iamVjdCkpXG4gICAgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKVxuICAgIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lT2JqZWN0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0luZGV4O1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTbGljZSA9IHJlcXVpcmUoJy4vX2Jhc2VTbGljZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcGFyZW50IHZhbHVlLlxuICovXG5mdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLmxlbmd0aCA8IDIgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgYmFzZVNsaWNlKHBhdGgsIDAsIC0xKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50O1xuIiwidmFyIGZyZWVHbG9iYWwgPSByZXF1aXJlKCcuL19mcmVlR2xvYmFsJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxubW9kdWxlLmV4cG9ydHMgPSByb290O1xuIiwidmFyIGJhc2VTZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VTZXRUb1N0cmluZycpLFxuICAgIHNob3J0T3V0ID0gcmVxdWlyZSgnLi9fc2hvcnRPdXQnKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzZXRUb1N0cmluZztcbiIsIi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU5vdyA9IERhdGUubm93O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0J2xsIHNob3J0IG91dCBhbmQgaW52b2tlIGBpZGVudGl0eWAgaW5zdGVhZFxuICogb2YgYGZ1bmNgIHdoZW4gaXQncyBjYWxsZWQgYEhPVF9DT1VOVGAgb3IgbW9yZSB0aW1lcyBpbiBgSE9UX1NQQU5gXG4gKiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc2hvcnRhYmxlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gIHZhciBjb3VudCA9IDAsXG4gICAgICBsYXN0Q2FsbGVkID0gMDtcblxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksXG4gICAgICAgIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG5cbiAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgaWYgKHJlbWFpbmluZyA+IDApIHtcbiAgICAgIGlmICgrK2NvdW50ID49IEhPVF9DT1VOVCkge1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb3VudCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG9ydE91dDtcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKTtcblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0NsZWFyO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrRGVsZXRlO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrR2V0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0hhcztcbiIsInZhciBMaXN0Q2FjaGUgPSByZXF1aXJlKCcuL19MaXN0Q2FjaGUnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0YWNrU2V0O1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29uc3RhbnQ7XG4iLCIvKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyk7XG5cbi8qKlxuICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZmxhdHRlbihbMSwgWzIsIFszLCBbNF1dLCA1XV0pO1xuICogLy8gPT4gWzEsIDIsIFszLCBbNF1dLCA1XVxuICovXG5mdW5jdGlvbiBmbGF0dGVuKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZsYXR0ZW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290JyksXG4gICAgc3R1YkZhbHNlID0gcmVxdWlyZSgnLi9zdHViRmFsc2UnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmZmVyO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0Jyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvbjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0xlbmd0aDtcbiIsInZhciBiYXNlSXNNYXAgPSByZXF1aXJlKCcuL19iYXNlSXNNYXAnKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBub2RlVXRpbCA9IHJlcXVpcmUoJy4vX25vZGVVdGlsJyk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNNYXA7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0TGlrZTtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGdldFByb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2dldFByb3RvdHlwZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGluZmVyIHRoZSBgT2JqZWN0YCBjb25zdHJ1Y3Rvci4gKi9cbnZhciBvYmplY3RDdG9yU3RyaW5nID0gZnVuY1RvU3RyaW5nLmNhbGwoT2JqZWN0KTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjguMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogfVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gIGlmIChwcm90byA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBDdG9yID0gaGFzT3duUHJvcGVydHkuY2FsbChwcm90bywgJ2NvbnN0cnVjdG9yJykgJiYgcHJvdG8uY29uc3RydWN0b3I7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuIiwidmFyIGJhc2VJc1NldCA9IHJlcXVpcmUoJy4vX2Jhc2VJc1NldCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFNldGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc2V0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTZXQobmV3IFNldCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1NldChuZXcgV2Vha1NldCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNTZXQgPSBub2RlSXNTZXQgPyBiYXNlVW5hcnkobm9kZUlzU2V0KSA6IGJhc2VJc1NldDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1NldDtcbiIsInZhciBiYXNlR2V0VGFnID0gcmVxdWlyZSgnLi9fYmFzZUdldFRhZycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1N5bWJvbDtcbiIsInZhciBiYXNlSXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fYmFzZUlzVHlwZWRBcnJheScpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlZEFycmF5O1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXMgPSByZXF1aXJlKCcuL19iYXNlS2V5cycpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzO1xuIiwidmFyIGFycmF5TGlrZUtleXMgPSByZXF1aXJlKCcuL19hcnJheUxpa2VLZXlzJyksXG4gICAgYmFzZUtleXNJbiA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzSW4nKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5c0luO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gbGVuZ3RoID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGFzdDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyk7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKSxcbiAgICBiYXNlVW5zZXQgPSByZXF1aXJlKCcuL19iYXNlVW5zZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBjdXN0b21PbWl0Q2xvbmUgPSByZXF1aXJlKCcuL19jdXN0b21PbWl0Q2xvbmUnKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0JyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tgOyB0aGlzIG1ldGhvZCBjcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGVcbiAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGNvbnNpZGVyYWJseSBzbG93ZXIgdGhhbiBgXy5waWNrYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAnMicsICdjJzogMyB9O1xuICpcbiAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICogLy8gPT4geyAnYic6ICcyJyB9XG4gKi9cbnZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgdmFyIGlzRGVlcCA9IGZhbHNlO1xuICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgaXNEZWVwIHx8IChpc0RlZXAgPSBwYXRoLmxlbmd0aCA+IDEpO1xuICAgIHJldHVybiBwYXRoO1xuICB9KTtcbiAgY29weU9iamVjdChvYmplY3QsIGdldEFsbEtleXNJbihvYmplY3QpLCByZXN1bHQpO1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmVzdWx0ID0gYmFzZUNsb25lKHJlc3VsdCwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfRkxBVF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21PbWl0Q2xvbmUpO1xuICB9XG4gIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGJhc2VVbnNldChyZXN1bHQsIHBhdGhzW2xlbmd0aF0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBvbWl0O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHViQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkZhbHNlO1xuIiwidmFyIGJhc2VUb1N0cmluZyA9IHJlcXVpcmUoJy4vX2Jhc2VUb1N0cmluZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9TdHJpbmc7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtcyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpIHx8XG4gICAgcGx1cmFsKG1zLCBoLCAnaG91cicpIHx8XG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcbiAgICBwbHVyYWwobXMsIHMsICdzZWNvbmQnKSB8fFxuICAgIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKG1zIDwgbiAqIDEuNSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICB9XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgb21pdCA9IHJlcXVpcmUoXCJsb2Rhc2gvb21pdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBvbWl0RGVlcExvZGFzaChpbnB1dCwgcHJvcHMpIHtcbiAgZnVuY3Rpb24gb21pdERlZXBPbk93blByb3BzKG9iaikge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqKSAmJiAhaXNPYmplY3Qob2JqKSkge1xuICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICByZXR1cm4gb21pdERlZXBMb2Rhc2gob2JqLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIG8gPSB7fTtcbiAgICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gICAgdmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAodmFyIF9pdGVyYXRvciA9IE9iamVjdC5lbnRyaWVzKG9iailbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwLnZhbHVlLCAyKSxcbiAgICAgICAgICAgIGtleSA9IF9zdGVwJHZhbHVlWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfc3RlcCR2YWx1ZVsxXTtcblxuICAgICAgICBvW2tleV0gPSAhaXNOaWwodmFsdWUpID8gb21pdERlZXBMb2Rhc2godmFsdWUsIHByb3BzKSA6IHZhbHVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvbWl0KG8sIHByb3BzKTtcbiAgfVxuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgIHByb3BzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5zbGljZSgxKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgIHJldHVybiBpbnB1dC5tYXAob21pdERlZXBPbk93blByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBvbWl0RGVlcE9uT3duUHJvcHMoaW5wdXQpO1xufTtcblxuZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09IFwiW29iamVjdCBPYmplY3RdXCI7XG59IiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgY3VycnkyID0gcmVxdWlyZSgnY3VycnkyJylcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NlbGVjdG4nKVxudmFyIGRvdHRlZCA9IHJlcXVpcmUoJ2JyYWNrZXRzMmRvdHMnKVxudmFyIHNwbGl0cyA9IHJlcXVpcmUoJ2RvdHNwbGl0LmpzJylcbnZhciBzdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gY3VycnkyKHNlbGVjdG4pXG5cbi8qKlxuICogQ3VycmllZCBwcm9wZXJ0eSBhY2Nlc3NvciBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGRlZXBseS1uZXN0ZWQgb2JqZWN0IHByb3BlcnRpZXMgdmlhIGRvdC9icmFja2V0LW5vdGF0aW9uXG4gKiBzdHJpbmcgcGF0aCB3aGlsZSBtaXRpZ2F0aW5nIGBUeXBlRXJyb3JzYCB2aWEgZnJpZW5kbHkgYW5kIGNvbXBvc2FibGUgQVBJLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBwYXRoXG4gKiBEb3QvYnJhY2tldC1ub3RhdGlvbiBzdHJpbmcgcGF0aCBvciBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gKiBPYmplY3QgdG8gYWNjZXNzLlxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufCp8dW5kZWZpbmVkfVxuICogKDEpIHJldHVybnMgYHNlbGVjdG4vMWAgd2hlbiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAqICgyKSByZXR1cm5zIHZhbHVlIGF0IHBhdGggaWYgcGF0aCBleGlzdHMuXG4gKiAoMykgcmV0dXJucyB1bmRlZmluZWQgaWYgcGF0aCBkb2VzIG5vdCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0biAocGF0aCwgb2JqZWN0KSB7XG4gIGRlYnVnKCdhcmd1bWVudHM6Jywge1xuICAgIHBhdGg6IHBhdGgsXG4gICAgb2JqZWN0OiBvYmplY3RcbiAgfSlcblxuICB2YXIgaWR4ID0gLTFcbiAgdmFyIHNlZyA9IHN0cmluZy5jYWxsKHBhdGgpID09PSAnW29iamVjdCBBcnJheV0nID8gcGF0aCA6IHNwbGl0cyhkb3R0ZWQocGF0aCkpXG4gIHZhciBlbmQgPSBzZWcubGVuZ3RoXG4gIHZhciByZWYgPSBlbmQgPyBvYmplY3QgOiB2b2lkIDBcblxuICB3aGlsZSAoKytpZHggPCBlbmQpIHtcbiAgICBpZiAoT2JqZWN0KHJlZikgIT09IHJlZikgcmV0dXJuIHZvaWQgMFxuICAgIHJlZiA9IHJlZltzZWdbaWR4XV1cbiAgfVxuXG4gIGRlYnVnKCdyZWY6JywgcmVmKVxuICByZXR1cm4gdHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJyA/IHJlZigpIDogcmVmXG59XG4iLCJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCIvKipcclxuICogQXJyYXkgTWV0aG9kc1xyXG4gKiBAbW9kdWxlIEFycmF5VXRpbHNcclxuICovXHJcblxyXG5pbXBvcnQgTGFuZ1V0aWxzIGZyb20gJ2xhbmctdXRpbHMnO1xyXG5pbXBvcnQgX3VuaXEgZnJvbSAnbG9kYXNoLnVuaXEnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXJyYXlVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIGFuIGFycmF5IHRvIHRoZSBlbmQgb2YgYW5vdGhlciBhcnJheS4gVGhlIGFycmF5cyBjYW4gY29udGFpbiBhbnkgdHlwZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB0b0FyciAgICAgVGhlIGFycmF5IHRvIG1lcmdlIGludG8uXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmcm9tQXJyICAgVGhlIGFycmF5IHRvIGJlIG1lcmdlZC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIG1lcmdlKHRvQXJyLCBmcm9tQXJyKSB7XHJcbiAgICAgICAgaWYgKExhbmdVdGlscy5pc0FycmF5KHRvQXJyKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFuZEluc2VydCh0b0FyciwgdG9BcnIubGVuZ3RoLCAwLCBmcm9tQXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgaXRlbSBmcm9tIGFycmF5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyciAgICAgICBUaGUgYXJyYXkgdG8gbWFuaXB1bGF0ZS5cclxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAgICBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gYmUgcmVtb3ZlZCwgaXQgc2hvdWxkIGJlIGFuIGludGVnZXIgPj0gMC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlbW92ZUF0KGFyciwgaW5kZXgpIHtcclxuICAgICAgICBpbmRleCA9IE51bWJlcihpbmRleCk7XHJcbiAgICAgICAgaWYgKExhbmdVdGlscy5pc0FycmF5KGFycikgJiYgaW5kZXggPCBhcnIubGVuZ3RoICYmIGluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgYXJyLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwbGFjZSAocGFydCBvZikgYW4gYXJyYXkgd2l0aCBpdGVtcyBmcm9tIGFub3RoZXIgYXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyICAgICAgICAgICAgICAgVGhlIGFycmF5IHRvIG1hbmlwdWxhdGUuXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRJbmRleCAgICAgICBTdGFydCBpbmRleCBvZiB0aGUgcGFydCBvZiB0aGUgYXJyYXkgdG8gYmUgcmVwbGFjZWQsIGl0IHNob3VsZFxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgYW4gaW50ZWdlciA+PSAwLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmRJbmRleF0gICAgICAgQW4gb3B0aW9uYWwgZW5kIGluZGV4IG9mIHRoZSBwYXJ0IG9mIHRoZSBhcnJheSB0byBiZSByZXBsYWNlZCwgVG9cclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSBpdGVtcywgYW4gZW5kIGluZGV4IHNob3VsZCBiZSA+PSBzdGFydEluZGV4IHZhbHVlLCBhbHRlcm5hdGl2ZWx5XHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhIG5ldyBhcnJheSBjYW4gYmUgaW5zZXJ0ZWQgYnkgc2V0dGluZyBlbmQgaW5kZXggdG8gbnVsbC5cclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtpbnNlcnRBcnI9W11dICAgIEFuIG9wdGlvbmFsIGFycmF5IHRvIGFkZCBpbiB0aGUgcGxhY2Ugb2YgdGhlIHJlbW92ZWQgcGFydC4gVGhpc1xyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIGFuIGVtcHR5IGFycmF5LlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVtb3ZlQW5kSW5zZXJ0KGFyciwgc3RhcnRJbmRleCwgZW5kSW5kZXgsIGluc2VydEFycikge1xyXG4gICAgICAgIHN0YXJ0SW5kZXggPSBOdW1iZXIoc3RhcnRJbmRleCk7XHJcbiAgICAgICAgZW5kSW5kZXggPSBOdW1iZXIoZW5kSW5kZXgpO1xyXG5cclxuICAgICAgICBjb25zdCBudW1JdGVtcyA9IGVuZEluZGV4ID49IHN0YXJ0SW5kZXggPyBlbmRJbmRleCAtIHN0YXJ0SW5kZXggKyAxIDogMDtcclxuXHJcbiAgICAgICAgaWYgKCFMYW5nVXRpbHMuaXNBcnJheShpbnNlcnRBcnIpKSB7XHJcbiAgICAgICAgICAgIGluc2VydEFyciA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTGFuZ1V0aWxzLmlzQXJyYXkoYXJyKSAmJiBzdGFydEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgYXJyLnNwbGljZShzdGFydEluZGV4LCBudW1JdGVtcywgLi4uaW5zZXJ0QXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGR1cGxpY2F0ZSBpdGVtcyBmcm9tIGFuIGFycmF5ICh1c2VzIExvZGFzaCB1bmlxIG1ldGhvZCkuXHJcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydHMgbmVzdGVkIGFycmF5cy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnIgICAgICAgVGhlIGFycmF5IHRvIG1hbmlwdWxhdGVcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBOZXcgYXJyYXkgd2l0aG91dCBkdXBsaWNhdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogQXJyYXlVdGlscy51bmlxKFsyLCAxLCAyXSk7XHJcbiAgICAgKiAvLyA9PiBbMiwgMV1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVuaXEoYXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIF91bmlxKGFycik7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggZm9yIGFuIGVsZW1lbnQgaW4gYW4gQXJyYXkuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgICAgICAgICAgICAgICAgIFRoZSBhcnJheSB0byBiZSBzZWFyY2hlZC5cclxuICAgICAqIEBwYXJhbSB7Kn0gc2VhcmNoRWxlbWVudCAgICAgICAgICAgICBUaGUgZWxlbWVudCB0byBzZWFyY2ggZm9yLlxyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXg9MF0gICAgICAgIFRoZSBpbmRleCB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS4gSXQgc2hvdWxkIGJlIGFuIGludGVnZXIgPj0gMC5cclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpc0VxdWFsRnVuY10gICAgICBBIGN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvbiB0byB1c2UgZm9yIHRoZSBzZWFyY2guXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7aW50fSAgICAgICAgICAgICAgICAgICAgICAgIEVsZW1lbnQgc2VhcmNoIEluZGV4LiBJZiBlbGVtZW50IGlzIG5vdCBmb3VuZCwgaXQgcmV0dXJucyAtMS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIEFycmF5VXRpbHMuaW5kZXhPZihbJ2EnLCAnYWInLCAnYWJjJ10sICdhYicpO1xyXG4gICAgICogLy8gPT4gMVxyXG4gICAgICpcclxuICAgICAqIEFycmF5VXRpbHMuaW5kZXhPZihbWzEsIDJdLCBudWxsLCBbMSwgM10sIHVuZGVmaW5lZCwgJ2EnXSwgWzEsIDNdLCAwLFxyXG4gICAgICogIChhLCBiKSA9PiAoKGEgPT09IGIpIHx8IChhICYmIGIgJiYgYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCkpKSk7XHJcbiAgICAgKiAvLyA9PiAyXHJcbiAgICAgKlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW5kZXhPZihhcnJheSwgc2VhcmNoRWxlbWVudCwgZnJvbUluZGV4LCBpc0VxdWFsRnVuYykge1xyXG4gICAgICAgIGlmICghTGFuZ1V0aWxzLmlzQXJyYXkoYXJyYXkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICghTGFuZ1V0aWxzLmlzTnVtYmVyKGZyb21JbmRleCkgfHwgZnJvbUluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICBmcm9tSW5kZXggPSAwO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKExhbmdVdGlscy5pc0Z1bmN0aW9uKGlzRXF1YWxGdW5jKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gZnJvbUluZGV4OyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc0VxdWFsRnVuYyhhcnJheVtpXSwgc2VhcmNoRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnJheS5pbmRleE9mKHNlYXJjaEVsZW1lbnQsIGZyb21JbmRleCk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEFycmF5VXRpbHMgZnJvbSAnYXJyYXktdXRpbHMnO1xyXG5pbXBvcnQgTGFuZ1V0aWxzIGZyb20gJ2xhbmctdXRpbHMnO1xyXG5pbXBvcnQgTG9nZ2VyIGZyb20gJ2xvZ2dlcic7XHJcbmltcG9ydCBOb2RlVXRpbHMgZnJvbSAnbm9kZS11dGlscyc7XHJcbmltcG9ydCBOdW1iZXJVdGlscyBmcm9tICdudW1iZXItdXRpbHMnO1xyXG5pbXBvcnQgT2JqZWN0VXRpbHMgZnJvbSAnb2JqZWN0LXV0aWxzJztcclxuaW1wb3J0IFByb21pc2VVdGlscyBmcm9tICdwcm9taXNlLXV0aWxzJztcclxuaW1wb3J0IFN0cmluZ1V0aWxzIGZyb20gJ3N0cmluZy11dGlscyc7XHJcblxyXG5leHBvcnQge1xyXG4gICAgQXJyYXlVdGlscyxcclxuICAgIExhbmdVdGlscyxcclxuICAgIExvZ2dlcixcclxuICAgIE5vZGVVdGlscyxcclxuICAgIE51bWJlclV0aWxzLFxyXG4gICAgT2JqZWN0VXRpbHMsXHJcbiAgICBQcm9taXNlVXRpbHMsXHJcbiAgICBTdHJpbmdVdGlsc1xyXG59O1xyXG4iLCIvKipcclxuICogQmFzaWMgSmF2YVNjcmlwdCBMYW5ndWFnZSBkZXYgdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgTGFuZ1V0aWxzXHJcbiAqL1xyXG5cclxuaW1wb3J0IF9jbG9uZURlZXAgZnJvbSAnbG9kYXNoLmNsb25lZGVlcCc7XHJcbmltcG9ydCBfY2xvbmUgZnJvbSAnbG9kYXNoLmNsb25lJztcclxuaW1wb3J0IF9pc0VtcHR5IGZyb20gJ2xvZGFzaC5pc2VtcHR5JztcclxuaW1wb3J0IF9pc0VxdWFsIGZyb20gJ2xvZGFzaC5pc2VxdWFsJztcclxuaW1wb3J0IHNlbGVjdG4gZnJvbSAnc2VsZWN0bic7XHJcbmltcG9ydCBfb21pdERlZXAgZnJvbSAnb21pdC1kZWVwLWxvZGFzaCc7XHJcblxyXG5mdW5jdGlvbiBjaGVja1R5cGUoeCwgdHlwZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB4ID09PSB0eXBlO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYW5nVXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlIGphdmFzY3JpcHQgZnVuY3Rpb24gd2l0aCBnaXZlbiBhcmd1bWVudHMuIElmIHRoZSBleGVjdXRpb24gZmFpbHMsIHJldHVybiBhIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtICB7RnVuY3Rpb259IGZ1bmMgICAgICAgICAgSmF2YVNjcmlwdCBmdW5jdGlvbi5cclxuICAgICAqIEBwYXJhbSAgeyp9IGRlZmF1bHRWYWx1ZSAgICAgICAgIFRoaXMgY2FuIGJlIGFueSB2YWx1ZS5cclxuICAgICAqIEBwYXJhbSAgey4uLip9IGFyZ3MgICAgICAgICAgICAgIFRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gb3V0cHV0IG9yIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgKlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqIGxldCB2YWx1ZSA9IDJcclxuICAgICAqIExhbmdVdGlscy5zY3JpcHRFeGVjdXRlKHggPT4geCAqIHgsIDAsIHZhbHVlKSAvLz0+IDRcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzY3JpcHRFeGVjdXRlKGZ1bmMsIGRlZmF1bHRWYWx1ZSwgLi4uYXJncykge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jKC4uLmFyZ3MpO1xyXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2NyaXB0RXhlY3V0ZSBleGNlcHRpb246ICcsIGVycik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBhcnJheS5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhbiBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0FycmF5KHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09iamVjdExpa2UoeCkgJiYgeCBpbnN0YW5jZW9mIEFycmF5O1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBib29sZWFuLlxyXG4gICAgICogQHBhcmFtICB7Kn0geCAgICAgICAgICAgICAgICBBY2NlcHRzIGFueSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgdHJ1ZSBpZiB4IGlzIGEgYm9vbGVhbiwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0Jvb2xlYW4oeCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1R5cGUoeCwgJ2Jvb2xlYW4nKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmeSBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgZGF0ZS5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtEYXRlfSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhIGRhdGUsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNEYXRlKHgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc09iamVjdExpa2UoeCkgJiYgeCBpbnN0YW5jZW9mIERhdGU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIEhUTUwgZWxlbWVudC5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhIEhUTUwgZWxlbWVudCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VsZW1lbnQoeCkge1xyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICAgIHRoaXMuaXNPYmplY3RMaWtlKHgpICYmXHJcbiAgICAgICAgICAgIHRoaXMuc2NyaXB0RXhlY3V0ZShcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uICh4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBmYWxzZSxcclxuICAgICAgICAgICAgICAgIHhcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBlbXB0eSB2YWx1ZSAgKHVzZXMgTG9kYXNoIGlzRW1wdHkgbWV0aG9kKS5cclxuICAgICAqIENoZWNrcyBpZiB2YWx1ZSBpcyBhbiBlbXB0eSBvYmplY3QsIGNvbGxlY3Rpb24sIG1hcCwgb3Igc2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhbiBlbXB0eSB2YWx1ZSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VtcHR5KHgpIHtcclxuICAgICAgICByZXR1cm4gX2lzRW1wdHkoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtICB7Kn0geCAgICAgICAgICAgICAgICBBY2NlcHRzIGFueSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgdHJ1ZSBpZiB4IGlzIGFuIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRnVuY3Rpb24oeCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1R5cGUoeCwgJ2Z1bmN0aW9uJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlci5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhbiBudW1iZXIsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNOdW1iZXIoeCkge1xyXG4gICAgICAgIHJldHVybiBjaGVja1R5cGUoeCwgJ251bWJlcicpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBudW1iZXIgbGlrZS5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBudW1iZXIgbGlrZSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc051bWJlckxpa2UoeCkge1xyXG4gICAgICAgIHJldHVybiB4ICE9PSBudWxsICYmICFpc05hTih4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmeSBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIG9iamVjdCBsaWtlIG9yIG5vdC5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBvYmplY3QgbGlrZSwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc09iamVjdExpa2UoeCkge1xyXG4gICAgICAgIHJldHVybiB4ICE9PSBudWxsICYmIGNoZWNrVHlwZSh4LCAnb2JqZWN0Jyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdCBvciBub3QuXHJcbiAgICAgKiBAcGFyYW0gIHsqfSB4ICAgICAgICAgICAgICAgIEFjY2VwdHMgYW55IHZhbHVlLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICB0cnVlIGlmIHggaXMgYSBwbGFpbiBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNQbGFpbk9iamVjdCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3RMaWtlKHgpICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmeSBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgcmVndWxhciBleHByZXNzaW9uIG9yIG5vdC5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1JlZ0V4cCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNPYmplY3RMaWtlKHgpICYmIHggaW5zdGFuY2VvZiBSZWdFeHA7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHRydWUgdmFsdWUgb3Igbm90LlxyXG4gICAgICogQHBhcmFtICB7Kn0geCAgICAgICAgICAgICAgICBBY2NlcHRzIGFueSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgdHJ1ZSBpZiB4IGlzIGEgdHJ1ZSB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNUcnVlKHgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuaXNBcnJheSh4KSB8fCB0aGlzLmlzUGxhaW5PYmplY3QoeCkgfHwgdGhpcy5pc1N0cmluZyh4KSkgPyAhdGhpcy5pc0VtcHR5KHgpIDogQm9vbGVhbih4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFZlcmlmeSBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nIG9yIG5vdC5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhIHN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1N0cmluZyh4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrVHlwZSh4LCAnc3RyaW5nJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYSBnaXZlbiB2YWx1ZSBpcyB1bmRlZmluZWQgb3Igbm90LlxyXG4gICAgICogQHBhcmFtICB7Kn0geCAgICAgICAgICAgICAgICBBY2NlcHRzIGFueSB2YWx1ZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgdHJ1ZSBpZiB4IGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1VuZGVmaW5lZCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrVHlwZSh4LCAndW5kZWZpbmVkJyk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBzaGFsbG93IGNsb25lIG9iamVjdCAodXNlcyBMb2Rhc2ggY2xvbmUgbWV0aG9kKS5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgIGNsb25lZCBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjbG9uZSh4KSB7XHJcbiAgICAgICAgcmV0dXJuIF9jbG9uZSh4KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIGRlZXAgY2xvbmUgb2JqZWN0ICh1c2VzIExvZGFzaCBjbG9uZURlZXAgbWV0aG9kKS5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgIGRlZXAgY2xvbmVkIG9iamVjdC5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNsb25lRGVlcCh4KSB7XHJcbiAgICAgICAgcmV0dXJuIF9jbG9uZURlZXAoeCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXHJcbiAgICAgKiBlcXVpdmFsZW50ICh1c2VzIExvZGFzaCBpc0VxdWFsIG1ldGhvZCkuXHJcbiAgICAgKlxyXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxyXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxyXG4gICAgICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcclxuICAgICAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxyXG4gICAgICogbm9kZXMgYXJlICoqbm90Kiogc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEBjYXRlZ29yeSBMYW5nXHJcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxyXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cclxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XHJcbiAgICAgKiB2YXIgb3RoZXIgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XHJcbiAgICAgKlxyXG4gICAgICogTGFuZ1V0aWxzLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XHJcbiAgICAgKiAvLyA9PiB0cnVlXHJcbiAgICAgKlxyXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xyXG4gICAgICAgIHJldHVybiBfaXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgdmFsdWUgZnJvbSBhIEpTT04gb2JqZWN0IGF0IGEgZ2l2ZW4gcGF0aC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0ganNvbiAgICAgICAgICAgICAgICAgSlNPTiBvYmplY3RcclxuICAgICAqIEBwYXJhbSB7KHN0cmluZ1xcfHN0cmluZ1tdKX0gcGF0aCAgICAgRG90L2JyYWNrZXQtbm90YXRpb24gc3RyaW5nIHBhdGggb3IgYXJyYXkuXHJcbiAgICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgYXQgZ2l2ZW4gcGF0aFxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBMYW5nVXRpbHMucXVlcnkoeydhJzogWydiJywgJ2MnXX0sICdhWzFdJyk7XHJcbiAgICAgKiAvLz0+ICdjJ1xyXG4gICAgICpcclxuICAgICAqIExhbmdVdGlscy5xdWVyeSh7J2EnOiBbJ2InLCAnYyddfSwgWydhJywgMV0pXHJcbiAgICAgKiAvLz0+ICdjJ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcXVlcnkoanNvbiwgcGF0aCkge1xyXG4gICAgICAgIGlmICgodGhpcy5pc0FycmF5KGpzb24pIHx8IHRoaXMuaXNQbGFpbk9iamVjdChqc29uKSkgJiYgKHRoaXMuaXNBcnJheShwYXRoKSB8fCB0aGlzLmlzU3RyaW5nKHBhdGgpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0bihwYXRoLCBqc29uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGaWx0ZXIgb3V0IGtleXMgZnJvbSBhbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0ICAgICAgVGhlIGlucHV0IG9iamVjdC5cclxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gcHJvcHMgICAgICBLZXlzIHRvIGJlIG9taXR0ZWQgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgb2JqZWN0IHdpdGgga2V5cyBvbWl0dGVkLlxyXG4gICAgICogQGV4YW1wbGVcclxuICAgICAqXHJcbiAgICAgKiBMYW5nVXRpbHMub21pdERlZXAoe2E6IFwiYVwiLCBiOiBcImJcIiwgYzoge2I6IFwiYlwiLCBkOiB7YjogXCJiXCIsIGY6IFwiZlwifX19LCBcImJcIik7XHJcbiAgICAgKiAvLz0+IHthOiBcImFcIiwgYzoge2Q6IHtmOiBcImZcIn19fVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb21pdERlZXAob2JqZWN0LCAuLi5wcm9wcykge1xyXG4gICAgICAgIHJldHVybiBfb21pdERlZXAuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgTGFuZ1V0aWxzIGZyb20gJ2xhbmctdXRpbHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nZ2VyIHtcclxuICAgIHN0YXRpYyBsb2coLi4ubXNnKSB7XHJcbiAgICAgICAgaWYgKExhbmdVdGlscy5pc09iamVjdExpa2UoY29uc29sZSkgJiYgTGFuZ1V0aWxzLmlzRnVuY3Rpb24oY29uc29sZS5sb2cpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKC4uLm1zZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChMYW5nVXRpbHMuaXNGdW5jdGlvbihwcmludCkpIHsgLy8gdG8gc3VwcG9ydCBuYXNob3JuIGVuZ2luZVxyXG4gICAgICAgICAgICBwcmludCguLi5tc2cpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKipcclxuICogTm9kZSBlbnYgcmVsYXRlZCBkZXYgdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgTm9kZVV0aWxzXHJcbiAqL1xyXG5pbXBvcnQgTGFuZ1V0aWxzIGZyb20gJ2xhbmctdXRpbHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTm9kZVV0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIGEgd2luZG93IG9iamVjdCBpcyBhdmFpbGFibGUuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICB0cnVlIGlmIGEgd2luZG93IG9iamVjdCBpcyBhdmFpbGFibGUsIG90aGVyd2lzZSBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNXaW5kb3dBdmFpbGFibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIExhbmdVdGlscy5zY3JpcHRFeGVjdXRlKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4od2luZG93KTtcclxuICAgICAgICB9LCBmYWxzZSk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIEFycmF5IHJlbGF0ZWQgZGV2IHV0aWxpdGllc1xyXG4gKiBAbW9kdWxlIE51bWJlclV0aWxzXHJcbiAqL1xyXG5cclxuaW1wb3J0IExhbmdVdGlscyBmcm9tICdsYW5nLXV0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE51bWJlclV0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYW4gaW50ZWdlci5cclxuICAgICAqIEBwYXJhbSAgeyp9IHggICAgICAgICAgICAgICAgQWNjZXB0cyBhbnkgdmFsdWUuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgIHRydWUgaWYgeCBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgZmFsc2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzSW50ZWdlcih4KSB7XHJcbiAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgTGFuZ1V0aWxzLmlzTnVtYmVyKHgpICYmXHJcbiAgICAgICAgICAgIChMYW5nVXRpbHMuaXNGdW5jdGlvbihOdW1iZXIuaXNJbnRlZ2VyKSA/IE51bWJlci5pc0ludGVnZXIoeCkgOiBNYXRoLmZsb29yKHgpID09PSB4KVxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn1cclxuIiwiLyoqXHJcbiAqIE9iamVjdCByZWxhdGVkIGRldiB1dGlsaXRpZXNcclxuICogQG1vZHVsZSBPYmplY3RVdGlsc1xyXG4gKi9cclxuXHJcbmltcG9ydCBMYW5nVXRpbHMgZnJvbSAnbGFuZy11dGlscyc7XHJcbmltcG9ydCBBcnJheVV0aWxzIGZyb20gJ2FycmF5LXV0aWxzJztcclxuXHJcbmZ1bmN0aW9uIGdldEtleXNGcm9tUHJvcGVydGllcyhvYmopIHtcclxuICAgIGxldCBpbnRlcm5hbEtleXMgPSBbXTtcclxuXHJcbiAgICBpZiAoTGFuZ1V0aWxzLmlzUGxhaW5PYmplY3Qob2JqKSkge1xyXG4gICAgICAgIGZvciAobGV0IGkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcclxuICAgICAgICAgICAgICAgIGludGVybmFsS2V5cy5wdXNoKGkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGludGVybmFsS2V5cztcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT2JqZWN0VXRpbHMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYXJyYXkgb2Yga2V5cyBmcm9tIGEgcGxhaW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICAgICBQbGFpbiBvYmplY3RcclxuICAgICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICBBcnJheSB3aXRoIGFsbCBrZXlzIG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBrZXlzKG9iaikge1xyXG4gICAgICAgIHJldHVybiBMYW5nVXRpbHMuaXNQbGFpbk9iamVjdChvYmopICYmIExhbmdVdGlscy5pc0Z1bmN0aW9uKE9iamVjdC5rZXlzKSA/XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikgOlxyXG4gICAgICAgICAgICBnZXRLZXlzRnJvbVByb3BlcnRpZXMob2JqKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBhcnJheSBvZiB2YWx1ZXMgZnJvbSBhIHBsYWluIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqICAgICAgUGxhaW4gb2JqZWN0XHJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgQXJyYXkgd2l0aCBhbGwgdmFsdWVzIG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB2YWx1ZXMob2JqKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cyhvYmopLm1hcChrZXkgPT4gb2JqW2tleV0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVmVyaWZ5IGlmIGEgZ2l2ZW4ga2V5IGlzIHByZXNlbnQgaW4gYW4gb2JqZWN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICAgICBQbGFpbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5ICAgICAgS2V5IHZhbHVlLlxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIHRydWUgaWYga2V5IGlzIHByZXNlbnQsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbnRhaW5zS2V5KG9iaiwga2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIExhbmdVdGlscy5pc1BsYWluT2JqZWN0KG9iaikgPyBvYmouaGFzT3duUHJvcGVydHkoa2V5KSA6IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgdmFsdWUgZnJvbSBhbiBvYmplY3QgZm9yIGEgZ2l2ZW4ga2V5LCBpZiB0aGUga2V5IGlzIG5vdCBwcmVzZW50IHJldHVybiBkZWZhdWx0IHZhbHVlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICAgICAgICAgICAgICAgICBQbGFpbiBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5ICAgICAgICAgICAgICAgICAgS2V5IHZhbHVlLlxyXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlID0gbnVsbF0gICAgIFZhbHVlIHRvIGJlIHJldHVybmVkIGlmIHRoZSBrZXkgaXMgbm90IHByZXNlbnQgaW4gdGhlIG9iamVjdC5cclxuICAgICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICAgICAgICAgICBWYWx1ZSBmb3IgdGhlIGdpdmVuIGtleSBmcm9tIHRoZSBvYmplY3QsIG9yIGRlZmF1bHQgdmFsdWUuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRWYWx1ZShvYmosIGtleSwgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnNLZXkob2JqLCBrZXkpID8gb2JqW2tleV0gOiBkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJpZnkgaWYgYWxsIGVsZW1lbnRzIG9mIGEgZ2l2ZW4gYXJyYXkgYXJlIHBsYWluIG9iamVjdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqQXJyYXkgICAgICAgICAgICAgICAgICAgICAgQXJyYXkgdG8gaW5zcGVjdC5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzUmVjdXJzaXZlPWZhbHNlXSAgICAgICAgIFZlcmlmeSBuZXN0ZWQgYXJyYXlzIGFzIHdlbGwuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnVlIGlmIGFycmF5IGlzIGFuIGFycmF5IG9mIG9iamVjdHMsIG90aGVyd2lzZSBmYWxzZS5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIE9iamVjdFV0aWxzLmlzUGxhaW5PYmplY3RBcnJheShbe2g6ICdoJ30sIFt7azogJ2snfV1dKTtcclxuICAgICAqIC8vID0+IGZhbHNlXHJcbiAgICAgKlxyXG4gICAgICogT2JqZWN0VXRpbHMuaXNQbGFpbk9iamVjdEFycmF5KFt7aDogJ2gnfSwgW3trOiAnayd9XV0sIHRydWUpO1xyXG4gICAgICogLy8gPT4gdHJ1ZVxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzUGxhaW5PYmplY3RBcnJheShvYmpBcnJheSwgaXNSZWN1cnNpdmUpIHtcclxuICAgICAgICBpZiAoIUxhbmdVdGlscy5pc0FycmF5KG9iakFycmF5KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqQXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgIUxhbmdVdGlscy5pc1BsYWluT2JqZWN0KG9iakFycmF5W2ldKSAmJlxyXG4gICAgICAgICAgICAgICAgLy8gc3VwcG9ydCBmb3IgbmVzdGVkIGxldmVscyBvZiBhcnJheXNcclxuICAgICAgICAgICAgICAgICghaXNSZWN1cnNpdmUgfHwgIXRoaXMuaXNQbGFpbk9iamVjdEFycmF5KG9iakFycmF5W2ldLCBpc1JlY3Vyc2l2ZSkpXHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE1lcmdlIG9uZSBvYmplY3QgaW50byBhbm90aGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0b0RpY3QgICAgICAgICAgICAgICAgICAgICAgIE9yaWdpbmFsIG9iamVjdCBvbiB3aGljaCBtZXJnZSBvcGVyYXRpb24gaXMgZ29pbmcgdG8gYmUgcGVyZm9ybWVkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZyb21EaWN0ICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IHRvIGJlIG1lcmdlZC5cclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlY3Vyc2l2ZT1mYWxzZV0gICAgICAgICAgIFBlcmZvcm0gYSByZWN1cnNpdmUgbWVyZ2UuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtub3RPdmVycmlkZT1mYWxzZV0gICAgICAgICBPdmVyaWRlIHBhcmFtZXRlcnMgaW4gb3JpZ2luYWwgb2JqZWN0IHdpdGggcGFyYW1ldGVycyBmcm9tXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0by1iZS1tZXJnZWQgb2JqZWN0LiBCeSBkZWZhdWx0IG92ZXJyaWRlIGlzIHRydWUuXHJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpZ25vcmVOdWxsPWZhbHNlXSAgICAgICAgICBDb25zaWRlciBrZXlzIHdpdGggbnVsbCB2YWx1ZXMuIEJ5IGRlZmF1bHQgbnVsbCB2YWx1ZXMgd2lsbCBiZVxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VkLlxyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBbZXh0ZW5kT2JqZWN0QXJyYXk9ZmFsc2VdICAgRXh0ZW5kIGFycmF5cy4gSWYgdHJ1ZSBhcnJheXMgd2lsbCBiZSBleHRlbmRlZCwgaWYgZmFsc2UgKGRlZmF1bHQpXHJcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJheXMgd2lsbCBiZSBvdmVycmlkZGVuIGJhc2VkIG9uIHRoZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAZXhhbXBsZVxyXG4gICAgICpcclxuICAgICAqIGxldCB0b0RpY3QgPSB7YTogJzEnLCBiOiB7YzogJzEnLCBlOiBudWxsfSwgZjogW3tnOiAnMSd9XSB9O1xyXG4gICAgICogbGV0IGZyb21EaWN0ID0ge2I6IHtjOiAnMicsIGQ6ICcyJywgZTogJzInfSwgZjogW3tnOiAnMid9XSB9O1xyXG4gICAgICogT2JqZWN0VXRpbHMubWVyZ2UodG9EaWN0LCBmcm9tRGljdCk7XHJcbiAgICAgKiAvLyA9PiB0b0RpY3QgaXMgdXBkYXRlZCBhcyB7YTogJzEnLCBiOiB7YzogJzInLCBkOiAnMicsIGU6ICcyJ30sIGY6IFt7ZzogJzInfV19XHJcbiAgICAgKlxyXG4gICAgICogbGV0IHRvRGljdCA9IHthOiAnMScsIGI6IHtjOiAnMScsIGU6IG51bGx9LCBmOiBbe2c6ICcxJ31dIH07XHJcbiAgICAgKiBsZXQgZnJvbURpY3QgPSB7Yjoge2M6ICcyJywgZDogJzInLCBlOiAnMid9LCBmOiBbe2c6ICcyJ31dIH07XHJcbiAgICAgKiBPYmplY3RVdGlscy5tZXJnZSh0b0RpY3QsIGZyb21EaWN0LCB0cnVlLCB0cnVlLCB0cnVlLCB0cnVlKTtcclxuICAgICAqIC8vID0+IHRvRGljdCBpcyB1cGRhdGVkIGFzIHthOiAnMScsIGI6IHtjOiAnMScsIGQ6ICcyJywgZTogJzInfSwgZjogW3tnOiAnMSd9LCB7ZzogJzInfV19XHJcbiAgICAgKlxyXG4gICAgICogbGV0IHRvRGljdCA9IHthOiAnMScsIGI6IHtjOiAnMScsIGU6IG51bGx9LCBmOiBbe2c6ICcxJ31dIH07XHJcbiAgICAgKiBsZXQgZnJvbURpY3QgPSB7Yjoge2M6ICcyJywgZDogJzInLCBlOiAnMid9LCBmOiBbe2c6ICcyJ31dIH07XHJcbiAgICAgKiBPYmplY3RVdGlscy5tZXJnZSh0b0RpY3QsIGZyb21EaWN0LCB0cnVlLCB0cnVlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICAgKiAvLyA9PiB0b0RpY3QgaXMgdXBkYXRlZCBhcyB7YTogJzEnLCBiOiB7YzogJzEnLCBkOiAnMicsIGU6IG51bGx9LCBmOiBbe2c6ICcxJ30sIHtnOiAnMid9XX1cclxuICAgICAqL1xyXG4gICAgLy8gVE9ETzogc3VwcG9ydCBTeW1ib2xzIGFuZCBCdWZmZXJcclxuICAgIHN0YXRpYyBtZXJnZSh0b0RpY3QsIGZyb21EaWN0LCByZWN1cnNpdmUsIG5vdE92ZXJyaWRlLCBpZ25vcmVOdWxsLCBleHRlbmRPYmplY3RBcnJheSkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlZXBDb3B5RnJvbURpY3RBdHRycyhhdHRyTmFtZSwgdG9EaWN0LCBmcm9tRGljdCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvRGljdFthdHRyTmFtZV0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChMYW5nVXRpbHMuaXNQbGFpbk9iamVjdCh0b0RpY3RbYXR0ck5hbWVdW2ldKSAmJiBMYW5nVXRpbHMuaXNQbGFpbk9iamVjdChmcm9tRGljdFthdHRyTmFtZV1baV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZU1lcmdlKHRvRGljdFthdHRyTmFtZV1baV0sIGZyb21EaWN0W2F0dHJOYW1lXVtpXSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlLWJlZm9yZS1kZWZpbmUsIG1heC1sZW5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VBcnJheXModG9BcnJheSwgZnJvbUFycmF5LCBtZXJnZVN0YXJ0SW5kZXgpIHtcclxuICAgICAgICAgICAgZnJvbUFycmF5ID0gTGFuZ1V0aWxzLmNsb25lRGVlcChmcm9tQXJyYXkuc2xpY2UobWVyZ2VTdGFydEluZGV4KSk7IC8vIG51bGwgdW5kZWZpbmVkIGhhbmRsZWQgYnkgc2xpY2VcclxuICAgICAgICAgICAgQXJyYXlVdGlscy5tZXJnZSh0b0FycmF5LCBmcm9tQXJyYXkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZnVuY3Rpb24gYWRkQWRkaXRpb25hbE5lc3RlZE9ianMoYXR0ck5hbWUsIHRvRGljdCwgZnJvbURpY3QpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VTdGFydEluZGV4ID0gdG9EaWN0W2F0dHJOYW1lXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIG1lcmdlQXJyYXlzKHRvRGljdFthdHRyTmFtZV0sIGZyb21EaWN0W2F0dHJOYW1lXSwgbWVyZ2VTdGFydEluZGV4KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGV4ZWN1dGVNZXJnZSh0b0RpY3QsIGZyb21EaWN0KSB7XHJcbiAgICAgICAgICAgIGlmICh0b0RpY3QgJiYgZnJvbURpY3QgJiYgTGFuZ1V0aWxzLmlzUGxhaW5PYmplY3QodG9EaWN0KSAmJiBMYW5nVXRpbHMuaXNQbGFpbk9iamVjdChmcm9tRGljdCkpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmcm9tRGljdEtleXMgPSBPYmplY3RVdGlscy5rZXlzKGZyb21EaWN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyb21EaWN0S2V5cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhdHRyTmFtZSA9IGZyb21EaWN0S2V5c1tpXTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlY3Vyc2l2ZSBuZXN0ZWQgb2JqZWN0c1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdXJzaXZlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExhbmdVdGlscy5pc1BsYWluT2JqZWN0KHRvRGljdFthdHRyTmFtZV0pICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIExhbmdVdGlscy5pc1BsYWluT2JqZWN0KGZyb21EaWN0W2F0dHJOYW1lXSlcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtbGVuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVNZXJnZSh0b0RpY3RbYXR0ck5hbWVdLCBmcm9tRGljdFthdHRyTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3RVdGlscy5pc1BsYWluT2JqZWN0QXJyYXkodG9EaWN0W2F0dHJOYW1lXSkgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0VXRpbHMuaXNQbGFpbk9iamVjdEFycmF5KGZyb21EaWN0W2F0dHJOYW1lXSlcclxuICAgICAgICAgICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIHJlY3VzaXZlIG5lc3RlZCBvYmplY3RBcnJheXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dGVuZE9iamVjdEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBvdmVycmlkZSBhcnJheSBpdGVtc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVyZ2VBcnJheXModG9EaWN0W2F0dHJOYW1lXSwgZnJvbURpY3RbYXR0ck5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZXBDb3B5RnJvbURpY3RBdHRycyhhdHRyTmFtZSwgdG9EaWN0LCBmcm9tRGljdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRBZGRpdGlvbmFsTmVzdGVkT2JqcyhhdHRyTmFtZSwgdG9EaWN0LCBmcm9tRGljdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhbm90T3ZlcnJpZGUgfHwgLy8gY2hlY2tpbmcgbm90IG92ZXJyaWRlIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICFPYmplY3RVdGlscy5jb250YWluc0tleSh0b0RpY3QsIGF0dHJOYW1lKSB8fCAvLyBjaGVja2luZyBwcm9wZXJ0eSBleGlzdHMgb3Igbm90XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpZ25vcmVOdWxsICYmICF0b0RpY3RbYXR0ck5hbWVdKVxyXG4gICAgICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVja2luZyBpZ25vcmVOdWxsIHByb3BlcnR5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGNvbnRhaW5lciBvYmplY3QsIGNsb25lIGl0IHRvIGRldGFjaCBjb21wbGV0ZWx5IGZyb20gZnJvbURpY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKExhbmdVdGlscy5pc09iamVjdExpa2UoZnJvbURpY3RbYXR0ck5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9EaWN0W2F0dHJOYW1lXSA9IExhbmdVdGlscy5jbG9uZURlZXAoZnJvbURpY3RbYXR0ck5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyIHByaW1pdGl2ZXMgYW5kIGZ1bmN0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9EaWN0W2F0dHJOYW1lXSA9IGZyb21EaWN0W2F0dHJOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgZXhlY3V0ZU1lcmdlKHRvRGljdCwgZnJvbURpY3QpO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBQcm9taXNlIHJlbGF0ZWQgZGV2IHV0aWxpdGllc1xyXG4gKiBAbW9kdWxlIFByb21pc2VVdGlsc1xyXG4gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb21pc2VVdGlscyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIG5ldyBwcm9taXNlIHdpdGggZ2l2ZW4gZGF0YVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7Kn0gZGF0YSAgICAgICAgICBQcm9taXNlIHJlc3VsdCBkYXRhLlxyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX0gICAgICAgIER1bXkgcHJvbWlzZSB3aXRoIGdpdmVuIGRhdGEuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRQcm9taXNlKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBTdHJpbmcgcmVsYXRlZCBkZXYgdXRpbGl0aWVzXHJcbiAqIEBtb2R1bGUgU3RyaW5nVXRpbHNcclxuICovXHJcblxyXG5pbXBvcnQgTGFuZ1V0aWxzIGZyb20gJ2xhbmctdXRpbHMnO1xyXG5pbXBvcnQgT2JqZWN0VXRpbHMgZnJvbSAnb2JqZWN0LXV0aWxzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0cmluZ1V0aWxzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnRlcnBvbGF0ZWQgc3RyaW5nIHdpdGggYSBzdHJpbmcgdGVtcGxhdGUgYW5kIGEgZGF0YSBvYmplY3QuXHJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyICAgICAgICAgICBTdHJpbmcgdGVtcGxhdGUgdG8gYmUgaW50ZXJwb2xhdGVkLlxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtc09iaiAgICAgRGF0YSBvYmplY3QgdG8gdXNlIGluIGludGVycG9sYXRpb24uXHJcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9ICAgICAgICAgICAgICBJbnRlcnBvbGF0ZWQgU3RyaW5nLlxyXG4gICAgICpcclxuICAgICAqIEBleGFtcGxlXHJcbiAgICAgKlxyXG4gICAgICogU3RyaW5nVXRpbHMuaW50ZXJwb2xhdGUoJyR7YX0gJHtifScsIHthOiA1LCBiOiAzfSk7XHJcbiAgICAgKiAvLyA9PiAnNSAzJ1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaW50ZXJwb2xhdGUoc3RyLCBwYXJhbXNPYmopIHtcclxuICAgICAgICBpZiAoIUxhbmdVdGlscy5pc1N0cmluZyhzdHIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gY29weSBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI5MTgyMjQ0L2NvbnZlcnQtYS1zdHJpbmctdG8tYS10ZW1wbGF0ZS1zdHJpbmdcclxuICAgICAgICBpZiAoTGFuZ1V0aWxzLmlzUGxhaW5PYmplY3QocGFyYW1zT2JqKSkge1xyXG4gICAgICAgICAgICBsZXQgcGFyYW1zID0gTGFuZ1V0aWxzLmNsb25lRGVlcChwYXJhbXNPYmopO1xyXG5cclxuICAgICAgICAgICAgLy8gY2xlYW51cCBudW1iZXIgbGlrZSBrZXlzICYgdmFsdWVzXHJcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwYXJhbXMpO1xyXG4gICAgICAgICAgICBrZXlzLmZvckVhY2goa2V5ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChMYW5nVXRpbHMuaXNOdW1iZXJMaWtlKGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBudW1iZXIgbGlrZSBrZXlzXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBMYW5nVXRpbHMuaXNPYmplY3RMaWtlKHBhcmFtc1trZXldKSAmJiAvLyBmaWx0ZXIgcGFyYW0gdmFsdWUgY2xhc3Mgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgIUxhbmdVdGlscy5pc0FycmF5KHBhcmFtc1trZXldKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFMYW5nVXRpbHMuaXNQbGFpbk9iamVjdChwYXJhbXNba2V5XSlcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXNba2V5XTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoTGFuZ1V0aWxzLmlzRnVuY3Rpb24ocGFyYW1zW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlsdGVyIHBhcmFtIHZhbHVlIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXJhbXNba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhcmFtc1trZXldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtS2V5cyA9IE9iamVjdFV0aWxzLmtleXMocGFyYW1zKTtcclxuICAgICAgICAgICAgY29uc3QgcGFyYW1WYWx1ZXMgPSBPYmplY3RVdGlscy52YWx1ZXMocGFyYW1zKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbiguLi5wYXJhbUtleXMsIGByZXR1cm4gXFxgJHtzdHJ9XFxgO2ApKC4uLnBhcmFtVmFsdWVzKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctZnVuY1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG59XHJcbiJdLCJzb3VyY2VSb290IjoiIn0=
